/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("THREE"));
	else if(typeof define === 'function' && define.amd)
		define(["THREE"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("THREE")) : factory(root["THREE"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, (__WEBPACK_EXTERNAL_MODULE_three__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three-loader-3dtiles */ \"./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js\");\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./textarea */ \"./textarea.js\");\n/* harmony import */ var _textarea__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_textarea__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nconst POINT_CLOUD_COLORING = {\n  white: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White,\n  intensity: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Intensity,\n  classification: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Classification,\n  elevation: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.Elevation,\n  rgb: three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.RGB\n};\n/**\n * 3D Tiles component for A-Frame.\n */\n\nAFRAME.registerComponent('loader-3dtiles', {\n  schema: {\n    url: {\n      type: 'string'\n    },\n    cameraEl: {\n      type: 'selector'\n    },\n    maximumSSE: {\n      type: 'int',\n      default: 16\n    },\n    maximumMem: {\n      type: 'int',\n      default: 32\n    },\n    distanceScale: {\n      type: 'number',\n      default: 1.0\n    },\n    pointcloudColoring: {\n      type: 'string',\n      default: 'white'\n    },\n    pointcloudElevationRange: {\n      type: 'array',\n      default: ['0', '400']\n    },\n    wireframe: {\n      type: 'boolean',\n      default: false\n    },\n    showStats: {\n      type: 'boolean',\n      default: false\n    },\n    cesiumIONToken: {\n      type: 'string'\n    },\n    googleApiKey: {\n      type: 'string'\n    },\n    lat: {\n      type: 'number'\n    },\n    long: {\n      type: 'number'\n    },\n    height: {\n      type: 'number',\n      default: 0\n    },\n    copyrightEl: {\n      type: 'selector'\n    }\n  },\n  init: async function () {\n    const sceneEl = this.el.sceneEl;\n    const data = this.data;\n    this.camera = data.cameraEl?.object3D.children[0] ?? document.querySelector('a-scene').camera;\n\n    if (!this.camera) {\n      throw new Error('3D Tiles: Please add an active camera or specify the target camera via the cameraEl property');\n    }\n\n    this.viewport = {\n      width: sceneEl.clientWidth,\n      height: sceneEl.clientHeight,\n      devicePixelRatio: window.devicePixelRatio\n    };\n    const {\n      model,\n      runtime\n    } = await this._initTileset();\n    this.el.setObject3D('tileset', model);\n    this.runtime = runtime;\n    this.originalCamera = this.camera;\n    sceneEl.addEventListener('camera-set-active', e => {\n      // TODO: For some reason after closing the inspector this event is fired with an empty camera,\n      // so revert to the original camera used.\n      //\n      // TODO: Does not provide the right Inspector perspective camera\n      this.camera = e.detail.cameraEl.object3D.children[0] ?? this.originalCamera;\n    });\n    this.el.addEventListener('cameraChange', e => {\n      this.camera = e.detail;\n\n      if (this.camera.type === 'OrthographicCamera') {\n        if (this.camera.rotation.x < -1) {\n          // Plan View mode\n          // raise the camera to increase the field of view and update a larger area of tiles\n          this.camera.position.y = 100;\n        } else {\n          // Cross Section mode\n          this.camera.position.y = 10; // default value for ortho camera in Editor\n        }\n      }\n\n      this.runtime.setViewport(this.viewport);\n    });\n    sceneEl.addEventListener('enter-vr', e => {\n      this.originalCamera = this.camera;\n\n      try {\n        this.camera = sceneEl.renderer.xr.getCamera(this.camera); // FOV Code from https://github.com/mrdoob/three.js/issues/21869\n\n        sceneEl.renderer.xr.getSession().requestAnimationFrame((time, frame) => {\n          const ref = sceneEl.renderer.xr.getReferenceSpace();\n          const pose = frame.getViewerPose(ref);\n\n          if (pose) {\n            const fovi = pose.views[0].projectionMatrix[5];\n            this.camera.fov = Math.atan2(1, fovi) * 2 * 180 / Math.PI;\n          }\n        });\n      } catch (e) {\n        console.warn('Could not get VR camera');\n      }\n    });\n    sceneEl.addEventListener('exit-vr', e => {\n      this.camera = this.originalCamera;\n    });\n\n    if (data.showStats) {\n      this.stats = this._initStats();\n    }\n\n    if (THREE.Cache.enabled) {\n      console.warn('3D Tiles loader cannot work with THREE.Cache, disabling.');\n      THREE.Cache.enabled = false;\n    }\n\n    await this._nextFrame();\n    this.runtime = runtime;\n    this.runtime.setElevationRange(data.pointcloudElevationRange.map(n => Number(n)));\n    window.addEventListener('resize', this.onWindowResize.bind(this));\n\n    if (AFRAME.INSPECTOR && AFRAME.INSPECTOR.opened) {\n      // set active inspector camera\n      this.camera = AFRAME.INSPECTOR.camera; // emit play event to start load tiles in aframe-inspector\n\n      this.play();\n    }\n  },\n  onWindowResize: function () {\n    const sceneEl = this.el.sceneEl;\n    this.camera.aspect = sceneEl.clientWidth / sceneEl.clientHeight;\n    this.camera.updateProjectionMatrix();\n    this.viewport = {\n      width: sceneEl.clientWidth,\n      height: sceneEl.clientHeight,\n      devicePixelRatio: window.devicePixelRatio\n    };\n    this.runtime.setViewport(this.viewport);\n  },\n  update: async function (oldData) {\n    if (oldData.url !== this.data.url) {\n      if (this.runtime) {\n        this.runtime.dispose();\n        this.runtime = null;\n      }\n\n      const {\n        model,\n        runtime\n      } = await this._initTileset();\n      this.el.setObject3D('tileset', model);\n      await this._nextFrame();\n      this.runtime = runtime;\n    } else if (this.runtime) {\n      this.runtime.setPointCloudColoring(this._resolvePointcloudColoring(this.data.pointCloudColoring));\n      this.runtime.setWireframe(this.data.wireframe);\n      this.runtime.setViewDistanceScale(this.data.distanceScale);\n      this.runtime.setElevationRange(this.data.pointcloudElevationRange.map(n => Number(n)));\n    }\n\n    if (this.data.showStats && !this.stats) {\n      this.stats = this._initStats();\n    }\n\n    if (!this.data.showStats && this.stats) {\n      this.el.sceneEl.removeChild(this.stats);\n      this.stats = null;\n    } // set parameters for google 3dtiles API\n\n\n    if (this.data.lat && this.data.long || this.data.height) {\n      this.runtime.orientToGeocoord({\n        lat: Number(this.data.lat),\n        long: Number(this.data.long),\n        height: Number(this.data.height)\n      });\n    }\n  },\n  tick: function (t, dt) {\n    if (this.runtime) {\n      this.runtime.update(dt, this.camera);\n\n      if (this.stats) {\n        const worldPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        this.camera.getWorldPosition(worldPos);\n        const stats = this.runtime.getStats();\n        this.stats.setAttribute('textarea', 'text', Object.values(stats.stats).map(s => `${s.name}: ${s.count}`).join('\\n'));\n        const newPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        newPos.copy(worldPos);\n        newPos.z -= 2;\n        this.stats.setAttribute('position', newPos);\n      }\n\n      if (this.data.copyrightEl) {\n        this.data.copyrightEl.innerHTML = this.runtime.getDataAttributions() ?? '';\n      }\n    }\n  },\n  remove: function () {\n    if (this.runtime) {\n      this.runtime.dispose();\n    }\n  },\n\n  _resolvePointcloudColoring() {\n    const pointCloudColoring = POINT_CLOUD_COLORING[this.data.pointcloudColoring];\n\n    if (!pointCloudColoring) {\n      console.warn('Invalid value for point cloud coloring');\n      return three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.PointCloudColoring.White;\n    } else {\n      return pointCloudColoring;\n    }\n  },\n\n  _initTileset: async function () {\n    const pointCloudColoring = this._resolvePointcloudColoring(this.data.pointcloudColoring);\n\n    return three_loader_3dtiles__WEBPACK_IMPORTED_MODULE_0__.Loader3DTiles.load({\n      url: this.data.url,\n      renderer: this.el.sceneEl.renderer,\n      options: {\n        googleApiKey: this.data.googleApiKey,\n        cesiumIONToken: this.data.cesiumIONToken,\n        dracoDecoderPath: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco',\n        basisTranscoderPath: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/basis',\n        maximumScreenSpaceError: this.data.maximumSSE,\n        maximumMemoryUsage: this.data.maximumMem,\n        memoryCacheOverflow: 128,\n        pointCloudColoring: pointCloudColoring,\n        viewDistanceScale: this.data.distanceScale,\n        wireframe: this.data.wireframe,\n        updateTransforms: true\n      },\n      viewport: this.viewport\n    });\n  },\n  _initStats: function () {\n    const stats = document.createElement('a-entity');\n    this.el.sceneEl.appendChild(stats);\n    stats.setAttribute('position', '-0.5 0 -1');\n    stats.setAttribute('textarea', {\n      cols: 30,\n      rows: 15,\n      text: '',\n      color: 'white',\n      disabledBackgroundColor: '#0c1e2c',\n      disabled: true\n    });\n    return stats;\n  },\n  _nextFrame: async function () {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve();\n      }, 0);\n    });\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./index.js?");

/***/ }),

/***/ "./textarea.js":
/*!*********************!*\
  !*** ./textarea.js ***!
  \*********************/
/***/ (() => {

eval("if (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n/**\n * Textarea component for A-Frame.\n *\n * Ripped from: https://github.com/brianpeiris/aframe-textarea-component\n */\n\n\nAFRAME.registerComponent('textarea', {\n  schema: {\n    transparentBG: {\n      type: 'boolean',\n      default: false\n    },\n    cols: {\n      type: 'int',\n      default: 40\n    },\n    rows: {\n      type: 'int',\n      default: 20\n    },\n    color: {\n      type: 'color',\n      default: 'black'\n    },\n    backgroundColor: {\n      type: 'color',\n      default: 'white'\n    },\n    disabledBackgroundColor: {\n      type: 'color',\n      default: 'lightgrey'\n    },\n    disabled: {\n      type: 'boolean',\n      default: false\n    },\n    text: {\n      type: 'string',\n      default: ''\n    }\n  },\n  init: function () {\n    this.text = null;\n    this.lines = [];\n    this.lastBlink = 0;\n    this.blinkEnabled = !this.data.disabled;\n    this.charWidth = this.charHeight = null;\n    this.selectionStart = this.selectionEnd = 0;\n    this.endIndexInfo = this.startIndexInfo = null;\n    this.origin = {\n      x: 0,\n      y: 0\n    };\n    this.background = document.createElement('a-plane');\n    this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    this.el.appendChild(this.background);\n\n    if (this.data.transparentBG) {\n      this.background.setAttribute('material', {\n        opacity: 0,\n        transparent: true\n      });\n    }\n\n    this.textAnchor = document.createElement('a-entity');\n    this.el.appendChild(this.textAnchor);\n    this.textAnchor.setAttribute('text', {\n      mode: 'pre',\n      baseline: 'top',\n      anchor: 'center',\n      font: 'dejavu',\n      wrapCount: this.data.cols,\n      height: this.data.rows,\n      color: this.data.color\n    });\n\n    this._initTextarea();\n\n    this.el.addEventListener('textfontset', this._updateCharMetrics.bind(this));\n    this.el.addEventListener('char-metrics-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('text-changed', this._updateLines.bind(this));\n    this.el.addEventListener('text-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('selection-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('selection-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('lines-changed', this._updateIndexInfo.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateOrigin.bind(this));\n    this.el.addEventListener('index-info-changed', this._updateHorizontalOrigin.bind(this));\n    this.el.addEventListener('origin-changed', this._updateDisplayText.bind(this));\n    this.el.addEventListener('click', this.focus.bind(this));\n  },\n  update: function (oldData) {\n    if (this.data.text !== oldData.text) {\n      this._updateTextarea();\n    }\n\n    if (this.data.backgroundColor !== oldData.backgroundColor || this.data.disabledBackgroundColor !== oldData.disabledBackgroundColor) {\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n\n    if (this.data.disabled !== oldData.disabled) {\n      this.blinkEnabled = !this.data.disabled;\n      this.textarea.disabled = this.data.disabled;\n      this.background.setAttribute('color', this.data.disabled ? this.data.disabledBackgroundColor : this.data.backgroundColor);\n    }\n  },\n  focus: function () {\n    this.textarea.focus();\n  },\n  _initTextarea: function () {\n    this.textarea = document.createElement('textarea');\n    document.body.appendChild(this.textarea);\n\n    this._updateTextarea();\n  },\n  _updateTextarea: function () {\n    this.textarea.style.whiteSpace = 'pre';\n    this.textarea.style.overflow = 'hidden';\n    this.textarea.style.opacity = '0';\n    this.textarea.cols = this.data.cols;\n    this.textarea.rows = this.data.rows;\n    this.textarea.value = this.data.text;\n    this.textarea.selectionStart = 0;\n    this.textarea.selectionEnd = 0;\n\n    this._updateIndexInfo();\n  },\n  _emit: function (eventName, detail) {\n    this.el.emit(eventName, detail);\n  },\n  _updateCharMetrics: function (event) {\n    const layout = this.textAnchor.components.text.geometry.layout;\n    const fontWidthFactor = event.detail.fontObj.widthFactor;\n    this.charWidth = fontWidthFactor * this.textAnchor.object3DMap.text.scale.x;\n    this.charHeight = this.charWidth * layout.lineHeight / fontWidthFactor;\n    this.textAnchor.setAttribute('position', {\n      x: 0,\n      y: this.charHeight * this.data.rows / 2,\n      z: 0\n    });\n\n    if (!this.data.transparentBG) {\n      this.background.setAttribute('scale', {\n        x: 1.05,\n        y: this.charHeight * this.data.rows * 1.05,\n        z: 1\n      });\n      this.background.setAttribute('position', {\n        x: 0,\n        y: 0,\n        z: 0\n      });\n    }\n\n    this._emit('char-metrics-changed');\n  },\n  _checkAndUpdateSelection: function () {\n    if (this.selectionStart === this.textarea.selectionStart && this.selectionEnd === this.textarea.selectionEnd) {\n      return;\n    }\n\n    const lastStart = this.selectionStart;\n    const lastEnd = this.selectionEnd;\n    this.selectionStart = this.textarea.selectionStart;\n    this.selectionEnd = this.textarea.selectionEnd;\n\n    this._emit('selection-changed', {\n      start: {\n        old: lastStart,\n        new: this.selectionStart,\n        changed: this.selectionStart !== lastStart\n      },\n      end: {\n        old: lastEnd,\n        new: this.selectionEnd,\n        changed: this.selectionEnd !== lastEnd\n      }\n    });\n  },\n  tick: function (time) {\n    if (time - this.lastBlink > 500 && this.blinkEnabled) {\n      this.lastBlink = time;\n    }\n\n    this._checkAndUpdateSelection();\n\n    this._checkAndUpdateText();\n  },\n  _getIndexInfo: function (lineIndex, textIndex) {\n    const y = Math.max(0, lineIndex);\n    const line = this.lines[y];\n    const x = textIndex - line.start;\n    return {\n      line: line,\n      x: x * this.charWidth,\n      y: -this.charHeight * y + -this.charHeight / 2\n    };\n  },\n  _updateIndexInfo: function () {\n    if (!this.lines.length) {\n      return;\n    }\n\n    const lastStart = this.startIndexInfo && this.startIndexInfo.line.index;\n    const lastEnd = this.endIndexInfo && this.endIndexInfo.line.index;\n    this.startIndexInfo = null;\n    this.endIndexInfo = null;\n    let i;\n    let startChanged = false;\n    let endChanged = false;\n\n    for (i = 0; i <= this.lines.length; i++) {\n      const prevLine = this.lines[i - 1];\n      const lineStart = i === this.lines.length ? prevLine.start + prevLine.length + 1 : this.lines[i].start;\n\n      if (lineStart > this.selectionStart && !this.startIndexInfo) {\n        this.startIndexInfo = this._getIndexInfo(i - 1, this.selectionStart);\n\n        if (this.startIndexInfo.line.index !== lastStart) {\n          startChanged = true;\n        }\n      }\n\n      if (lineStart > this.selectionEnd) {\n        this.endIndexInfo = this._getIndexInfo(i - 1, this.selectionEnd);\n\n        if (this.endIndexInfo.line.index !== lastEnd) {\n          endChanged = true;\n        }\n\n        break;\n      }\n    }\n\n    if (startChanged || endChanged) {\n      this._emit('index-info-changed', {\n        start: {\n          changed: startChanged\n        },\n        end: {\n          changed: endChanged\n        }\n      });\n    }\n  },\n  _updateOrigin: function (event) {\n    let changed = false;\n\n    if (event.detail.end.changed) {\n      const end = this.origin.y + this.data.rows - 1;\n\n      if (this.endIndexInfo.line.index > end) {\n        this.origin.y = this.endIndexInfo.line.index + 1 - this.data.rows;\n        changed = true;\n      } else if (this.endIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.endIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (event.detail.start.changed) {\n      if (this.startIndexInfo.line.index < this.origin.y) {\n        this.origin.y = this.startIndexInfo.line.index;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateHorizontalOrigin: function (event) {\n    if (!this.endIndexInfo) {\n      return;\n    }\n\n    let changed = true;\n\n    if (event.detail.end.changed) {\n      const endIndex = this.selectionEnd - this.endIndexInfo.line.start;\n\n      if (endIndex > this.origin.x + this.data.cols) {\n        this.origin.x = endIndex - this.data.cols;\n        changed = true;\n      } else if (endIndex < this.origin.x) {\n        this.origin.x = endIndex;\n        changed = true;\n      }\n    }\n\n    const startIndex = this.selectionStart - this.startIndexInfo.line.start;\n\n    if (event.detail.start.changed) {\n      if (startIndex > this.origin.x + this.data.cols) {\n        this.origin.x = startIndex - this.data.cols;\n        changed = true;\n      } else if (startIndex < this.origin.x) {\n        this.origin.x = startIndex;\n        changed = true;\n      }\n    }\n\n    if (changed) {\n      this._emit('origin-changed');\n    }\n  },\n  _updateLines: function () {\n    this.lines = [];\n    const lines = this.text.split('\\n');\n    let counter = 0;\n\n    for (let i = 0; i < lines.length; i++) {\n      this.lines[i] = {\n        index: i,\n        length: lines[i].length,\n        start: counter\n      };\n      counter += lines[i].length + 1;\n    }\n\n    this._emit('lines-changed');\n  },\n  _getViewportText: function () {\n    return this.text.split('\\n').slice(this.origin.y, this.origin.y + this.data.rows).map(function (line) {\n      return line.substr(this.origin.x, this.data.cols) || ' ';\n    }.bind(this)).join('\\n');\n  },\n  _updateDisplayText: function () {\n    this.textAnchor.setAttribute('text', {\n      value: this._getViewportText()\n    });\n  },\n  _checkAndUpdateText: function () {\n    const text = this.textarea.value;\n\n    if (text === this.text) {\n      return;\n    }\n\n    this.text = text;\n\n    this._emit('text-changed');\n  }\n});\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./textarea.js?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_three__;

/***/ }),

/***/ "./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js":
/*!****************************************************************************!*\
  !*** ./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Loader3DTiles\": () => (/* binding */ qB),\n/* harmony export */   \"PointCloudColoring\": () => (/* binding */ Nc),\n/* harmony export */   \"Shading\": () => (/* binding */ jn)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three/examples/jsm/loaders/KTX2Loader.js */ \"three\");\nvar Hc = Object.defineProperty;\nvar Jc = (e, t, n) => t in e ? Hc(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;\nvar p = (e, t, n) => (Jc(e, typeof t != \"symbol\" ? t + \"\" : t, n), n);\n\n\n\n\nasync function Ke(e, t, n, s) {\n  return s._parse(e, t, n, s);\n}\nfunction K(e, t) {\n  if (!e)\n    throw new Error(t || \"loader assertion failed.\");\n}\nconst kn = !!(typeof process != \"object\" || String(process) !== \"[object process]\" || process.browser), zr = typeof process < \"u\" && process.version && /v([0-9]*)/.exec(process.version);\nzr && parseFloat(zr[1]);\nfunction au(e, t) {\n  return zo(e || {}, t);\n}\nfunction zo(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  if (n > 3)\n    return t;\n  const s = {\n    ...e\n  };\n  for (const [r, i] of Object.entries(t))\n    i && typeof i == \"object\" && !Array.isArray(i) ? s[r] = zo(s[r] || {}, t[r], n + 1) : s[r] = t[r];\n  return s;\n}\nconst cu = \"latest\";\nfunction uu() {\n  var e;\n  return (e = globalThis._loadersgl_) !== null && e !== void 0 && e.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = \"4.1.1\"), globalThis._loadersgl_.version;\n}\nconst Wo = uu();\nfunction Jt(e, t) {\n  if (!e)\n    throw new Error(t || \"loaders.gl assertion failed.\");\n}\nconst bt = typeof process != \"object\" || String(process) !== \"[object process]\" || process.browser, fr = typeof importScripts == \"function\", lu = typeof window < \"u\" && typeof window.orientation < \"u\", Wr = typeof process < \"u\" && process.version && /v([0-9]*)/.exec(process.version);\nWr && parseFloat(Wr[1]);\nclass hu {\n  constructor(t, n) {\n    this.name = void 0, this.workerThread = void 0, this.isRunning = !0, this.result = void 0, this._resolve = () => {\n    }, this._reject = () => {\n    }, this.name = t, this.workerThread = n, this.result = new Promise((s, r) => {\n      this._resolve = s, this._reject = r;\n    });\n  }\n  postMessage(t, n) {\n    this.workerThread.postMessage({\n      source: \"loaders.gl\",\n      type: t,\n      payload: n\n    });\n  }\n  done(t) {\n    Jt(this.isRunning), this.isRunning = !1, this._resolve(t);\n  }\n  error(t) {\n    Jt(this.isRunning), this.isRunning = !1, this._reject(t);\n  }\n}\nclass is {\n  terminate() {\n  }\n}\nconst os = /* @__PURE__ */ new Map();\nfunction fu(e) {\n  Jt(e.source && !e.url || !e.source && e.url);\n  let t = os.get(e.source || e.url);\n  return t || (e.url && (t = du(e.url), os.set(e.url, t)), e.source && (t = Xo(e.source), os.set(e.source, t))), Jt(t), t;\n}\nfunction du(e) {\n  if (!e.startsWith(\"http\"))\n    return e;\n  const t = mu(e);\n  return Xo(t);\n}\nfunction Xo(e) {\n  const t = new Blob([e], {\n    type: \"application/javascript\"\n  });\n  return URL.createObjectURL(t);\n}\nfunction mu(e) {\n  return `try {\n  importScripts('${e}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;\n}\nfunction Qo(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = n || /* @__PURE__ */ new Set();\n  if (e) {\n    if (Xr(e))\n      s.add(e);\n    else if (Xr(e.buffer))\n      s.add(e.buffer);\n    else if (!ArrayBuffer.isView(e)) {\n      if (t && typeof e == \"object\")\n        for (const r in e)\n          Qo(e[r], t, s);\n    }\n  }\n  return n === void 0 ? Array.from(s) : [];\n}\nfunction Xr(e) {\n  return e ? e instanceof ArrayBuffer || typeof MessagePort < \"u\" && e instanceof MessagePort || typeof ImageBitmap < \"u\" && e instanceof ImageBitmap || typeof OffscreenCanvas < \"u\" && e instanceof OffscreenCanvas : !1;\n}\nconst as = () => {\n};\nclass Vs {\n  static isSupported() {\n    return typeof Worker < \"u\" && bt || typeof is < \"u\" && !bt;\n  }\n  constructor(t) {\n    this.name = void 0, this.source = void 0, this.url = void 0, this.terminated = !1, this.worker = void 0, this.onMessage = void 0, this.onError = void 0, this._loadableURL = \"\";\n    const {\n      name: n,\n      source: s,\n      url: r\n    } = t;\n    Jt(s || r), this.name = n, this.source = s, this.url = r, this.onMessage = as, this.onError = (i) => console.log(i), this.worker = bt ? this._createBrowserWorker() : this._createNodeWorker();\n  }\n  destroy() {\n    this.onMessage = as, this.onError = as, this.worker.terminate(), this.terminated = !0;\n  }\n  get isRunning() {\n    return !!this.onMessage;\n  }\n  postMessage(t, n) {\n    n = n || Qo(t), this.worker.postMessage(t, n);\n  }\n  _getErrorFromErrorEvent(t) {\n    let n = \"Failed to load \";\n    return n += `worker ${this.name} from ${this.url}. `, t.message && (n += `${t.message} in `), t.lineno && (n += `:${t.lineno}:${t.colno}`), new Error(n);\n  }\n  _createBrowserWorker() {\n    this._loadableURL = fu({\n      source: this.source,\n      url: this.url\n    });\n    const t = new Worker(this._loadableURL, {\n      name: this.name\n    });\n    return t.onmessage = (n) => {\n      n.data ? this.onMessage(n.data) : this.onError(new Error(\"No data received\"));\n    }, t.onerror = (n) => {\n      this.onError(this._getErrorFromErrorEvent(n)), this.terminated = !0;\n    }, t.onmessageerror = (n) => console.error(n), t;\n  }\n  _createNodeWorker() {\n    let t;\n    if (this.url) {\n      const s = this.url.includes(\":/\") || this.url.startsWith(\"/\") ? this.url : `./${this.url}`;\n      t = new is(s, {\n        eval: !1\n      });\n    } else if (this.source)\n      t = new is(this.source, {\n        eval: !0\n      });\n    else\n      throw new Error(\"no worker\");\n    return t.on(\"message\", (n) => {\n      this.onMessage(n);\n    }), t.on(\"error\", (n) => {\n      this.onError(n);\n    }), t.on(\"exit\", (n) => {\n    }), t;\n  }\n}\nclass gu {\n  static isSupported() {\n    return Vs.isSupported();\n  }\n  constructor(t) {\n    this.name = \"unnamed\", this.source = void 0, this.url = void 0, this.maxConcurrency = 1, this.maxMobileConcurrency = 1, this.onDebug = () => {\n    }, this.reuseWorkers = !0, this.props = {}, this.jobQueue = [], this.idleQueue = [], this.count = 0, this.isDestroyed = !1, this.source = t.source, this.url = t.url, this.setProps(t);\n  }\n  destroy() {\n    this.idleQueue.forEach((t) => t.destroy()), this.isDestroyed = !0;\n  }\n  setProps(t) {\n    this.props = {\n      ...this.props,\n      ...t\n    }, t.name !== void 0 && (this.name = t.name), t.maxConcurrency !== void 0 && (this.maxConcurrency = t.maxConcurrency), t.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = t.maxMobileConcurrency), t.reuseWorkers !== void 0 && (this.reuseWorkers = t.reuseWorkers), t.onDebug !== void 0 && (this.onDebug = t.onDebug);\n  }\n  async startJob(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (i, o, a) => i.done(a), s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (i, o) => i.error(o);\n    const r = new Promise((i) => (this.jobQueue.push({\n      name: t,\n      onMessage: n,\n      onError: s,\n      onStart: i\n    }), this));\n    return this._startQueuedJob(), await r;\n  }\n  async _startQueuedJob() {\n    if (!this.jobQueue.length)\n      return;\n    const t = this._getAvailableWorker();\n    if (!t)\n      return;\n    const n = this.jobQueue.shift();\n    if (n) {\n      this.onDebug({\n        message: \"Starting job\",\n        name: n.name,\n        workerThread: t,\n        backlog: this.jobQueue.length\n      });\n      const s = new hu(n.name, t);\n      t.onMessage = (r) => n.onMessage(s, r.type, r.payload), t.onError = (r) => n.onError(s, r), n.onStart(s);\n      try {\n        await s.result;\n      } catch (r) {\n        console.error(`Worker exception: ${r}`);\n      } finally {\n        this.returnWorkerToQueue(t);\n      }\n    }\n  }\n  returnWorkerToQueue(t) {\n    !bt || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (t.destroy(), this.count--) : this.idleQueue.push(t), this.isDestroyed || this._startQueuedJob();\n  }\n  _getAvailableWorker() {\n    if (this.idleQueue.length > 0)\n      return this.idleQueue.shift() || null;\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const t = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new Vs({\n        name: t,\n        source: this.source,\n        url: this.url\n      });\n    }\n    return null;\n  }\n  _getMaxConcurrency() {\n    return lu ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\nconst Au = {\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: !0,\n  onDebug: () => {\n  }\n};\nclass Nt {\n  static isSupported() {\n    return Vs.isSupported();\n  }\n  static getWorkerFarm() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return Nt._workerFarm = Nt._workerFarm || new Nt({}), Nt._workerFarm.setProps(t), Nt._workerFarm;\n  }\n  constructor(t) {\n    this.props = void 0, this.workerPools = /* @__PURE__ */ new Map(), this.props = {\n      ...Au\n    }, this.setProps(t), this.workerPools = /* @__PURE__ */ new Map();\n  }\n  destroy() {\n    for (const t of this.workerPools.values())\n      t.destroy();\n    this.workerPools = /* @__PURE__ */ new Map();\n  }\n  setProps(t) {\n    this.props = {\n      ...this.props,\n      ...t\n    };\n    for (const n of this.workerPools.values())\n      n.setProps(this._getWorkerPoolProps());\n  }\n  getWorkerPool(t) {\n    const {\n      name: n,\n      source: s,\n      url: r\n    } = t;\n    let i = this.workerPools.get(n);\n    return i || (i = new gu({\n      name: n,\n      source: s,\n      url: r\n    }), i.setProps(this._getWorkerPoolProps()), this.workerPools.set(n, i)), i;\n  }\n  _getWorkerPoolProps() {\n    return {\n      maxConcurrency: this.props.maxConcurrency,\n      maxMobileConcurrency: this.props.maxMobileConcurrency,\n      reuseWorkers: this.props.reuseWorkers,\n      onDebug: this.props.onDebug\n    };\n  }\n}\nNt._workerFarm = void 0;\nfunction pu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const n = t[e.id] || {}, s = bt ? `${e.id}-worker.js` : `${e.id}-worker-node.js`;\n  let r = n.workerUrl;\n  if (!r && e.id === \"compression\" && (r = t.workerUrl), t._workerType === \"test\" && (bt ? r = `modules/${e.module}/dist/${s}` : r = `modules/${e.module}/src/workers/${e.id}-worker-node.ts`), !r) {\n    let i = e.version;\n    i === \"latest\" && (i = cu);\n    const o = i ? `@${i}` : \"\";\n    r = `https://unpkg.com/@loaders.gl/${e.module}${o}/dist/${s}`;\n  }\n  return Jt(r), r;\n}\nfunction yu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wo;\n  Jt(e, \"no worker provided\");\n  const n = e.version;\n  return !(!t || !n);\n}\nconst Bu = {}, Cu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: Bu\n}, Symbol.toStringTag, { value: \"Module\" })), cs = {};\nasync function Zt(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n  return t && (e = Eu(e, t, n, s)), cs[e] = cs[e] || Tu(e), await cs[e];\n}\nfunction Eu(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n  if (!n.useLocalLibraries && e.startsWith(\"http\"))\n    return e;\n  s = s || e;\n  const r = n.modules || {};\n  return r[s] ? r[s] : bt ? n.CDN ? (Jt(n.CDN.startsWith(\"http\")), `${n.CDN}/${t}@${Wo}/dist/libs/${s}`) : fr ? `../src/libs/${s}` : `modules/${t}/src/libs/${s}` : `modules/${t}/dist/libs/${s}`;\n}\nasync function Tu(e) {\n  if (e.endsWith(\"wasm\"))\n    return await _u(e);\n  if (!bt)\n    try {\n      return Cu && void 0;\n    } catch (n) {\n      return console.error(n), null;\n    }\n  if (fr)\n    return importScripts(e);\n  const t = await wu(e);\n  return bu(t, e);\n}\nfunction bu(e, t) {\n  if (!bt)\n    return;\n  if (fr)\n    return eval.call(globalThis, e), null;\n  const n = document.createElement(\"script\");\n  n.id = t;\n  try {\n    n.appendChild(document.createTextNode(e));\n  } catch {\n    n.text = e;\n  }\n  return document.body.appendChild(n), null;\n}\nasync function _u(e) {\n  return await (await fetch(e)).arrayBuffer();\n}\nasync function wu(e) {\n  return await (await fetch(e)).text();\n}\nfunction Ru(e, t) {\n  return !Nt.isSupported() || !bt && !(t != null && t._nodeWorkers) ? !1 : e.worker && (t == null ? void 0 : t.worker);\n}\nasync function Mu(e, t, n, s, r) {\n  const i = e.id, o = pu(e, n), c = Nt.getWorkerFarm(n).getWorkerPool({\n    name: i,\n    url: o\n  });\n  n = JSON.parse(JSON.stringify(n)), s = JSON.parse(JSON.stringify(s || {}));\n  const u = await c.startJob(\"process-on-worker\", Su.bind(null, r));\n  return u.postMessage(\"process\", {\n    input: t,\n    options: n,\n    context: s\n  }), await (await u.result).result;\n}\nasync function Su(e, t, n, s) {\n  switch (n) {\n    case \"done\":\n      t.done(s);\n      break;\n    case \"error\":\n      t.error(new Error(s.error));\n      break;\n    case \"process\":\n      const {\n        id: r,\n        input: i,\n        options: o\n      } = s;\n      try {\n        const a = await e(i, o);\n        t.postMessage(\"done\", {\n          id: r,\n          result: a\n        });\n      } catch (a) {\n        const c = a instanceof Error ? a.message : \"unknown error\";\n        t.postMessage(\"error\", {\n          id: r,\n          error: c\n        });\n      }\n      break;\n    default:\n      console.warn(`parse-with-worker unknown message ${n}`);\n  }\n}\nfunction Iu(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n  return typeof e == \"string\" ? e.slice(0, t) : ArrayBuffer.isView(e) ? Qr(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? Qr(e, 0, t) : \"\";\n}\nfunction Qr(e, t, n) {\n  if (e.byteLength <= t + n)\n    return \"\";\n  const s = new DataView(e);\n  let r = \"\";\n  for (let i = 0; i < n; i++)\n    r += String.fromCharCode(s.getUint8(t + i));\n  return r;\n}\nfunction xu(e) {\n  try {\n    return JSON.parse(e);\n  } catch {\n    throw new Error(`Failed to parse JSON from data starting with \"${Iu(e)}\"`);\n  }\n}\nfunction vu(e, t, n) {\n  if (n = n || e.byteLength, e.byteLength < n || t.byteLength < n)\n    return !1;\n  const s = new Uint8Array(e), r = new Uint8Array(t);\n  for (let i = 0; i < s.length; ++i)\n    if (s[i] !== r[i])\n      return !1;\n  return !0;\n}\nfunction Ou() {\n  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)\n    t[n] = arguments[n];\n  return Fu(t);\n}\nfunction Fu(e) {\n  const t = e.map((i) => i instanceof ArrayBuffer ? new Uint8Array(i) : i), n = t.reduce((i, o) => i + o.byteLength, 0), s = new Uint8Array(n);\n  let r = 0;\n  for (const i of t)\n    s.set(i, r), r += i.byteLength;\n  return s.buffer;\n}\nfunction dr(e, t, n) {\n  const s = n !== void 0 ? new Uint8Array(e).subarray(t, t + n) : new Uint8Array(e).subarray(t);\n  return new Uint8Array(s).buffer;\n}\nfunction ze(e, t) {\n  return K(e >= 0), K(t > 0), e + (t - 1) & ~(t - 1);\n}\nfunction Du(e, t, n) {\n  let s;\n  if (e instanceof ArrayBuffer)\n    s = new Uint8Array(e);\n  else {\n    const r = e.byteOffset, i = e.byteLength;\n    s = new Uint8Array(e.buffer || e.arrayBuffer, r, i);\n  }\n  return t.set(s, n), n + ze(s.byteLength, 4);\n}\nasync function Lu(e) {\n  const t = [];\n  for await (const n of e)\n    t.push(n);\n  return Ou(...t);\n}\nfunction qr() {\n  let e;\n  if (typeof window < \"u\" && window.performance)\n    e = window.performance.now();\n  else if (typeof process < \"u\" && process.hrtime) {\n    const t = process.hrtime();\n    e = t[0] * 1e3 + t[1] / 1e6;\n  } else\n    e = Date.now();\n  return e;\n}\nclass Yr {\n  constructor(t, n) {\n    this.name = void 0, this.type = void 0, this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = t, this.type = n, this.reset();\n  }\n  reset() {\n    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;\n  }\n  setSampleSize(t) {\n    return this.sampleSize = t, this;\n  }\n  incrementCount() {\n    return this.addCount(1), this;\n  }\n  decrementCount() {\n    return this.subtractCount(1), this;\n  }\n  addCount(t) {\n    return this._count += t, this._samples++, this._checkSampling(), this;\n  }\n  subtractCount(t) {\n    return this._count -= t, this._samples++, this._checkSampling(), this;\n  }\n  addTime(t) {\n    return this._time += t, this.lastTiming = t, this._samples++, this._checkSampling(), this;\n  }\n  timeStart() {\n    return this._startTime = qr(), this._timerPending = !0, this;\n  }\n  timeEnd() {\n    return this._timerPending ? (this.addTime(qr() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;\n  }\n  getSampleAverageCount() {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n  getSampleAverageTime() {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n  getSampleHz() {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;\n  }\n  getAverageCount() {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n  getAverageTime() {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n  getHz() {\n    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;\n  }\n  _checkSampling() {\n    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);\n  }\n}\nclass qo {\n  constructor(t) {\n    this.id = void 0, this.stats = {}, this.id = t.id, this.stats = {}, this._initializeStats(t.stats), Object.seal(this);\n  }\n  get(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"count\";\n    return this._getOrCreate({\n      name: t,\n      type: n\n    });\n  }\n  get size() {\n    return Object.keys(this.stats).length;\n  }\n  reset() {\n    for (const t of Object.values(this.stats))\n      t.reset();\n    return this;\n  }\n  forEach(t) {\n    for (const n of Object.values(this.stats))\n      t(n);\n  }\n  getTable() {\n    const t = {};\n    return this.forEach((n) => {\n      t[n.name] = {\n        time: n.time || 0,\n        count: n.count || 0,\n        average: n.getAverageTime() || 0,\n        hz: n.getHz() || 0\n      };\n    }), t;\n  }\n  _initializeStats() {\n    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((n) => this._getOrCreate(n));\n  }\n  _getOrCreate(t) {\n    const {\n      name: n,\n      type: s\n    } = t;\n    let r = this.stats[n];\n    return r || (t instanceof Yr ? r = t : r = new Yr(n, s), this.stats[n] = r), r;\n  }\n}\nlet Pu = \"\";\nconst $r = {};\nfunction Gu(e) {\n  for (const t in $r)\n    if (e.startsWith(t)) {\n      const n = $r[t];\n      e = e.replace(t, n);\n    }\n  return !e.startsWith(\"http://\") && !e.startsWith(\"https://\") && (e = `${Pu}${e}`), e;\n}\nfunction Nu(e) {\n  return e && typeof e == \"object\" && e.isBuffer;\n}\nfunction Yo(e) {\n  if (Nu(e))\n    return e;\n  if (e instanceof ArrayBuffer)\n    return e;\n  if (ArrayBuffer.isView(e))\n    return e.byteOffset === 0 && e.byteLength === e.buffer.byteLength ? e.buffer : e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);\n  if (typeof e == \"string\") {\n    const t = e;\n    return new TextEncoder().encode(t).buffer;\n  }\n  if (e && typeof e == \"object\" && e._toArrayBuffer)\n    return e._toArrayBuffer();\n  throw new Error(\"toArrayBuffer\");\n}\nfunction Uu() {\n  var e;\n  if (typeof process < \"u\" && typeof process.cwd < \"u\")\n    return process.cwd();\n  const t = (e = window.location) === null || e === void 0 ? void 0 : e.pathname;\n  return (t == null ? void 0 : t.slice(0, t.lastIndexOf(\"/\") + 1)) || \"\";\n}\nfunction $o(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(t + 1) : \"\";\n}\nfunction Zo(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(0, t) : \"\";\n}\nfunction Hu() {\n  const e = [];\n  for (let r = 0; r < arguments.length; r++)\n    e[r] = r < 0 || arguments.length <= r ? void 0 : arguments[r];\n  let t = \"\", n = !1, s;\n  for (let r = e.length - 1; r >= -1 && !n; r--) {\n    let i;\n    r >= 0 ? i = e[r] : (s === void 0 && (s = Uu()), i = s), i.length !== 0 && (t = `${i}/${t}`, n = i.charCodeAt(0) === Ie);\n  }\n  return t = Ju(t, !n), n ? `/${t}` : t.length > 0 ? t : \".\";\n}\nconst Ie = 47, us = 46;\nfunction Ju(e, t) {\n  let n = \"\", s = -1, r = 0, i, o = !1;\n  for (let a = 0; a <= e.length; ++a) {\n    if (a < e.length)\n      i = e.charCodeAt(a);\n    else {\n      if (i === Ie)\n        break;\n      i = Ie;\n    }\n    if (i === Ie) {\n      if (!(s === a - 1 || r === 1))\n        if (s !== a - 1 && r === 2) {\n          if (n.length < 2 || !o || n.charCodeAt(n.length - 1) !== us || n.charCodeAt(n.length - 2) !== us) {\n            if (n.length > 2) {\n              const c = n.length - 1;\n              let u = c;\n              for (; u >= 0 && n.charCodeAt(u) !== Ie; --u)\n                ;\n              if (u !== c) {\n                n = u === -1 ? \"\" : n.slice(0, u), s = a, r = 0, o = !1;\n                continue;\n              }\n            } else if (n.length === 2 || n.length === 1) {\n              n = \"\", s = a, r = 0, o = !1;\n              continue;\n            }\n          }\n          t && (n.length > 0 ? n += \"/..\" : n = \"..\", o = !0);\n        } else {\n          const c = e.slice(s + 1, a);\n          n.length > 0 ? n += `/${c}` : n = c, o = !1;\n        }\n      s = a, r = 0;\n    } else\n      i === us && r !== -1 ? ++r : r = -1;\n  }\n  return n;\n}\nconst Vu = (e) => typeof e == \"boolean\", ve = (e) => typeof e == \"function\", We = (e) => e !== null && typeof e == \"object\", Zr = (e) => We(e) && e.constructor === {}.constructor, ju = (e) => !!e && typeof e[Symbol.iterator] == \"function\", ku = (e) => e && typeof e[Symbol.asyncIterator] == \"function\", se = (e) => typeof Response < \"u\" && e instanceof Response || e && e.arrayBuffer && e.text && e.json, re = (e) => typeof Blob < \"u\" && e instanceof Blob, Ku = (e) => e && typeof e == \"object\" && e.isBuffer, zu = (e) => typeof ReadableStream < \"u\" && e instanceof ReadableStream || We(e) && ve(e.tee) && ve(e.cancel) && ve(e.getReader), Wu = (e) => We(e) && ve(e.read) && ve(e.pipe) && Vu(e.readable), ta = (e) => zu(e) || Wu(e), Xu = /^data:([-\\w.]+\\/[-\\w.+]+)(;|,)/, Qu = /^([-\\w.]+\\/[-\\w.+]+)/;\nfunction qu(e) {\n  const t = Qu.exec(e);\n  return t ? t[1] : e;\n}\nfunction ti(e) {\n  const t = Xu.exec(e);\n  return t ? t[1] : \"\";\n}\nconst ea = /\\?.*/;\nfunction Yu(e) {\n  const t = e.match(ea);\n  return t && t[0];\n}\nfunction mr(e) {\n  return e.replace(ea, \"\");\n}\nfunction Kn(e) {\n  return se(e) ? e.url : re(e) ? e.name || \"\" : typeof e == \"string\" ? e : \"\";\n}\nfunction gr(e) {\n  if (se(e)) {\n    const t = e, n = t.headers.get(\"content-type\") || \"\", s = mr(t.url);\n    return qu(n) || ti(s);\n  }\n  return re(e) ? e.type || \"\" : typeof e == \"string\" ? ti(e) : \"\";\n}\nfunction $u(e) {\n  return se(e) ? e.headers[\"content-length\"] || -1 : re(e) ? e.size : typeof e == \"string\" ? e.length : e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? e.byteLength : -1;\n}\nasync function na(e) {\n  if (se(e))\n    return e;\n  const t = {}, n = $u(e);\n  n >= 0 && (t[\"content-length\"] = String(n));\n  const s = Kn(e), r = gr(e);\n  r && (t[\"content-type\"] = r);\n  const i = await el(e);\n  i && (t[\"x-first-bytes\"] = i), typeof e == \"string\" && (e = new TextEncoder().encode(e));\n  const o = new Response(e, {\n    headers: t\n  });\n  return Object.defineProperty(o, \"url\", {\n    value: s\n  }), o;\n}\nasync function Zu(e) {\n  if (!e.ok) {\n    const t = await tl(e);\n    throw new Error(t);\n  }\n}\nasync function tl(e) {\n  let t = `Failed to fetch resource ${e.url} (${e.status}): `;\n  try {\n    const n = e.headers.get(\"Content-Type\");\n    let s = e.statusText;\n    n != null && n.includes(\"application/json\") && (s += ` ${await e.text()}`), t += s, t = t.length > 60 ? `${t.slice(0, 60)}...` : t;\n  } catch {\n  }\n  return t;\n}\nasync function el(e) {\n  if (typeof e == \"string\")\n    return `data:,${e.slice(0, 5)}`;\n  if (e instanceof Blob) {\n    const n = e.slice(0, 5);\n    return await new Promise((s) => {\n      const r = new FileReader();\n      r.onload = (i) => {\n        var o;\n        return s(i == null || (o = i.target) === null || o === void 0 ? void 0 : o.result);\n      }, r.readAsDataURL(n);\n    });\n  }\n  if (e instanceof ArrayBuffer) {\n    const n = e.slice(0, 5);\n    return `data:base64,${nl(n)}`;\n  }\n  return null;\n}\nfunction nl(e) {\n  let t = \"\";\n  const n = new Uint8Array(e);\n  for (let s = 0; s < n.byteLength; s++)\n    t += String.fromCharCode(n[s]);\n  return btoa(t);\n}\nfunction sl(e) {\n  return !rl(e) && !il(e);\n}\nfunction rl(e) {\n  return e.startsWith(\"http:\") || e.startsWith(\"https:\");\n}\nfunction il(e) {\n  return e.startsWith(\"data:\");\n}\nasync function Ge(e, t) {\n  if (typeof e == \"string\") {\n    const r = Gu(e);\n    if (sl(r)) {\n      var n;\n      if ((n = globalThis.loaders) !== null && n !== void 0 && n.fetchNode) {\n        var s;\n        return (s = globalThis.loaders) === null || s === void 0 ? void 0 : s.fetchNode(r, t);\n      }\n    }\n    return await fetch(r, t);\n  }\n  return await na(e);\n}\nfunction ol(e) {\n  if (typeof window < \"u\" && typeof window.process == \"object\" && window.process.type === \"renderer\" || typeof process < \"u\" && typeof process.versions == \"object\" && process.versions.electron)\n    return !0;\n  const t = typeof navigator == \"object\" && typeof navigator.userAgent == \"string\" && navigator.userAgent, n = e || t;\n  return !!(n && n.indexOf(\"Electron\") >= 0);\n}\nfunction Xe() {\n  return !(typeof process == \"object\" && String(process) === \"[object process]\" && !process.browser) || ol();\n}\nconst Ze = globalThis.window || globalThis.self || globalThis.global, Ee = globalThis.process || {}, sa = typeof __VERSION__ < \"u\" ? __VERSION__ : \"untranspiled source\";\nXe();\nfunction al(e) {\n  try {\n    const t = window[e], n = \"__storage_test__\";\n    return t.setItem(n, n), t.removeItem(n), t;\n  } catch {\n    return null;\n  }\n}\nclass cl {\n  constructor(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"sessionStorage\";\n    this.storage = void 0, this.id = void 0, this.config = void 0, this.storage = al(s), this.id = t, this.config = n, this._loadConfiguration();\n  }\n  getConfiguration() {\n    return this.config;\n  }\n  setConfiguration(t) {\n    if (Object.assign(this.config, t), this.storage) {\n      const n = JSON.stringify(this.config);\n      this.storage.setItem(this.id, n);\n    }\n  }\n  _loadConfiguration() {\n    let t = {};\n    if (this.storage) {\n      const n = this.storage.getItem(this.id);\n      t = n ? JSON.parse(n) : {};\n    }\n    return Object.assign(this.config, t), this;\n  }\n}\nfunction ul(e) {\n  let t;\n  return e < 10 ? t = \"\".concat(e.toFixed(2), \"ms\") : e < 100 ? t = \"\".concat(e.toFixed(1), \"ms\") : e < 1e3 ? t = \"\".concat(e.toFixed(0), \"ms\") : t = \"\".concat((e / 1e3).toFixed(2), \"s\"), t;\n}\nfunction ll(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;\n  const n = Math.max(t - e.length, 0);\n  return \"\".concat(\" \".repeat(n)).concat(e);\n}\nfunction ls(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;\n  const r = e.src.replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\");\n  e.width > s && (n = Math.min(n, s / e.width));\n  const i = e.width * n, o = e.height * n, a = [\"font-size:1px;\", \"padding:\".concat(Math.floor(o / 2), \"px \").concat(Math.floor(i / 2), \"px;\"), \"line-height:\".concat(o, \"px;\"), \"background:url(\".concat(r, \");\"), \"background-size:\".concat(i, \"px \").concat(o, \"px;\"), \"color:transparent;\"].join(\"\");\n  return [\"\".concat(t, \" %c+\"), a];\n}\nlet In;\n(function(e) {\n  e[e.BLACK = 30] = \"BLACK\", e[e.RED = 31] = \"RED\", e[e.GREEN = 32] = \"GREEN\", e[e.YELLOW = 33] = \"YELLOW\", e[e.BLUE = 34] = \"BLUE\", e[e.MAGENTA = 35] = \"MAGENTA\", e[e.CYAN = 36] = \"CYAN\", e[e.WHITE = 37] = \"WHITE\", e[e.BRIGHT_BLACK = 90] = \"BRIGHT_BLACK\", e[e.BRIGHT_RED = 91] = \"BRIGHT_RED\", e[e.BRIGHT_GREEN = 92] = \"BRIGHT_GREEN\", e[e.BRIGHT_YELLOW = 93] = \"BRIGHT_YELLOW\", e[e.BRIGHT_BLUE = 94] = \"BRIGHT_BLUE\", e[e.BRIGHT_MAGENTA = 95] = \"BRIGHT_MAGENTA\", e[e.BRIGHT_CYAN = 96] = \"BRIGHT_CYAN\", e[e.BRIGHT_WHITE = 97] = \"BRIGHT_WHITE\";\n})(In || (In = {}));\nconst hl = 10;\nfunction ei(e) {\n  return typeof e != \"string\" ? e : (e = e.toUpperCase(), In[e] || In.WHITE);\n}\nfunction fl(e, t, n) {\n  if (!Xe && typeof e == \"string\") {\n    if (t) {\n      const s = ei(t);\n      e = \"\\x1B[\".concat(s, \"m\").concat(e, \"\\x1B[39m\");\n    }\n    if (n) {\n      const s = ei(n);\n      e = \"\\x1B[\".concat(s + hl, \"m\").concat(e, \"\\x1B[49m\");\n    }\n  }\n  return e;\n}\nfunction dl(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [\"constructor\"];\n  const n = Object.getPrototypeOf(e), s = Object.getOwnPropertyNames(n), r = e;\n  for (const i of s) {\n    const o = r[i];\n    typeof o == \"function\" && (t.find((a) => i === a) || (r[i] = o.bind(e)));\n  }\n}\nfunction xn(e, t) {\n  if (!e)\n    throw new Error(t || \"Assertion failed\");\n}\nfunction ae() {\n  let e;\n  if (Xe() && Ze.performance) {\n    var t, n;\n    e = Ze == null || (t = Ze.performance) === null || t === void 0 || (n = t.now) === null || n === void 0 ? void 0 : n.call(t);\n  } else if (\"hrtime\" in Ee) {\n    var s;\n    const r = Ee == null || (s = Ee.hrtime) === null || s === void 0 ? void 0 : s.call(Ee);\n    e = r[0] * 1e3 + r[1] / 1e6;\n  } else\n    e = Date.now();\n  return e;\n}\nconst ce = {\n  debug: Xe() && console.debug || console.log,\n  log: console.log,\n  info: console.info,\n  warn: console.warn,\n  error: console.error\n}, ml = {\n  enabled: !0,\n  level: 0\n};\nfunction Ct() {\n}\nconst ni = {}, si = {\n  once: !0\n};\nclass zn {\n  constructor() {\n    let {\n      id: t\n    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n      id: \"\"\n    };\n    this.id = void 0, this.VERSION = sa, this._startTs = ae(), this._deltaTs = ae(), this._storage = void 0, this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = t, this.userData = {}, this._storage = new cl(\"__probe-\".concat(this.id, \"__\"), ml), this.timeStamp(\"\".concat(this.id, \" started\")), dl(this), Object.seal(this);\n  }\n  set level(t) {\n    this.setLevel(t);\n  }\n  get level() {\n    return this.getLevel();\n  }\n  isEnabled() {\n    return this._storage.config.enabled;\n  }\n  getLevel() {\n    return this._storage.config.level;\n  }\n  getTotal() {\n    return Number((ae() - this._startTs).toPrecision(10));\n  }\n  getDelta() {\n    return Number((ae() - this._deltaTs).toPrecision(10));\n  }\n  set priority(t) {\n    this.level = t;\n  }\n  get priority() {\n    return this.level;\n  }\n  getPriority() {\n    return this.level;\n  }\n  enable() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n    return this._storage.setConfiguration({\n      enabled: t\n    }), this;\n  }\n  setLevel(t) {\n    return this._storage.setConfiguration({\n      level: t\n    }), this;\n  }\n  get(t) {\n    return this._storage.config[t];\n  }\n  set(t, n) {\n    this._storage.setConfiguration({\n      [t]: n\n    });\n  }\n  settings() {\n    console.table ? console.table(this._storage.config) : console.log(this._storage.config);\n  }\n  assert(t, n) {\n    xn(t, n);\n  }\n  warn(t) {\n    return this._getLogFunction(0, t, ce.warn, arguments, si);\n  }\n  error(t) {\n    return this._getLogFunction(0, t, ce.error, arguments);\n  }\n  deprecated(t, n) {\n    return this.warn(\"`\".concat(t, \"` is deprecated and will be removed in a later version. Use `\").concat(n, \"` instead\"));\n  }\n  removed(t, n) {\n    return this.error(\"`\".concat(t, \"` has been removed. Use `\").concat(n, \"` instead\"));\n  }\n  probe(t, n) {\n    return this._getLogFunction(t, n, ce.log, arguments, {\n      time: !0,\n      once: !0\n    });\n  }\n  log(t, n) {\n    return this._getLogFunction(t, n, ce.debug, arguments);\n  }\n  info(t, n) {\n    return this._getLogFunction(t, n, console.info, arguments);\n  }\n  once(t, n) {\n    return this._getLogFunction(t, n, ce.debug || ce.info, arguments, si);\n  }\n  table(t, n, s) {\n    return n ? this._getLogFunction(t, n, console.table || Ct, s && [s], {\n      tag: yl(n)\n    }) : Ct;\n  }\n  image(t) {\n    let {\n      logLevel: n,\n      priority: s,\n      image: r,\n      message: i = \"\",\n      scale: o = 1\n    } = t;\n    return this._shouldLog(n || s) ? Xe() ? pl({\n      image: r,\n      message: i,\n      scale: o\n    }) : Al() : Ct;\n  }\n  time(t, n) {\n    return this._getLogFunction(t, n, console.time ? console.time : console.info);\n  }\n  timeEnd(t, n) {\n    return this._getLogFunction(t, n, console.timeEnd ? console.timeEnd : console.info);\n  }\n  timeStamp(t, n) {\n    return this._getLogFunction(t, n, console.timeStamp || Ct);\n  }\n  group(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n      collapsed: !1\n    };\n    const r = ri({\n      logLevel: t,\n      message: n,\n      opts: s\n    }), {\n      collapsed: i\n    } = s;\n    return r.method = (i ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(r);\n  }\n  groupCollapsed(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return this.group(t, n, Object.assign({}, s, {\n      collapsed: !0\n    }));\n  }\n  groupEnd(t) {\n    return this._getLogFunction(t, \"\", console.groupEnd || Ct);\n  }\n  withGroup(t, n, s) {\n    this.group(t, n)();\n    try {\n      s();\n    } finally {\n      this.groupEnd(t)();\n    }\n  }\n  trace() {\n    console.trace && console.trace();\n  }\n  _shouldLog(t) {\n    return this.isEnabled() && this.getLevel() >= ra(t);\n  }\n  _getLogFunction(t, n, s, r, i) {\n    if (this._shouldLog(t)) {\n      i = ri({\n        logLevel: t,\n        message: n,\n        args: r,\n        opts: i\n      }), s = s || i.method, xn(s), i.total = this.getTotal(), i.delta = this.getDelta(), this._deltaTs = ae();\n      const o = i.tag || i.message;\n      if (i.once && o)\n        if (!ni[o])\n          ni[o] = ae();\n        else\n          return Ct;\n      return n = gl(this.id, i.message, i), s.bind(console, n, ...i.args);\n    }\n    return Ct;\n  }\n}\nzn.VERSION = sa;\nfunction ra(e) {\n  if (!e)\n    return 0;\n  let t;\n  switch (typeof e) {\n    case \"number\":\n      t = e;\n      break;\n    case \"object\":\n      t = e.logLevel || e.priority || 0;\n      break;\n    default:\n      return 0;\n  }\n  return xn(Number.isFinite(t) && t >= 0), t;\n}\nfunction ri(e) {\n  const {\n    logLevel: t,\n    message: n\n  } = e;\n  e.logLevel = ra(t);\n  const s = e.args ? Array.from(e.args) : [];\n  for (; s.length && s.shift() !== n; )\n    ;\n  switch (typeof t) {\n    case \"string\":\n    case \"function\":\n      n !== void 0 && s.unshift(n), e.message = t;\n      break;\n    case \"object\":\n      Object.assign(e, t);\n      break;\n  }\n  typeof e.message == \"function\" && (e.message = e.message());\n  const r = typeof e.message;\n  return xn(r === \"string\" || r === \"object\"), Object.assign(e, {\n    args: s\n  }, e.opts);\n}\nfunction gl(e, t, n) {\n  if (typeof t == \"string\") {\n    const s = n.time ? ll(ul(n.total)) : \"\";\n    t = n.time ? \"\".concat(e, \": \").concat(s, \"  \").concat(t) : \"\".concat(e, \": \").concat(t), t = fl(t, n.color, n.background);\n  }\n  return t;\n}\nfunction Al(e) {\n  return console.warn(\"removed\"), Ct;\n}\nfunction pl(e) {\n  let {\n    image: t,\n    message: n = \"\",\n    scale: s = 1\n  } = e;\n  if (typeof t == \"string\") {\n    const i = new Image();\n    return i.onload = () => {\n      const o = ls(i, n, s);\n      console.log(...o);\n    }, i.src = t, Ct;\n  }\n  const r = t.nodeName || \"\";\n  if (r.toLowerCase() === \"img\")\n    return console.log(...ls(t, n, s)), Ct;\n  if (r.toLowerCase() === \"canvas\") {\n    const i = new Image();\n    return i.onload = () => console.log(...ls(i, n, s)), i.src = t.toDataURL(), Ct;\n  }\n  return Ct;\n}\nfunction yl(e) {\n  for (const t in e)\n    for (const n in e[t])\n      return n || \"untitled\";\n  return \"empty\";\n}\nconst ia = new zn({\n  id: \"@probe.gl/log\"\n}), ii = new zn({\n  id: \"loaders.gl\"\n});\nclass Bl {\n  log() {\n    return () => {\n    };\n  }\n  info() {\n    return () => {\n    };\n  }\n  warn() {\n    return () => {\n    };\n  }\n  error() {\n    return () => {\n    };\n  }\n}\nclass Cl {\n  constructor() {\n    this.console = void 0, this.console = console;\n  }\n  log() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.log.bind(this.console, ...n);\n  }\n  info() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.info.bind(this.console, ...n);\n  }\n  warn() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.warn.bind(this.console, ...n);\n  }\n  error() {\n    for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++)\n      n[s] = arguments[s];\n    return this.console.error.bind(this.console, ...n);\n  }\n}\nconst oa = {\n  fetch: null,\n  mimeType: void 0,\n  nothrow: !1,\n  log: new Cl(),\n  useLocalLibraries: !1,\n  CDN: \"https://unpkg.com/@loaders.gl\",\n  worker: !0,\n  maxConcurrency: 3,\n  maxMobileConcurrency: 1,\n  reuseWorkers: kn,\n  _nodeWorkers: !1,\n  _workerType: \"\",\n  limit: 0,\n  _limitMB: 0,\n  batchSize: \"auto\",\n  batchDebounceMs: 0,\n  metadata: !1,\n  transforms: []\n}, El = {\n  throws: \"nothrow\",\n  dataType: \"(no longer used)\",\n  uri: \"baseUri\",\n  method: \"fetch.method\",\n  headers: \"fetch.headers\",\n  body: \"fetch.body\",\n  mode: \"fetch.mode\",\n  credentials: \"fetch.credentials\",\n  cache: \"fetch.cache\",\n  redirect: \"fetch.redirect\",\n  referrer: \"fetch.referrer\",\n  referrerPolicy: \"fetch.referrerPolicy\",\n  integrity: \"fetch.integrity\",\n  keepalive: \"fetch.keepalive\",\n  signal: \"fetch.signal\"\n};\nfunction aa() {\n  globalThis.loaders = globalThis.loaders || {};\n  const {\n    loaders: e\n  } = globalThis;\n  return e._state = e._state || {}, e._state;\n}\nfunction ca() {\n  const e = aa();\n  return e.globalOptions = e.globalOptions || {\n    ...oa\n  }, e.globalOptions;\n}\nfunction Tl(e, t, n, s) {\n  return n = n || [], n = Array.isArray(n) ? n : [n], bl(e, n), wl(t, e, s);\n}\nfunction bl(e, t) {\n  oi(e, null, oa, El, t);\n  for (const n of t) {\n    const s = e && e[n.id] || {}, r = n.options && n.options[n.id] || {}, i = n.deprecatedOptions && n.deprecatedOptions[n.id] || {};\n    oi(s, n.id, r, i, t);\n  }\n}\nfunction oi(e, t, n, s, r) {\n  const i = t || \"Top level\", o = t ? `${t}.` : \"\";\n  for (const a in e) {\n    const c = !t && We(e[a]), u = a === \"baseUri\" && !t, l = a === \"workerUrl\" && t;\n    if (!(a in n) && !u && !l) {\n      if (a in s)\n        ii.warn(`${i} loader option '${o}${a}' no longer supported, use '${s[a]}'`)();\n      else if (!c) {\n        const h = _l(a, r);\n        ii.warn(`${i} loader option '${o}${a}' not recognized. ${h}`)();\n      }\n    }\n  }\n}\nfunction _l(e, t) {\n  const n = e.toLowerCase();\n  let s = \"\";\n  for (const r of t)\n    for (const i in r.options) {\n      if (e === i)\n        return `Did you mean '${r.id}.${i}'?`;\n      const o = i.toLowerCase();\n      (n.startsWith(o) || o.startsWith(n)) && (s = s || `Did you mean '${r.id}.${i}'?`);\n    }\n  return s;\n}\nfunction wl(e, t, n) {\n  const r = {\n    ...e.options || {}\n  };\n  return Rl(r, n), r.log === null && (r.log = new Bl()), ai(r, ca()), ai(r, t), r;\n}\nfunction ai(e, t) {\n  for (const n in t)\n    if (n in t) {\n      const s = t[n];\n      Zr(s) && Zr(e[n]) ? e[n] = {\n        ...e[n],\n        ...t[n]\n      } : e[n] = t[n];\n    }\n}\nfunction Rl(e, t) {\n  t && !(\"baseUri\" in e) && (e.baseUri = t);\n}\nfunction Ar(e) {\n  var t;\n  return e ? (Array.isArray(e) && (e = e[0]), Array.isArray((t = e) === null || t === void 0 ? void 0 : t.extensions)) : !1;\n}\nfunction ua(e) {\n  var t, n;\n  K(e, \"null loader\"), K(Ar(e), \"invalid loader\");\n  let s;\n  return Array.isArray(e) && (s = e[1], e = e[0], e = {\n    ...e,\n    options: {\n      ...e.options,\n      ...s\n    }\n  }), ((t = e) !== null && t !== void 0 && t.parseTextSync || (n = e) !== null && n !== void 0 && n.parseText) && (e.text = !0), e.text || (e.binary = !0), e;\n}\nconst Ml = () => {\n  const e = aa();\n  return e.loaderRegistry = e.loaderRegistry || [], e.loaderRegistry;\n};\nfunction Sl() {\n  return Ml();\n}\nconst Il = new zn({\n  id: \"loaders.gl\"\n}), xl = /\\.([^.]+)$/;\nasync function vl(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], n = arguments.length > 2 ? arguments[2] : void 0, s = arguments.length > 3 ? arguments[3] : void 0;\n  if (!la(e))\n    return null;\n  let r = ci(e, t, {\n    ...n,\n    nothrow: !0\n  }, s);\n  if (r)\n    return r;\n  if (re(e) && (e = await e.slice(0, 10).arrayBuffer(), r = ci(e, t, n, s)), !r && !(n != null && n.nothrow))\n    throw new Error(ha(e));\n  return r;\n}\nfunction ci(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], n = arguments.length > 2 ? arguments[2] : void 0, s = arguments.length > 3 ? arguments[3] : void 0;\n  if (!la(e))\n    return null;\n  if (t && !Array.isArray(t))\n    return ua(t);\n  let r = [];\n  t && (r = r.concat(t)), n != null && n.ignoreRegisteredLoaders || r.push(...Sl()), Fl(r);\n  const i = Ol(e, r, n, s);\n  if (!i && !(n != null && n.nothrow))\n    throw new Error(ha(e));\n  return i;\n}\nfunction Ol(e, t, n, s) {\n  const r = Kn(e), i = gr(e), o = mr(r) || (s == null ? void 0 : s.url);\n  let a = null, c = \"\";\n  if (n != null && n.mimeType && (a = hs(t, n == null ? void 0 : n.mimeType), c = `match forced by supplied MIME type ${n == null ? void 0 : n.mimeType}`), a = a || Dl(t, o), c = c || (a ? `matched url ${o}` : \"\"), a = a || hs(t, i), c = c || (a ? `matched MIME type ${i}` : \"\"), a = a || Pl(t, e), c = c || (a ? `matched initial data ${fa(e)}` : \"\"), n != null && n.fallbackMimeType && (a = a || hs(t, n == null ? void 0 : n.fallbackMimeType), c = c || (a ? `matched fallback MIME type ${i}` : \"\")), c) {\n    var u;\n    Il.log(1, `selectLoader selected ${(u = a) === null || u === void 0 ? void 0 : u.name}: ${c}.`);\n  }\n  return a;\n}\nfunction la(e) {\n  return !(e instanceof Response && e.status === 204);\n}\nfunction ha(e) {\n  const t = Kn(e), n = gr(e);\n  let s = \"No valid loader found (\";\n  s += t ? `${$o(t)}, ` : \"no url provided, \", s += `MIME type: ${n ? `\"${n}\"` : \"not provided\"}, `;\n  const r = e ? fa(e) : \"\";\n  return s += r ? ` first bytes: \"${r}\"` : \"first bytes: not available\", s += \")\", s;\n}\nfunction Fl(e) {\n  for (const t of e)\n    ua(t);\n}\nfunction Dl(e, t) {\n  const n = t && xl.exec(t), s = n && n[1];\n  return s ? Ll(e, s) : null;\n}\nfunction Ll(e, t) {\n  t = t.toLowerCase();\n  for (const n of e)\n    for (const s of n.extensions)\n      if (s.toLowerCase() === t)\n        return n;\n  return null;\n}\nfunction hs(e, t) {\n  for (const n of e)\n    if (n.mimeTypes && n.mimeTypes.includes(t) || t === `application/x.${n.id}`)\n      return n;\n  return null;\n}\nfunction Pl(e, t) {\n  if (!t)\n    return null;\n  for (const n of e)\n    if (typeof t == \"string\") {\n      if (Gl(t, n))\n        return n;\n    } else if (ArrayBuffer.isView(t)) {\n      if (ui(t.buffer, t.byteOffset, n))\n        return n;\n    } else if (t instanceof ArrayBuffer && ui(t, 0, n))\n      return n;\n  return null;\n}\nfunction Gl(e, t) {\n  return t.testText ? t.testText(e) : (Array.isArray(t.tests) ? t.tests : [t.tests]).some((s) => e.startsWith(s));\n}\nfunction ui(e, t, n) {\n  return (Array.isArray(n.tests) ? n.tests : [n.tests]).some((r) => Nl(e, t, n, r));\n}\nfunction Nl(e, t, n, s) {\n  if (s instanceof ArrayBuffer)\n    return vu(s, e, s.byteLength);\n  switch (typeof s) {\n    case \"function\":\n      return s(e);\n    case \"string\":\n      const r = js(e, t, s.length);\n      return s === r;\n    default:\n      return !1;\n  }\n}\nfunction fa(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n  return typeof e == \"string\" ? e.slice(0, t) : ArrayBuffer.isView(e) ? js(e.buffer, e.byteOffset, t) : e instanceof ArrayBuffer ? js(e, 0, t) : \"\";\n}\nfunction js(e, t, n) {\n  if (e.byteLength < t + n)\n    return \"\";\n  const s = new DataView(e);\n  let r = \"\";\n  for (let i = 0; i < n; i++)\n    r += String.fromCharCode(s.getUint8(t + i));\n  return r;\n}\nconst Ul = 256 * 1024;\nfunction* Hl(e, t) {\n  const n = (t == null ? void 0 : t.chunkSize) || Ul;\n  let s = 0;\n  const r = new TextEncoder();\n  for (; s < e.length; ) {\n    const i = Math.min(e.length - s, n), o = e.slice(s, s + i);\n    s += i, yield r.encode(o);\n  }\n}\nconst Jl = 256 * 1024;\nfunction Vl(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return function* () {\n    const {\n      chunkSize: n = Jl\n    } = t;\n    let s = 0;\n    for (; s < e.byteLength; ) {\n      const r = Math.min(e.byteLength - s, n), i = new ArrayBuffer(r), o = new Uint8Array(e, s, r);\n      new Uint8Array(i).set(o), s += r, yield i;\n    }\n  }();\n}\nconst jl = 1024 * 1024;\nasync function* kl(e, t) {\n  const n = (t == null ? void 0 : t.chunkSize) || jl;\n  let s = 0;\n  for (; s < e.size; ) {\n    const r = s + n, i = await e.slice(s, r).arrayBuffer();\n    s = r, yield i;\n  }\n}\nfunction li(e, t) {\n  return kn ? Kl(e, t) : zl(e);\n}\nasync function* Kl(e, t) {\n  const n = e.getReader();\n  let s;\n  try {\n    for (; ; ) {\n      const r = s || n.read();\n      t != null && t._streamReadAhead && (s = n.read());\n      const {\n        done: i,\n        value: o\n      } = await r;\n      if (i)\n        return;\n      yield Yo(o);\n    }\n  } catch {\n    n.releaseLock();\n  }\n}\nasync function* zl(e, t) {\n  for await (const n of e)\n    yield Yo(n);\n}\nfunction Wl(e, t) {\n  if (typeof e == \"string\")\n    return Hl(e, t);\n  if (e instanceof ArrayBuffer)\n    return Vl(e, t);\n  if (re(e))\n    return kl(e, t);\n  if (ta(e))\n    return li(e, t);\n  if (se(e))\n    return li(e.body, t);\n  throw new Error(\"makeIterator\");\n}\nconst da = \"Cannot convert supplied data type\";\nfunction Xl(e, t, n) {\n  if (t.text && typeof e == \"string\")\n    return e;\n  if (Ku(e) && (e = e.buffer), e instanceof ArrayBuffer) {\n    const s = e;\n    return t.text && !t.binary ? new TextDecoder(\"utf8\").decode(s) : s;\n  }\n  if (ArrayBuffer.isView(e)) {\n    if (t.text && !t.binary)\n      return new TextDecoder(\"utf8\").decode(e);\n    let s = e.buffer;\n    const r = e.byteLength || e.length;\n    return (e.byteOffset !== 0 || r !== s.byteLength) && (s = s.slice(e.byteOffset, e.byteOffset + r)), s;\n  }\n  throw new Error(da);\n}\nasync function Ql(e, t, n) {\n  const s = e instanceof ArrayBuffer || ArrayBuffer.isView(e);\n  if (typeof e == \"string\" || s)\n    return Xl(e, t);\n  if (re(e) && (e = await na(e)), se(e)) {\n    const r = e;\n    return await Zu(r), t.binary ? await r.arrayBuffer() : await r.text();\n  }\n  if (ta(e) && (e = Wl(e, n)), ju(e) || ku(e))\n    return Lu(e);\n  throw new Error(da);\n}\nfunction ma(e, t) {\n  const n = ca(), s = e || n;\n  return typeof s.fetch == \"function\" ? s.fetch : We(s.fetch) ? (r) => Ge(r, s.fetch) : t != null && t.fetch ? t == null ? void 0 : t.fetch : Ge;\n}\nfunction ql(e, t, n) {\n  if (n)\n    return n;\n  const s = {\n    fetch: ma(t, e),\n    ...e\n  };\n  if (s.url) {\n    const r = mr(s.url);\n    s.baseUrl = r, s.queryString = Yu(s.url), s.filename = $o(r), s.baseUrl = Zo(r);\n  }\n  return Array.isArray(s.loaders) || (s.loaders = null), s;\n}\nfunction Yl(e, t) {\n  if (e && !Array.isArray(e))\n    return e;\n  let n;\n  if (e && (n = Array.isArray(e) ? e : [e]), t && t.loaders) {\n    const s = Array.isArray(t.loaders) ? t.loaders : [t.loaders];\n    n = n ? [...n, ...s] : s;\n  }\n  return n && n.length ? n : void 0;\n}\nasync function vn(e, t, n, s) {\n  t && !Array.isArray(t) && !Ar(t) && (s = void 0, n = t, t = void 0), e = await e, n = n || {};\n  const r = Kn(e), o = Yl(t, s), a = await vl(e, o, n);\n  return a ? (n = Tl(n, a, o, r), s = ql({\n    url: r,\n    _parse: vn,\n    loaders: o\n  }, n, s || null), await $l(a, e, n, s)) : null;\n}\nasync function $l(e, t, n, s) {\n  if (yu(e), n = au(e.options, n), se(t)) {\n    const i = t, {\n      ok: o,\n      redirected: a,\n      status: c,\n      statusText: u,\n      type: l,\n      url: h\n    } = i, f = Object.fromEntries(i.headers.entries());\n    s.response = {\n      headers: f,\n      ok: o,\n      redirected: a,\n      status: c,\n      statusText: u,\n      type: l,\n      url: h\n    };\n  }\n  t = await Ql(t, e, n);\n  const r = e;\n  if (r.parseTextSync && typeof t == \"string\")\n    return r.parseTextSync(t, n, s);\n  if (Ru(e, n))\n    return await Mu(e, t, n, s, vn);\n  if (r.parseText && typeof t == \"string\")\n    return await r.parseText(t, n, s);\n  if (r.parse)\n    return await r.parse(t, n, s);\n  throw Jt(!r.parseSync), new Error(`${e.id} loader - no parser found and worker is disabled`);\n}\nfunction Zl(e) {\n  switch (e.constructor) {\n    case Int8Array:\n      return \"int8\";\n    case Uint8Array:\n    case Uint8ClampedArray:\n      return \"uint8\";\n    case Int16Array:\n      return \"int16\";\n    case Uint16Array:\n      return \"uint16\";\n    case Int32Array:\n      return \"int32\";\n    case Uint32Array:\n      return \"uint32\";\n    case Float32Array:\n      return \"float32\";\n    case Float64Array:\n      return \"float64\";\n    default:\n      return \"null\";\n  }\n}\nfunction th(e) {\n  let t = 1 / 0, n = 1 / 0, s = 1 / 0, r = -1 / 0, i = -1 / 0, o = -1 / 0;\n  const a = e.POSITION ? e.POSITION.value : [], c = a && a.length;\n  for (let u = 0; u < c; u += 3) {\n    const l = a[u], h = a[u + 1], f = a[u + 2];\n    t = l < t ? l : t, n = h < n ? h : n, s = f < s ? f : s, r = l > r ? l : r, i = h > i ? h : i, o = f > o ? f : o;\n  }\n  return [[t, n, s], [r, i, o]];\n}\nfunction eh(e, t, n) {\n  const s = Zl(t.value), r = n || nh(t);\n  return {\n    name: e,\n    type: {\n      type: \"fixed-size-list\",\n      listSize: t.size,\n      children: [{\n        name: \"value\",\n        type: s\n      }]\n    },\n    nullable: !1,\n    metadata: r\n  };\n}\nfunction nh(e) {\n  const t = {};\n  return \"byteOffset\" in e && (t.byteOffset = e.byteOffset.toString(10)), \"byteStride\" in e && (t.byteStride = e.byteStride.toString(10)), \"normalized\" in e && (t.normalized = e.normalized.toString()), t;\n}\nasync function Ae(e, t, n, s) {\n  let r, i;\n  !Array.isArray(t) && !Ar(t) ? (r = [], i = t) : (r = t, i = n);\n  const o = ma(i);\n  let a = e;\n  return typeof e == \"string\" && (a = await o(e)), re(e) && (a = await o(e)), Array.isArray(r) ? await vn(a, r, i) : await vn(a, r, i);\n}\nconst sh = 1 / Math.PI * 180, rh = 1 / 180 * Math.PI, ih = {\n  EPSILON: 1e-12,\n  debug: !1,\n  precision: 4,\n  printTypes: !1,\n  printDegrees: !1,\n  printRowMajor: !0,\n  _cartographicRadians: !1\n};\nglobalThis.mathgl = globalThis.mathgl || {\n  config: {\n    ...ih\n  }\n};\nconst Z = globalThis.mathgl.config;\nfunction oh(e, {\n  precision: t = Z.precision\n} = {}) {\n  return e = hh(e), \"\".concat(parseFloat(e.toPrecision(t)));\n}\nfunction ee(e) {\n  return Array.isArray(e) || ArrayBuffer.isView(e) && !(e instanceof DataView);\n}\nfunction ah(e) {\n  return uh(e);\n}\nfunction ch(e) {\n  return Rt(e);\n}\nfunction uh(e, t) {\n  return pr(e, (n) => n * rh, t);\n}\nfunction Rt(e, t) {\n  return pr(e, (n) => n * sh, t);\n}\nfunction lh(e, t, n) {\n  return pr(e, (s) => Math.max(t, Math.min(n, s)));\n}\nfunction Kt(e, t, n) {\n  const s = Z.EPSILON;\n  n && (Z.EPSILON = n);\n  try {\n    if (e === t)\n      return !0;\n    if (ee(e) && ee(t)) {\n      if (e.length !== t.length)\n        return !1;\n      for (let r = 0; r < e.length; ++r)\n        if (!Kt(e[r], t[r]))\n          return !1;\n      return !0;\n    }\n    return e && e.equals ? e.equals(t) : t && t.equals ? t.equals(e) : typeof e == \"number\" && typeof t == \"number\" ? Math.abs(e - t) <= Z.EPSILON * Math.max(1, Math.abs(e), Math.abs(t)) : !1;\n  } finally {\n    Z.EPSILON = s;\n  }\n}\nfunction hh(e) {\n  return Math.round(e / Z.EPSILON) * Z.EPSILON;\n}\nfunction fh(e) {\n  return e.clone ? e.clone() : new Array(e.length);\n}\nfunction pr(e, t, n) {\n  if (ee(e)) {\n    const s = e;\n    n = n || fh(s);\n    for (let r = 0; r < n.length && r < s.length; ++r) {\n      const i = typeof e == \"number\" ? e : e[r];\n      n[r] = t(i, r, n);\n    }\n    return n;\n  }\n  return t(e);\n}\nfunction dh(e) {\n  function t() {\n    var n = Reflect.construct(e, Array.from(arguments));\n    return Object.setPrototypeOf(n, Object.getPrototypeOf(this)), n;\n  }\n  return t.prototype = Object.create(e.prototype, {\n    constructor: {\n      value: e,\n      enumerable: !1,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e, t;\n}\nclass yr extends dh(Array) {\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  fromArray(t, n = 0) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      this[s] = t[s + n];\n    return this.check();\n  }\n  toArray(t = [], n = 0) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      t[n + s] = this[s];\n    return t;\n  }\n  toObject(t) {\n    return t;\n  }\n  from(t) {\n    return Array.isArray(t) ? this.copy(t) : this.fromObject(t);\n  }\n  to(t) {\n    return t === this ? this : ee(t) ? this.toArray(t) : this.toObject(t);\n  }\n  toTarget(t) {\n    return t ? this.to(t) : this;\n  }\n  toFloat32Array() {\n    return new Float32Array(this);\n  }\n  toString() {\n    return this.formatString(Z);\n  }\n  formatString(t) {\n    let n = \"\";\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      n += (s > 0 ? \", \" : \"\") + oh(this[s], t);\n    return \"\".concat(t.printTypes ? this.constructor.name : \"\", \"[\").concat(n, \"]\");\n  }\n  equals(t) {\n    if (!t || this.length !== t.length)\n      return !1;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      if (!Kt(this[n], t[n]))\n        return !1;\n    return !0;\n  }\n  exactEquals(t) {\n    if (!t || this.length !== t.length)\n      return !1;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      if (this[n] !== t[n])\n        return !1;\n    return !0;\n  }\n  negate() {\n    for (let t = 0; t < this.ELEMENTS; ++t)\n      this[t] = -this[t];\n    return this.check();\n  }\n  lerp(t, n, s) {\n    if (s === void 0)\n      return this.lerp(this, t, n);\n    for (let r = 0; r < this.ELEMENTS; ++r) {\n      const i = t[r], o = typeof n == \"number\" ? n : n[r];\n      this[r] = i + s * (o - i);\n    }\n    return this.check();\n  }\n  min(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] = Math.min(t[n], this[n]);\n    return this.check();\n  }\n  max(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] = Math.max(t[n], this[n]);\n    return this.check();\n  }\n  clamp(t, n) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      this[s] = Math.min(Math.max(this[s], t[s]), n[s]);\n    return this.check();\n  }\n  add(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] += n[s];\n    return this.check();\n  }\n  subtract(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] -= n[s];\n    return this.check();\n  }\n  scale(t) {\n    if (typeof t == \"number\")\n      for (let n = 0; n < this.ELEMENTS; ++n)\n        this[n] *= t;\n    else\n      for (let n = 0; n < this.ELEMENTS && n < t.length; ++n)\n        this[n] *= t[n];\n    return this.check();\n  }\n  multiplyByScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] *= t;\n    return this.check();\n  }\n  check() {\n    if (Z.debug && !this.validate())\n      throw new Error(\"math.gl: \".concat(this.constructor.name, \" some fields set to invalid numbers'\"));\n    return this;\n  }\n  validate() {\n    let t = this.length === this.ELEMENTS;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      t = t && Number.isFinite(this[n]);\n    return t;\n  }\n  sub(t) {\n    return this.subtract(t);\n  }\n  setScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] = t;\n    return this.check();\n  }\n  addScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] += t;\n    return this.check();\n  }\n  subScalar(t) {\n    return this.addScalar(-t);\n  }\n  multiplyScalar(t) {\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      this[n] *= t;\n    return this.check();\n  }\n  divideScalar(t) {\n    return this.multiplyByScalar(1 / t);\n  }\n  clampScalar(t, n) {\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      this[s] = Math.min(Math.max(this[s], t), n);\n    return this.check();\n  }\n  get elements() {\n    return this;\n  }\n}\nfunction mh(e, t) {\n  if (e.length !== t)\n    return !1;\n  for (let n = 0; n < e.length; ++n)\n    if (!Number.isFinite(e[n]))\n      return !1;\n  return !0;\n}\nfunction U(e) {\n  if (!Number.isFinite(e))\n    throw new Error(\"Invalid number \".concat(JSON.stringify(e)));\n  return e;\n}\nfunction Oe(e, t, n = \"\") {\n  if (Z.debug && !mh(e, t))\n    throw new Error(\"math.gl: \".concat(n, \" some fields set to invalid numbers'\"));\n  return e;\n}\nfunction j(e, t) {\n  if (!e)\n    throw new Error(\"math.gl assertion \".concat(t));\n}\nclass Br extends yr {\n  get x() {\n    return this[0];\n  }\n  set x(t) {\n    this[0] = U(t);\n  }\n  get y() {\n    return this[1];\n  }\n  set y(t) {\n    this[1] = U(t);\n  }\n  len() {\n    return Math.sqrt(this.lengthSquared());\n  }\n  magnitude() {\n    return this.len();\n  }\n  lengthSquared() {\n    let t = 0;\n    for (let n = 0; n < this.ELEMENTS; ++n)\n      t += this[n] * this[n];\n    return t;\n  }\n  magnitudeSquared() {\n    return this.lengthSquared();\n  }\n  distance(t) {\n    return Math.sqrt(this.distanceSquared(t));\n  }\n  distanceSquared(t) {\n    let n = 0;\n    for (let s = 0; s < this.ELEMENTS; ++s) {\n      const r = this[s] - t[s];\n      n += r * r;\n    }\n    return U(n);\n  }\n  dot(t) {\n    let n = 0;\n    for (let s = 0; s < this.ELEMENTS; ++s)\n      n += this[s] * t[s];\n    return U(n);\n  }\n  normalize() {\n    const t = this.magnitude();\n    if (t !== 0)\n      for (let n = 0; n < this.ELEMENTS; ++n)\n        this[n] /= t;\n    return this.check();\n  }\n  multiply(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] *= n[s];\n    return this.check();\n  }\n  divide(...t) {\n    for (const n of t)\n      for (let s = 0; s < this.ELEMENTS; ++s)\n        this[s] /= n[s];\n    return this.check();\n  }\n  lengthSq() {\n    return this.lengthSquared();\n  }\n  distanceTo(t) {\n    return this.distance(t);\n  }\n  distanceToSquared(t) {\n    return this.distanceSquared(t);\n  }\n  getComponent(t) {\n    return j(t >= 0 && t < this.ELEMENTS, \"index is out of range\"), U(this[t]);\n  }\n  setComponent(t, n) {\n    return j(t >= 0 && t < this.ELEMENTS, \"index is out of range\"), this[t] = n, this.check();\n  }\n  addVectors(t, n) {\n    return this.copy(t).add(n);\n  }\n  subVectors(t, n) {\n    return this.copy(t).subtract(n);\n  }\n  multiplyVectors(t, n) {\n    return this.copy(t).multiply(n);\n  }\n  addScaledVector(t, n) {\n    return this.add(new this.constructor(t).multiplyScalar(n));\n  }\n}\nconst Fe = 1e-6;\nlet It = typeof Float32Array < \"u\" ? Float32Array : Array;\nfunction gh() {\n  const e = new It(2);\n  return It != Float32Array && (e[0] = 0, e[1] = 0), e;\n}\nfunction Ah(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e;\n}\nfunction ph(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r + n[4], e[1] = n[1] * s + n[3] * r + n[5], e;\n}\nfunction ga(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[3] * r + n[6], e[1] = n[1] * s + n[4] * r + n[7], e;\n}\nfunction Aa(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[4] * r + n[12], e[1] = n[1] * s + n[5] * r + n[13], e;\n}\n(function() {\n  const e = gh();\n  return function(t, n, s, r, i, o) {\n    let a, c;\n    for (n || (n = 2), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n)\n      e[0] = t[a], e[1] = t[a + 1], i(e, e, o), t[a] = e[0], t[a + 1] = e[1];\n    return t;\n  };\n})();\nfunction pa(e, t, n) {\n  const s = t[0], r = t[1], i = n[3] * s + n[7] * r || 1;\n  return e[0] = (n[0] * s + n[4] * r) / i, e[1] = (n[1] * s + n[5] * r) / i, e;\n}\nfunction ya(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = n[3] * s + n[7] * r + n[11] * i || 1;\n  return e[0] = (n[0] * s + n[4] * r + n[8] * i) / o, e[1] = (n[1] * s + n[5] * r + n[9] * i) / o, e[2] = (n[2] * s + n[6] * r + n[10] * i) / o, e;\n}\nfunction yh(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e[2] = t[2], e;\n}\nfunction Bh(e, t, n) {\n  const s = t[0], r = t[1];\n  return e[0] = n[0] * s + n[2] * r, e[1] = n[1] * s + n[3] * r, e[2] = t[2], e[3] = t[3], e;\n}\nfunction Ba(e, t, n) {\n  const s = t[0], r = t[1], i = t[2];\n  return e[0] = n[0] * s + n[3] * r + n[6] * i, e[1] = n[1] * s + n[4] * r + n[7] * i, e[2] = n[2] * s + n[5] * r + n[8] * i, e[3] = t[3], e;\n}\nclass Wn extends Br {\n  constructor(t = 0, n = 0) {\n    super(2), ee(t) && arguments.length === 1 ? this.copy(t) : (Z.debug && (U(t), U(n)), this[0] = t, this[1] = n);\n  }\n  set(t, n) {\n    return this[0] = t, this[1] = n, this.check();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this.check();\n  }\n  fromObject(t) {\n    return Z.debug && (U(t.x), U(t.y)), this[0] = t.x, this[1] = t.y, this.check();\n  }\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t;\n  }\n  get ELEMENTS() {\n    return 2;\n  }\n  horizontalAngle() {\n    return Math.atan2(this.y, this.x);\n  }\n  verticalAngle() {\n    return Math.atan2(this.x, this.y);\n  }\n  transform(t) {\n    return this.transformAsPoint(t);\n  }\n  transformAsPoint(t) {\n    return Aa(this, this, t), this.check();\n  }\n  transformAsVector(t) {\n    return pa(this, this, t), this.check();\n  }\n  transformByMatrix3(t) {\n    return ga(this, this, t), this.check();\n  }\n  transformByMatrix2x3(t) {\n    return ph(this, this, t), this.check();\n  }\n  transformByMatrix2(t) {\n    return Ah(this, this, t), this.check();\n  }\n}\nfunction Ca() {\n  const e = new It(3);\n  return It != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e;\n}\nfunction Ea(e) {\n  const t = e[0], n = e[1], s = e[2];\n  return Math.sqrt(t * t + n * n + s * s);\n}\nfunction hi(e, t, n) {\n  const s = new It(3);\n  return s[0] = e, s[1] = t, s[2] = n, s;\n}\nfunction Ch(e, t) {\n  const n = t[0], s = t[1], r = t[2];\n  let i = n * n + s * s + r * r;\n  return i > 0 && (i = 1 / Math.sqrt(i)), e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e;\n}\nfunction Cr(e, t) {\n  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];\n}\nfunction Tn(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = n[0], a = n[1], c = n[2];\n  return e[0] = r * c - i * a, e[1] = i * o - s * c, e[2] = s * a - r * o, e;\n}\nfunction Er(e, t, n) {\n  const s = t[0], r = t[1], i = t[2];\n  let o = n[3] * s + n[7] * r + n[11] * i + n[15];\n  return o = o || 1, e[0] = (n[0] * s + n[4] * r + n[8] * i + n[12]) / o, e[1] = (n[1] * s + n[5] * r + n[9] * i + n[13]) / o, e[2] = (n[2] * s + n[6] * r + n[10] * i + n[14]) / o, e;\n}\nfunction Ta(e, t, n) {\n  const s = t[0], r = t[1], i = t[2];\n  return e[0] = s * n[0] + r * n[3] + i * n[6], e[1] = s * n[1] + r * n[4] + i * n[7], e[2] = s * n[2] + r * n[5] + i * n[8], e;\n}\nfunction ba(e, t, n) {\n  const s = n[0], r = n[1], i = n[2], o = n[3], a = t[0], c = t[1], u = t[2];\n  let l = r * u - i * c, h = i * a - s * u, f = s * c - r * a, d = r * f - i * h, m = i * l - s * f, g = s * h - r * l;\n  const y = o * 2;\n  return l *= y, h *= y, f *= y, d *= 2, m *= 2, g *= 2, e[0] = a + l + d, e[1] = c + h + m, e[2] = u + f + g, e;\n}\nfunction Eh(e, t, n, s) {\n  const r = [], i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[0], i[1] = r[1] * Math.cos(s) - r[2] * Math.sin(s), i[2] = r[1] * Math.sin(s) + r[2] * Math.cos(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\nfunction Th(e, t, n, s) {\n  const r = [], i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[2] * Math.sin(s) + r[0] * Math.cos(s), i[1] = r[1], i[2] = r[2] * Math.cos(s) - r[0] * Math.sin(s), e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\nfunction bh(e, t, n, s) {\n  const r = [], i = [];\n  return r[0] = t[0] - n[0], r[1] = t[1] - n[1], r[2] = t[2] - n[2], i[0] = r[0] * Math.cos(s) - r[1] * Math.sin(s), i[1] = r[0] * Math.sin(s) + r[1] * Math.cos(s), i[2] = r[2], e[0] = i[0] + n[0], e[1] = i[1] + n[1], e[2] = i[2] + n[2], e;\n}\nfunction _h(e, t) {\n  const n = e[0], s = e[1], r = e[2], i = t[0], o = t[1], a = t[2], c = Math.sqrt((n * n + s * s + r * r) * (i * i + o * o + a * a)), u = c && Cr(e, t) / c;\n  return Math.acos(Math.min(Math.max(u, -1), 1));\n}\nconst wh = Ea;\n(function() {\n  const e = Ca();\n  return function(t, n, s, r, i, o) {\n    let a, c;\n    for (n || (n = 3), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n)\n      e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], i(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2];\n    return t;\n  };\n})();\nconst fs = [0, 0, 0];\nlet tn;\nclass A extends Br {\n  static get ZERO() {\n    return tn || (tn = new A(0, 0, 0), Object.freeze(tn)), tn;\n  }\n  constructor(t = 0, n = 0, s = 0) {\n    super(-0, -0, -0), arguments.length === 1 && ee(t) ? this.copy(t) : (Z.debug && (U(t), U(n), U(s)), this[0] = t, this[1] = n, this[2] = s);\n  }\n  set(t, n, s) {\n    return this[0] = t, this[1] = n, this[2] = s, this.check();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this.check();\n  }\n  fromObject(t) {\n    return Z.debug && (U(t.x), U(t.y), U(t.z)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this.check();\n  }\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t.z = this[2], t;\n  }\n  get ELEMENTS() {\n    return 3;\n  }\n  get z() {\n    return this[2];\n  }\n  set z(t) {\n    this[2] = U(t);\n  }\n  angle(t) {\n    return _h(this, t);\n  }\n  cross(t) {\n    return Tn(this, this, t), this.check();\n  }\n  rotateX({\n    radians: t,\n    origin: n = fs\n  }) {\n    return Eh(this, this, n, t), this.check();\n  }\n  rotateY({\n    radians: t,\n    origin: n = fs\n  }) {\n    return Th(this, this, n, t), this.check();\n  }\n  rotateZ({\n    radians: t,\n    origin: n = fs\n  }) {\n    return bh(this, this, n, t), this.check();\n  }\n  transform(t) {\n    return this.transformAsPoint(t);\n  }\n  transformAsPoint(t) {\n    return Er(this, this, t), this.check();\n  }\n  transformAsVector(t) {\n    return ya(this, this, t), this.check();\n  }\n  transformByMatrix3(t) {\n    return Ta(this, this, t), this.check();\n  }\n  transformByMatrix2(t) {\n    return yh(this, this, t), this.check();\n  }\n  transformByQuaternion(t) {\n    return ba(this, this, t), this.check();\n  }\n}\nlet en;\nclass Tr extends Br {\n  static get ZERO() {\n    return en || (en = new Tr(0, 0, 0, 0), Object.freeze(en)), en;\n  }\n  constructor(t = 0, n = 0, s = 0, r = 0) {\n    super(-0, -0, -0, -0), ee(t) && arguments.length === 1 ? this.copy(t) : (Z.debug && (U(t), U(n), U(s), U(r)), this[0] = t, this[1] = n, this[2] = s, this[3] = r);\n  }\n  set(t, n, s, r) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this.check();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check();\n  }\n  fromObject(t) {\n    return Z.debug && (U(t.x), U(t.y), U(t.z), U(t.w)), this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this;\n  }\n  toObject(t) {\n    return t.x = this[0], t.y = this[1], t.z = this[2], t.w = this[3], t;\n  }\n  get ELEMENTS() {\n    return 4;\n  }\n  get z() {\n    return this[2];\n  }\n  set z(t) {\n    this[2] = U(t);\n  }\n  get w() {\n    return this[3];\n  }\n  set w(t) {\n    this[3] = U(t);\n  }\n  transform(t) {\n    return Er(this, this, t), this.check();\n  }\n  transformByMatrix3(t) {\n    return Ba(this, this, t), this.check();\n  }\n  transformByMatrix2(t) {\n    return Bh(this, this, t), this.check();\n  }\n  transformByQuaternion(t) {\n    return ba(this, this, t), this.check();\n  }\n  applyMatrix4(t) {\n    return t.transform(this, this), this;\n  }\n}\nclass _a extends yr {\n  toString() {\n    let t = \"[\";\n    if (Z.printRowMajor) {\n      t += \"row-major:\";\n      for (let n = 0; n < this.RANK; ++n)\n        for (let s = 0; s < this.RANK; ++s)\n          t += \" \".concat(this[s * this.RANK + n]);\n    } else {\n      t += \"column-major:\";\n      for (let n = 0; n < this.ELEMENTS; ++n)\n        t += \" \".concat(this[n]);\n    }\n    return t += \"]\", t;\n  }\n  getElementIndex(t, n) {\n    return n * this.RANK + t;\n  }\n  getElement(t, n) {\n    return this[n * this.RANK + t];\n  }\n  setElement(t, n, s) {\n    return this[n * this.RANK + t] = U(s), this;\n  }\n  getColumn(t, n = new Array(this.RANK).fill(-0)) {\n    const s = t * this.RANK;\n    for (let r = 0; r < this.RANK; ++r)\n      n[r] = this[s + r];\n    return n;\n  }\n  setColumn(t, n) {\n    const s = t * this.RANK;\n    for (let r = 0; r < this.RANK; ++r)\n      this[s + r] = n[r];\n    return this;\n  }\n}\nfunction Rh() {\n  const e = new It(9);\n  return It != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e;\n}\nfunction Mh(e, t) {\n  if (e === t) {\n    const n = t[1], s = t[2], r = t[5];\n    e[1] = t[3], e[2] = t[6], e[3] = n, e[5] = t[7], e[6] = s, e[7] = r;\n  } else\n    e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];\n  return e;\n}\nfunction Sh(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = t[4], a = t[5], c = t[6], u = t[7], l = t[8], h = l * o - a * u, f = -l * i + a * c, d = u * i - o * c;\n  let m = n * h + s * f + r * d;\n  return m ? (m = 1 / m, e[0] = h * m, e[1] = (-l * s + r * u) * m, e[2] = (a * s - r * o) * m, e[3] = f * m, e[4] = (l * n - r * c) * m, e[5] = (-a * n + r * i) * m, e[6] = d * m, e[7] = (-u * n + s * c) * m, e[8] = (o * n - s * i) * m, e) : null;\n}\nfunction Ih(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3], i = e[4], o = e[5], a = e[6], c = e[7], u = e[8];\n  return t * (u * i - o * c) + n * (-u * r + o * a) + s * (c * r - i * a);\n}\nfunction fi(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = n[0], d = n[1], m = n[2], g = n[3], y = n[4], E = n[5], R = n[6], B = n[7], C = n[8];\n  return e[0] = f * s + d * o + m * u, e[1] = f * r + d * a + m * l, e[2] = f * i + d * c + m * h, e[3] = g * s + y * o + E * u, e[4] = g * r + y * a + E * l, e[5] = g * i + y * c + E * h, e[6] = R * s + B * o + C * u, e[7] = R * r + B * a + C * l, e[8] = R * i + B * c + C * h, e;\n}\nfunction xh(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = n[0], d = n[1];\n  return e[0] = s, e[1] = r, e[2] = i, e[3] = o, e[4] = a, e[5] = c, e[6] = f * s + d * o + u, e[7] = f * r + d * a + l, e[8] = f * i + d * c + h, e;\n}\nfunction vh(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = Math.sin(n), d = Math.cos(n);\n  return e[0] = d * s + f * o, e[1] = d * r + f * a, e[2] = d * i + f * c, e[3] = d * o - f * s, e[4] = d * a - f * r, e[5] = d * c - f * i, e[6] = u, e[7] = l, e[8] = h, e;\n}\nfunction di(e, t, n) {\n  const s = n[0], r = n[1];\n  return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = r * t[3], e[4] = r * t[4], e[5] = r * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;\n}\nfunction Oh(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = n + n, a = s + s, c = r + r, u = n * o, l = s * o, h = s * a, f = r * o, d = r * a, m = r * c, g = i * o, y = i * a, E = i * c;\n  return e[0] = 1 - h - m, e[3] = l - E, e[6] = f + y, e[1] = l + E, e[4] = 1 - u - m, e[7] = d - g, e[2] = f - y, e[5] = d + g, e[8] = 1 - u - h, e;\n}\nvar ks;\n(function(e) {\n  e[e.COL0ROW0 = 0] = \"COL0ROW0\", e[e.COL0ROW1 = 1] = \"COL0ROW1\", e[e.COL0ROW2 = 2] = \"COL0ROW2\", e[e.COL1ROW0 = 3] = \"COL1ROW0\", e[e.COL1ROW1 = 4] = \"COL1ROW1\", e[e.COL1ROW2 = 5] = \"COL1ROW2\", e[e.COL2ROW0 = 6] = \"COL2ROW0\", e[e.COL2ROW1 = 7] = \"COL2ROW1\", e[e.COL2ROW2 = 8] = \"COL2ROW2\";\n})(ks || (ks = {}));\nconst Fh = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);\nclass W extends _a {\n  static get IDENTITY() {\n    return Lh();\n  }\n  static get ZERO() {\n    return Dh();\n  }\n  get ELEMENTS() {\n    return 9;\n  }\n  get RANK() {\n    return 3;\n  }\n  get INDICES() {\n    return ks;\n  }\n  constructor(t, ...n) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : n.length > 0 ? this.copy([t, ...n]) : this.identity();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this.check();\n  }\n  identity() {\n    return this.copy(Fh);\n  }\n  fromObject(t) {\n    return this.check();\n  }\n  fromQuaternion(t) {\n    return Oh(this, t), this.check();\n  }\n  set(t, n, s, r, i, o, a, c, u) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = u, this.check();\n  }\n  setRowMajor(t, n, s, r, i, o, a, c, u) {\n    return this[0] = t, this[1] = r, this[2] = a, this[3] = n, this[4] = i, this[5] = c, this[6] = s, this[7] = o, this[8] = u, this.check();\n  }\n  determinant() {\n    return Ih(this);\n  }\n  transpose() {\n    return Mh(this, this), this.check();\n  }\n  invert() {\n    return Sh(this, this), this.check();\n  }\n  multiplyLeft(t) {\n    return fi(this, t, this), this.check();\n  }\n  multiplyRight(t) {\n    return fi(this, this, t), this.check();\n  }\n  rotate(t) {\n    return vh(this, this, t), this.check();\n  }\n  scale(t) {\n    return Array.isArray(t) ? di(this, this, t) : di(this, this, [t, t]), this.check();\n  }\n  translate(t) {\n    return xh(this, this, t), this.check();\n  }\n  transform(t, n) {\n    let s;\n    switch (t.length) {\n      case 2:\n        s = ga(n || [-0, -0], t, this);\n        break;\n      case 3:\n        s = Ta(n || [-0, -0, -0], t, this);\n        break;\n      case 4:\n        s = Ba(n || [-0, -0, -0, -0], t, this);\n        break;\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n    return Oe(s, t.length), s;\n  }\n  transformVector(t, n) {\n    return this.transform(t, n);\n  }\n  transformVector2(t, n) {\n    return this.transform(t, n);\n  }\n  transformVector3(t, n) {\n    return this.transform(t, n);\n  }\n}\nlet nn, sn = null;\nfunction Dh() {\n  return nn || (nn = new W([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(nn)), nn;\n}\nfunction Lh() {\n  return sn || (sn = new W(), Object.freeze(sn)), sn;\n}\nfunction Ph(e) {\n  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n}\nfunction Gh(e, t) {\n  if (e === t) {\n    const n = t[1], s = t[2], r = t[3], i = t[6], o = t[7], a = t[11];\n    e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = n, e[6] = t[9], e[7] = t[13], e[8] = s, e[9] = i, e[11] = t[14], e[12] = r, e[13] = o, e[14] = a;\n  } else\n    e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];\n  return e;\n}\nfunction Nh(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = t[4], a = t[5], c = t[6], u = t[7], l = t[8], h = t[9], f = t[10], d = t[11], m = t[12], g = t[13], y = t[14], E = t[15], R = n * a - s * o, B = n * c - r * o, C = n * u - i * o, M = s * c - r * a, b = s * u - i * a, O = r * u - i * c, F = l * g - h * m, v = l * y - f * m, L = l * E - d * m, k = h * y - f * g, X = h * E - d * g, Q = f * E - d * y;\n  let P = R * Q - B * X + C * k + M * L - b * v + O * F;\n  return P ? (P = 1 / P, e[0] = (a * Q - c * X + u * k) * P, e[1] = (r * X - s * Q - i * k) * P, e[2] = (g * O - y * b + E * M) * P, e[3] = (f * b - h * O - d * M) * P, e[4] = (c * L - o * Q - u * v) * P, e[5] = (n * Q - r * L + i * v) * P, e[6] = (y * C - m * O - E * B) * P, e[7] = (l * O - f * C + d * B) * P, e[8] = (o * X - a * L + u * F) * P, e[9] = (s * L - n * X - i * F) * P, e[10] = (m * b - g * C + E * R) * P, e[11] = (h * C - l * b - d * R) * P, e[12] = (a * v - o * k - c * F) * P, e[13] = (n * k - s * v + r * F) * P, e[14] = (g * B - m * M - y * R) * P, e[15] = (l * M - h * B + f * R) * P, e) : null;\n}\nfunction Uh(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3], i = e[4], o = e[5], a = e[6], c = e[7], u = e[8], l = e[9], h = e[10], f = e[11], d = e[12], m = e[13], g = e[14], y = e[15], E = t * o - n * i, R = t * a - s * i, B = n * a - s * o, C = u * m - l * d, M = u * g - h * d, b = l * g - h * m, O = t * b - n * M + s * C, F = i * b - o * M + a * C, v = u * B - l * R + h * E, L = d * B - m * R + g * E;\n  return c * O - r * F + y * v - f * L;\n}\nfunction mi(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = t[4], c = t[5], u = t[6], l = t[7], h = t[8], f = t[9], d = t[10], m = t[11], g = t[12], y = t[13], E = t[14], R = t[15];\n  let B = n[0], C = n[1], M = n[2], b = n[3];\n  return e[0] = B * s + C * a + M * h + b * g, e[1] = B * r + C * c + M * f + b * y, e[2] = B * i + C * u + M * d + b * E, e[3] = B * o + C * l + M * m + b * R, B = n[4], C = n[5], M = n[6], b = n[7], e[4] = B * s + C * a + M * h + b * g, e[5] = B * r + C * c + M * f + b * y, e[6] = B * i + C * u + M * d + b * E, e[7] = B * o + C * l + M * m + b * R, B = n[8], C = n[9], M = n[10], b = n[11], e[8] = B * s + C * a + M * h + b * g, e[9] = B * r + C * c + M * f + b * y, e[10] = B * i + C * u + M * d + b * E, e[11] = B * o + C * l + M * m + b * R, B = n[12], C = n[13], M = n[14], b = n[15], e[12] = B * s + C * a + M * h + b * g, e[13] = B * r + C * c + M * f + b * y, e[14] = B * i + C * u + M * d + b * E, e[15] = B * o + C * l + M * m + b * R, e;\n}\nfunction Hh(e, t, n) {\n  const s = n[0], r = n[1], i = n[2];\n  let o, a, c, u, l, h, f, d, m, g, y, E;\n  return t === e ? (e[12] = t[0] * s + t[4] * r + t[8] * i + t[12], e[13] = t[1] * s + t[5] * r + t[9] * i + t[13], e[14] = t[2] * s + t[6] * r + t[10] * i + t[14], e[15] = t[3] * s + t[7] * r + t[11] * i + t[15]) : (o = t[0], a = t[1], c = t[2], u = t[3], l = t[4], h = t[5], f = t[6], d = t[7], m = t[8], g = t[9], y = t[10], E = t[11], e[0] = o, e[1] = a, e[2] = c, e[3] = u, e[4] = l, e[5] = h, e[6] = f, e[7] = d, e[8] = m, e[9] = g, e[10] = y, e[11] = E, e[12] = o * s + l * r + m * i + t[12], e[13] = a * s + h * r + g * i + t[13], e[14] = c * s + f * r + y * i + t[14], e[15] = u * s + d * r + E * i + t[15]), e;\n}\nfunction Jh(e, t, n) {\n  const s = n[0], r = n[1], i = n[2];\n  return e[0] = t[0] * s, e[1] = t[1] * s, e[2] = t[2] * s, e[3] = t[3] * s, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * i, e[9] = t[9] * i, e[10] = t[10] * i, e[11] = t[11] * i, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n}\nfunction Vh(e, t, n, s) {\n  let r = s[0], i = s[1], o = s[2], a = Math.sqrt(r * r + i * i + o * o), c, u, l, h, f, d, m, g, y, E, R, B, C, M, b, O, F, v, L, k, X, Q, P, at;\n  return a < Fe ? null : (a = 1 / a, r *= a, i *= a, o *= a, u = Math.sin(n), c = Math.cos(n), l = 1 - c, h = t[0], f = t[1], d = t[2], m = t[3], g = t[4], y = t[5], E = t[6], R = t[7], B = t[8], C = t[9], M = t[10], b = t[11], O = r * r * l + c, F = i * r * l + o * u, v = o * r * l - i * u, L = r * i * l - o * u, k = i * i * l + c, X = o * i * l + r * u, Q = r * o * l + i * u, P = i * o * l - r * u, at = o * o * l + c, e[0] = h * O + g * F + B * v, e[1] = f * O + y * F + C * v, e[2] = d * O + E * F + M * v, e[3] = m * O + R * F + b * v, e[4] = h * L + g * k + B * X, e[5] = f * L + y * k + C * X, e[6] = d * L + E * k + M * X, e[7] = m * L + R * k + b * X, e[8] = h * Q + g * P + B * at, e[9] = f * Q + y * P + C * at, e[10] = d * Q + E * P + M * at, e[11] = m * Q + R * P + b * at, t !== e && (e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e);\n}\nfunction jh(e, t, n) {\n  const s = Math.sin(n), r = Math.cos(n), i = t[4], o = t[5], a = t[6], c = t[7], u = t[8], l = t[9], h = t[10], f = t[11];\n  return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = i * r + u * s, e[5] = o * r + l * s, e[6] = a * r + h * s, e[7] = c * r + f * s, e[8] = u * r - i * s, e[9] = l * r - o * s, e[10] = h * r - a * s, e[11] = f * r - c * s, e;\n}\nfunction kh(e, t, n) {\n  const s = Math.sin(n), r = Math.cos(n), i = t[0], o = t[1], a = t[2], c = t[3], u = t[8], l = t[9], h = t[10], f = t[11];\n  return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * r - u * s, e[1] = o * r - l * s, e[2] = a * r - h * s, e[3] = c * r - f * s, e[8] = i * s + u * r, e[9] = o * s + l * r, e[10] = a * s + h * r, e[11] = c * s + f * r, e;\n}\nfunction Kh(e, t, n) {\n  const s = Math.sin(n), r = Math.cos(n), i = t[0], o = t[1], a = t[2], c = t[3], u = t[4], l = t[5], h = t[6], f = t[7];\n  return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = i * r + u * s, e[1] = o * r + l * s, e[2] = a * r + h * s, e[3] = c * r + f * s, e[4] = u * r - i * s, e[5] = l * r - o * s, e[6] = h * r - a * s, e[7] = f * r - c * s, e;\n}\nfunction zh(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[4], o = t[5], a = t[6], c = t[8], u = t[9], l = t[10];\n  return e[0] = Math.sqrt(n * n + s * s + r * r), e[1] = Math.sqrt(i * i + o * o + a * a), e[2] = Math.sqrt(c * c + u * u + l * l), e;\n}\nfunction Wh(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = n + n, a = s + s, c = r + r, u = n * o, l = s * o, h = s * a, f = r * o, d = r * a, m = r * c, g = i * o, y = i * a, E = i * c;\n  return e[0] = 1 - h - m, e[1] = l + E, e[2] = f - y, e[3] = 0, e[4] = l - E, e[5] = 1 - u - m, e[6] = d + g, e[7] = 0, e[8] = f + y, e[9] = d - g, e[10] = 1 - u - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;\n}\nfunction Xh(e, t, n, s, r, i, o) {\n  const a = 1 / (n - t), c = 1 / (r - s), u = 1 / (i - o);\n  return e[0] = i * 2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i * 2 * c, e[6] = 0, e[7] = 0, e[8] = (n + t) * a, e[9] = (r + s) * c, e[10] = (o + i) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = o * i * 2 * u, e[15] = 0, e;\n}\nfunction Qh(e, t, n, s, r) {\n  const i = 1 / Math.tan(t / 2);\n  if (e[0] = i / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, r != null && r !== 1 / 0) {\n    const o = 1 / (s - r);\n    e[10] = (r + s) * o, e[14] = 2 * r * s * o;\n  } else\n    e[10] = -1, e[14] = -2 * s;\n  return e;\n}\nconst qh = Qh;\nfunction Yh(e, t, n, s, r, i, o) {\n  const a = 1 / (t - n), c = 1 / (s - r), u = 1 / (i - o);\n  return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + n) * a, e[13] = (r + s) * c, e[14] = (o + i) * u, e[15] = 1, e;\n}\nconst $h = Yh;\nfunction Zh(e, t, n, s) {\n  let r, i, o, a, c, u, l, h, f, d;\n  const m = t[0], g = t[1], y = t[2], E = s[0], R = s[1], B = s[2], C = n[0], M = n[1], b = n[2];\n  return Math.abs(m - C) < Fe && Math.abs(g - M) < Fe && Math.abs(y - b) < Fe ? Ph(e) : (h = m - C, f = g - M, d = y - b, r = 1 / Math.sqrt(h * h + f * f + d * d), h *= r, f *= r, d *= r, i = R * d - B * f, o = B * h - E * d, a = E * f - R * h, r = Math.sqrt(i * i + o * o + a * a), r ? (r = 1 / r, i *= r, o *= r, a *= r) : (i = 0, o = 0, a = 0), c = f * a - d * o, u = d * i - h * a, l = h * o - f * i, r = Math.sqrt(c * c + u * u + l * l), r ? (r = 1 / r, c *= r, u *= r, l *= r) : (c = 0, u = 0, l = 0), e[0] = i, e[1] = c, e[2] = h, e[3] = 0, e[4] = o, e[5] = u, e[6] = f, e[7] = 0, e[8] = a, e[9] = l, e[10] = d, e[11] = 0, e[12] = -(i * m + o * g + a * y), e[13] = -(c * m + u * g + l * y), e[14] = -(h * m + f * g + d * y), e[15] = 1, e);\n}\nfunction tf() {\n  const e = new It(4);\n  return It != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0), e;\n}\nfunction ef(e, t, n) {\n  return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e[3] = t[3] + n[3], e;\n}\nfunction nf(e, t, n) {\n  return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e;\n}\nfunction sf(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3];\n  return Math.sqrt(t * t + n * n + s * s + r * r);\n}\nfunction rf(e) {\n  const t = e[0], n = e[1], s = e[2], r = e[3];\n  return t * t + n * n + s * s + r * r;\n}\nfunction of(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3];\n  let o = n * n + s * s + r * r + i * i;\n  return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = n * o, e[1] = s * o, e[2] = r * o, e[3] = i * o, e;\n}\nfunction af(e, t) {\n  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];\n}\nfunction cf(e, t, n, s) {\n  const r = t[0], i = t[1], o = t[2], a = t[3];\n  return e[0] = r + s * (n[0] - r), e[1] = i + s * (n[1] - i), e[2] = o + s * (n[2] - o), e[3] = a + s * (n[3] - a), e;\n}\nfunction uf(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3];\n  return e[0] = n[0] * s + n[4] * r + n[8] * i + n[12] * o, e[1] = n[1] * s + n[5] * r + n[9] * i + n[13] * o, e[2] = n[2] * s + n[6] * r + n[10] * i + n[14] * o, e[3] = n[3] * s + n[7] * r + n[11] * i + n[15] * o, e;\n}\nfunction lf(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = n[0], a = n[1], c = n[2], u = n[3], l = u * s + a * i - c * r, h = u * r + c * s - o * i, f = u * i + o * r - a * s, d = -o * s - a * r - c * i;\n  return e[0] = l * u + d * -o + h * -c - f * -a, e[1] = h * u + d * -a + f * -o - l * -c, e[2] = f * u + d * -c + l * -a - h * -o, e[3] = t[3], e;\n}\n(function() {\n  const e = tf();\n  return function(t, n, s, r, i, o) {\n    let a, c;\n    for (n || (n = 4), s || (s = 0), r ? c = Math.min(r * n + s, t.length) : c = t.length, a = s; a < c; a += n)\n      e[0] = t[a], e[1] = t[a + 1], e[2] = t[a + 2], e[3] = t[a + 3], i(e, e, o), t[a] = e[0], t[a + 1] = e[1], t[a + 2] = e[2], t[a + 3] = e[3];\n    return t;\n  };\n})();\nvar Ks;\n(function(e) {\n  e[e.COL0ROW0 = 0] = \"COL0ROW0\", e[e.COL0ROW1 = 1] = \"COL0ROW1\", e[e.COL0ROW2 = 2] = \"COL0ROW2\", e[e.COL0ROW3 = 3] = \"COL0ROW3\", e[e.COL1ROW0 = 4] = \"COL1ROW0\", e[e.COL1ROW1 = 5] = \"COL1ROW1\", e[e.COL1ROW2 = 6] = \"COL1ROW2\", e[e.COL1ROW3 = 7] = \"COL1ROW3\", e[e.COL2ROW0 = 8] = \"COL2ROW0\", e[e.COL2ROW1 = 9] = \"COL2ROW1\", e[e.COL2ROW2 = 10] = \"COL2ROW2\", e[e.COL2ROW3 = 11] = \"COL2ROW3\", e[e.COL3ROW0 = 12] = \"COL3ROW0\", e[e.COL3ROW1 = 13] = \"COL3ROW1\", e[e.COL3ROW2 = 14] = \"COL3ROW2\", e[e.COL3ROW3 = 15] = \"COL3ROW3\";\n})(Ks || (Ks = {}));\nconst hf = 45 * Math.PI / 180, ff = 1, ds = 0.1, ms = 500, df = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\nclass V extends _a {\n  static get IDENTITY() {\n    return gf();\n  }\n  static get ZERO() {\n    return mf();\n  }\n  get ELEMENTS() {\n    return 16;\n  }\n  get RANK() {\n    return 4;\n  }\n  get INDICES() {\n    return Ks;\n  }\n  constructor(t) {\n    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(t) ? this.copy(t) : this.identity();\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this[4] = t[4], this[5] = t[5], this[6] = t[6], this[7] = t[7], this[8] = t[8], this[9] = t[9], this[10] = t[10], this[11] = t[11], this[12] = t[12], this[13] = t[13], this[14] = t[14], this[15] = t[15], this.check();\n  }\n  set(t, n, s, r, i, o, a, c, u, l, h, f, d, m, g, y) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this[4] = i, this[5] = o, this[6] = a, this[7] = c, this[8] = u, this[9] = l, this[10] = h, this[11] = f, this[12] = d, this[13] = m, this[14] = g, this[15] = y, this.check();\n  }\n  setRowMajor(t, n, s, r, i, o, a, c, u, l, h, f, d, m, g, y) {\n    return this[0] = t, this[1] = i, this[2] = u, this[3] = d, this[4] = n, this[5] = o, this[6] = l, this[7] = m, this[8] = s, this[9] = a, this[10] = h, this[11] = g, this[12] = r, this[13] = c, this[14] = f, this[15] = y, this.check();\n  }\n  toRowMajor(t) {\n    return t[0] = this[0], t[1] = this[4], t[2] = this[8], t[3] = this[12], t[4] = this[1], t[5] = this[5], t[6] = this[9], t[7] = this[13], t[8] = this[2], t[9] = this[6], t[10] = this[10], t[11] = this[14], t[12] = this[3], t[13] = this[7], t[14] = this[11], t[15] = this[15], t;\n  }\n  identity() {\n    return this.copy(df);\n  }\n  fromObject(t) {\n    return this.check();\n  }\n  fromQuaternion(t) {\n    return Wh(this, t), this.check();\n  }\n  frustum(t) {\n    const {\n      left: n,\n      right: s,\n      bottom: r,\n      top: i,\n      near: o = ds,\n      far: a = ms\n    } = t;\n    return a === 1 / 0 ? Af(this, n, s, r, i, o) : Xh(this, n, s, r, i, o, a), this.check();\n  }\n  lookAt(t) {\n    const {\n      eye: n,\n      center: s = [0, 0, 0],\n      up: r = [0, 1, 0]\n    } = t;\n    return Zh(this, n, s, r), this.check();\n  }\n  ortho(t) {\n    const {\n      left: n,\n      right: s,\n      bottom: r,\n      top: i,\n      near: o = ds,\n      far: a = ms\n    } = t;\n    return $h(this, n, s, r, i, o, a), this.check();\n  }\n  orthographic(t) {\n    const {\n      fovy: n = hf,\n      aspect: s = ff,\n      focalDistance: r = 1,\n      near: i = ds,\n      far: o = ms\n    } = t;\n    gi(n);\n    const a = n / 2, c = r * Math.tan(a), u = c * s;\n    return this.ortho({\n      left: -u,\n      right: u,\n      bottom: -c,\n      top: c,\n      near: i,\n      far: o\n    });\n  }\n  perspective(t) {\n    const {\n      fovy: n = 45 * Math.PI / 180,\n      aspect: s = 1,\n      near: r = 0.1,\n      far: i = 500\n    } = t;\n    return gi(n), qh(this, n, s, r, i), this.check();\n  }\n  determinant() {\n    return Uh(this);\n  }\n  getScale(t = [-0, -0, -0]) {\n    return t[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), t[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), t[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), t;\n  }\n  getTranslation(t = [-0, -0, -0]) {\n    return t[0] = this[12], t[1] = this[13], t[2] = this[14], t;\n  }\n  getRotation(t, n) {\n    t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], n = n || [-0, -0, -0];\n    const s = this.getScale(n), r = 1 / s[0], i = 1 / s[1], o = 1 / s[2];\n    return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = 0, t[4] = this[4] * r, t[5] = this[5] * i, t[6] = this[6] * o, t[7] = 0, t[8] = this[8] * r, t[9] = this[9] * i, t[10] = this[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n  }\n  getRotationMatrix3(t, n) {\n    t = t || [-0, -0, -0, -0, -0, -0, -0, -0, -0], n = n || [-0, -0, -0];\n    const s = this.getScale(n), r = 1 / s[0], i = 1 / s[1], o = 1 / s[2];\n    return t[0] = this[0] * r, t[1] = this[1] * i, t[2] = this[2] * o, t[3] = this[4] * r, t[4] = this[5] * i, t[5] = this[6] * o, t[6] = this[8] * r, t[7] = this[9] * i, t[8] = this[10] * o, t;\n  }\n  transpose() {\n    return Gh(this, this), this.check();\n  }\n  invert() {\n    return Nh(this, this), this.check();\n  }\n  multiplyLeft(t) {\n    return mi(this, t, this), this.check();\n  }\n  multiplyRight(t) {\n    return mi(this, this, t), this.check();\n  }\n  rotateX(t) {\n    return jh(this, this, t), this.check();\n  }\n  rotateY(t) {\n    return kh(this, this, t), this.check();\n  }\n  rotateZ(t) {\n    return Kh(this, this, t), this.check();\n  }\n  rotateXYZ(t) {\n    return this.rotateX(t[0]).rotateY(t[1]).rotateZ(t[2]);\n  }\n  rotateAxis(t, n) {\n    return Vh(this, this, t, n), this.check();\n  }\n  scale(t) {\n    return Jh(this, this, Array.isArray(t) ? t : [t, t, t]), this.check();\n  }\n  translate(t) {\n    return Hh(this, this, t), this.check();\n  }\n  transform(t, n) {\n    return t.length === 4 ? (n = uf(n || [-0, -0, -0, -0], t, this), Oe(n, 4), n) : this.transformAsPoint(t, n);\n  }\n  transformAsPoint(t, n) {\n    const {\n      length: s\n    } = t;\n    let r;\n    switch (s) {\n      case 2:\n        r = Aa(n || [-0, -0], t, this);\n        break;\n      case 3:\n        r = Er(n || [-0, -0, -0], t, this);\n        break;\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n    return Oe(r, t.length), r;\n  }\n  transformAsVector(t, n) {\n    let s;\n    switch (t.length) {\n      case 2:\n        s = pa(n || [-0, -0], t, this);\n        break;\n      case 3:\n        s = ya(n || [-0, -0, -0], t, this);\n        break;\n      default:\n        throw new Error(\"Illegal vector\");\n    }\n    return Oe(s, t.length), s;\n  }\n  transformPoint(t, n) {\n    return this.transformAsPoint(t, n);\n  }\n  transformVector(t, n) {\n    return this.transformAsPoint(t, n);\n  }\n  transformDirection(t, n) {\n    return this.transformAsVector(t, n);\n  }\n  makeRotationX(t) {\n    return this.identity().rotateX(t);\n  }\n  makeTranslation(t, n, s) {\n    return this.identity().translate([t, n, s]);\n  }\n}\nlet rn, on;\nfunction mf() {\n  return rn || (rn = new V([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(rn)), rn;\n}\nfunction gf() {\n  return on || (on = new V(), Object.freeze(on)), on;\n}\nfunction gi(e) {\n  if (e > Math.PI * 2)\n    throw Error(\"expected radians\");\n}\nfunction Af(e, t, n, s, r, i) {\n  const o = 2 * i / (n - t), a = 2 * i / (r - s), c = (n + t) / (n - t), u = (r + s) / (r - s), l = -1, h = -1, f = -2 * i;\n  return e[0] = o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = a, e[6] = 0, e[7] = 0, e[8] = c, e[9] = u, e[10] = l, e[11] = h, e[12] = 0, e[13] = 0, e[14] = f, e[15] = 0, e;\n}\nfunction Ai() {\n  const e = new It(4);\n  return It != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e;\n}\nfunction pf(e) {\n  return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;\n}\nfunction wa(e, t, n) {\n  n = n * 0.5;\n  const s = Math.sin(n);\n  return e[0] = s * t[0], e[1] = s * t[1], e[2] = s * t[2], e[3] = Math.cos(n), e;\n}\nfunction pi(e, t, n) {\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = n[0], c = n[1], u = n[2], l = n[3];\n  return e[0] = s * l + o * a + r * u - i * c, e[1] = r * l + o * c + i * a - s * u, e[2] = i * l + o * u + s * c - r * a, e[3] = o * l - s * a - r * c - i * u, e;\n}\nfunction yf(e, t, n) {\n  n *= 0.5;\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = Math.sin(n), c = Math.cos(n);\n  return e[0] = s * c + o * a, e[1] = r * c + i * a, e[2] = i * c - r * a, e[3] = o * c - s * a, e;\n}\nfunction Bf(e, t, n) {\n  n *= 0.5;\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = Math.sin(n), c = Math.cos(n);\n  return e[0] = s * c - i * a, e[1] = r * c + o * a, e[2] = i * c + s * a, e[3] = o * c - r * a, e;\n}\nfunction Cf(e, t, n) {\n  n *= 0.5;\n  const s = t[0], r = t[1], i = t[2], o = t[3], a = Math.sin(n), c = Math.cos(n);\n  return e[0] = s * c + r * a, e[1] = r * c - s * a, e[2] = i * c + o * a, e[3] = o * c - i * a, e;\n}\nfunction Ef(e, t) {\n  const n = t[0], s = t[1], r = t[2];\n  return e[0] = n, e[1] = s, e[2] = r, e[3] = Math.sqrt(Math.abs(1 - n * n - s * s - r * r)), e;\n}\nfunction bn(e, t, n, s) {\n  const r = t[0], i = t[1], o = t[2], a = t[3];\n  let c = n[0], u = n[1], l = n[2], h = n[3], f, d, m, g, y;\n  return f = r * c + i * u + o * l + a * h, f < 0 && (f = -f, c = -c, u = -u, l = -l, h = -h), 1 - f > Fe ? (d = Math.acos(f), y = Math.sin(d), m = Math.sin((1 - s) * d) / y, g = Math.sin(s * d) / y) : (m = 1 - s, g = s), e[0] = m * r + g * c, e[1] = m * i + g * u, e[2] = m * o + g * l, e[3] = m * a + g * h, e;\n}\nfunction Tf(e, t) {\n  const n = t[0], s = t[1], r = t[2], i = t[3], o = n * n + s * s + r * r + i * i, a = o ? 1 / o : 0;\n  return e[0] = -n * a, e[1] = -s * a, e[2] = -r * a, e[3] = i * a, e;\n}\nfunction bf(e, t) {\n  return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e;\n}\nfunction Ra(e, t) {\n  const n = t[0] + t[4] + t[8];\n  let s;\n  if (n > 0)\n    s = Math.sqrt(n + 1), e[3] = 0.5 * s, s = 0.5 / s, e[0] = (t[5] - t[7]) * s, e[1] = (t[6] - t[2]) * s, e[2] = (t[1] - t[3]) * s;\n  else {\n    let r = 0;\n    t[4] > t[0] && (r = 1), t[8] > t[r * 3 + r] && (r = 2);\n    const i = (r + 1) % 3, o = (r + 2) % 3;\n    s = Math.sqrt(t[r * 3 + r] - t[i * 3 + i] - t[o * 3 + o] + 1), e[r] = 0.5 * s, s = 0.5 / s, e[3] = (t[i * 3 + o] - t[o * 3 + i]) * s, e[i] = (t[i * 3 + r] + t[r * 3 + i]) * s, e[o] = (t[o * 3 + r] + t[r * 3 + o]) * s;\n  }\n  return e;\n}\nconst _f = ef, wf = nf, Rf = af, Mf = cf, Sf = sf, If = rf, Ma = of, xf = function() {\n  const e = Ca(), t = hi(1, 0, 0), n = hi(0, 1, 0);\n  return function(s, r, i) {\n    const o = Cr(r, i);\n    return o < -0.999999 ? (Tn(e, t, r), wh(e) < 1e-6 && Tn(e, n, r), Ch(e, e), wa(s, e, Math.PI), s) : o > 0.999999 ? (s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1, s) : (Tn(e, r, i), s[0] = e[0], s[1] = e[1], s[2] = e[2], s[3] = 1 + o, Ma(s, s));\n  };\n}();\n(function() {\n  const e = Ai(), t = Ai();\n  return function(n, s, r, i, o, a) {\n    return bn(e, s, o, a), bn(t, r, i, a), bn(n, e, t, 2 * a * (1 - a)), n;\n  };\n})();\n(function() {\n  const e = Rh();\n  return function(t, n, s, r) {\n    return e[0] = s[0], e[3] = s[1], e[6] = s[2], e[1] = r[0], e[4] = r[1], e[7] = r[2], e[2] = -n[0], e[5] = -n[1], e[8] = -n[2], Ma(t, Ra(t, e));\n  };\n})();\nconst vf = [0, 0, 0, 1];\nclass On extends yr {\n  constructor(t = 0, n = 0, s = 0, r = 1) {\n    super(-0, -0, -0, -0), Array.isArray(t) && arguments.length === 1 ? this.copy(t) : this.set(t, n, s, r);\n  }\n  copy(t) {\n    return this[0] = t[0], this[1] = t[1], this[2] = t[2], this[3] = t[3], this.check();\n  }\n  set(t, n, s, r) {\n    return this[0] = t, this[1] = n, this[2] = s, this[3] = r, this.check();\n  }\n  fromObject(t) {\n    return this[0] = t.x, this[1] = t.y, this[2] = t.z, this[3] = t.w, this.check();\n  }\n  fromMatrix3(t) {\n    return Ra(this, t), this.check();\n  }\n  fromAxisRotation(t, n) {\n    return wa(this, t, n), this.check();\n  }\n  identity() {\n    return pf(this), this.check();\n  }\n  setAxisAngle(t, n) {\n    return this.fromAxisRotation(t, n);\n  }\n  get ELEMENTS() {\n    return 4;\n  }\n  get x() {\n    return this[0];\n  }\n  set x(t) {\n    this[0] = U(t);\n  }\n  get y() {\n    return this[1];\n  }\n  set y(t) {\n    this[1] = U(t);\n  }\n  get z() {\n    return this[2];\n  }\n  set z(t) {\n    this[2] = U(t);\n  }\n  get w() {\n    return this[3];\n  }\n  set w(t) {\n    this[3] = U(t);\n  }\n  len() {\n    return Sf(this);\n  }\n  lengthSquared() {\n    return If(this);\n  }\n  dot(t) {\n    return Rf(this, t);\n  }\n  rotationTo(t, n) {\n    return xf(this, t, n), this.check();\n  }\n  add(t) {\n    return _f(this, this, t), this.check();\n  }\n  calculateW() {\n    return Ef(this, this), this.check();\n  }\n  conjugate() {\n    return bf(this, this), this.check();\n  }\n  invert() {\n    return Tf(this, this), this.check();\n  }\n  lerp(t, n, s) {\n    return s === void 0 ? this.lerp(this, t, n) : (Mf(this, t, n, s), this.check());\n  }\n  multiplyRight(t) {\n    return pi(this, this, t), this.check();\n  }\n  multiplyLeft(t) {\n    return pi(this, t, this), this.check();\n  }\n  normalize() {\n    const t = this.len(), n = t > 0 ? 1 / t : 0;\n    return this[0] = this[0] * n, this[1] = this[1] * n, this[2] = this[2] * n, this[3] = this[3] * n, t === 0 && (this[3] = 1), this.check();\n  }\n  rotateX(t) {\n    return yf(this, this, t), this.check();\n  }\n  rotateY(t) {\n    return Bf(this, this, t), this.check();\n  }\n  rotateZ(t) {\n    return Cf(this, this, t), this.check();\n  }\n  scale(t) {\n    return wf(this, this, t), this.check();\n  }\n  slerp(t, n, s) {\n    let r, i, o;\n    switch (arguments.length) {\n      case 1:\n        ({\n          start: r = vf,\n          target: i,\n          ratio: o\n        } = t);\n        break;\n      case 2:\n        r = this, i = t, o = n;\n        break;\n      default:\n        r = t, i = n, o = s;\n    }\n    return bn(this, r, i, o), this.check();\n  }\n  transformVector4(t, n = new Tr()) {\n    return lf(n, t, this), Oe(n, 4);\n  }\n  lengthSq() {\n    return this.lengthSquared();\n  }\n  setFromAxisAngle(t, n) {\n    return this.setAxisAngle(t, n);\n  }\n  premultiply(t) {\n    return this.multiplyLeft(t);\n  }\n  multiply(t) {\n    return this.multiplyRight(t);\n  }\n}\nfunction Ne(e) {\n  \"@babel/helpers - typeof\";\n  return Ne = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(t) {\n    return typeof t;\n  } : function(t) {\n    return t && typeof Symbol == \"function\" && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n  }, Ne(e);\n}\nfunction Of(e, t) {\n  if (Ne(e) != \"object\" || !e)\n    return e;\n  var n = e[Symbol.toPrimitive];\n  if (n !== void 0) {\n    var s = n.call(e, t || \"default\");\n    if (Ne(s) != \"object\")\n      return s;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (t === \"string\" ? String : Number)(e);\n}\nfunction Ff(e) {\n  var t = Of(e, \"string\");\n  return Ne(t) == \"symbol\" ? t : String(t);\n}\nfunction x(e, t, n) {\n  return t = Ff(t), t in e ? Object.defineProperty(e, t, {\n    value: n,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = n, e;\n}\nconst Df = 0.1, Lf = 1e-12, Sa = 1e-15, Pf = 1e-20, Gf = 6378137, Nf = 6378137, Uf = 6356752314245179e-9;\nfunction Xn(e) {\n  return e;\n}\nnew A();\nfunction Hf(e, t = [], n = Xn) {\n  return \"longitude\" in e ? (t[0] = n(e.longitude), t[1] = n(e.latitude), t[2] = e.height) : \"x\" in e ? (t[0] = n(e.x), t[1] = n(e.y), t[2] = e.z) : (t[0] = n(e[0]), t[1] = n(e[1]), t[2] = e[2]), t;\n}\nfunction Jf(e, t = []) {\n  return Hf(e, t, Z._cartographicRadians ? Xn : ah);\n}\nfunction Vf(e, t, n = Xn) {\n  return \"longitude\" in t ? (t.longitude = n(e[0]), t.latitude = n(e[1]), t.height = e[2]) : \"x\" in t ? (t.x = n(e[0]), t.y = n(e[1]), t.z = e[2]) : (t[0] = n(e[0]), t[1] = n(e[1]), t[2] = e[2]), t;\n}\nfunction jf(e, t) {\n  return Vf(e, t, Z._cartographicRadians ? Xn : ch);\n}\nconst yi = 1e-14, kf = new A(), Bi = {\n  up: {\n    south: \"east\",\n    north: \"west\",\n    west: \"south\",\n    east: \"north\"\n  },\n  down: {\n    south: \"west\",\n    north: \"east\",\n    west: \"north\",\n    east: \"south\"\n  },\n  south: {\n    up: \"west\",\n    down: \"east\",\n    west: \"down\",\n    east: \"up\"\n  },\n  north: {\n    up: \"east\",\n    down: \"west\",\n    west: \"up\",\n    east: \"down\"\n  },\n  west: {\n    up: \"north\",\n    down: \"south\",\n    north: \"down\",\n    south: \"up\"\n  },\n  east: {\n    up: \"south\",\n    down: \"north\",\n    north: \"up\",\n    south: \"down\"\n  }\n}, gs = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n}, Te = {\n  east: new A(),\n  north: new A(),\n  up: new A(),\n  west: new A(),\n  south: new A(),\n  down: new A()\n}, Kf = new A(), zf = new A(), Wf = new A();\nfunction Ci(e, t, n, s, r, i) {\n  const o = Bi[t] && Bi[t][n];\n  j(o && (!s || s === o));\n  let a, c, u;\n  const l = kf.copy(r);\n  if (Kt(l.x, 0, yi) && Kt(l.y, 0, yi)) {\n    const f = Math.sign(l.z);\n    a = Kf.fromArray(gs[t]), t !== \"east\" && t !== \"west\" && a.scale(f), c = zf.fromArray(gs[n]), n !== \"east\" && n !== \"west\" && c.scale(f), u = Wf.fromArray(gs[s]), s !== \"east\" && s !== \"west\" && u.scale(f);\n  } else {\n    const {\n      up: f,\n      east: d,\n      north: m\n    } = Te;\n    d.set(-l.y, l.x, 0).normalize(), e.geodeticSurfaceNormal(l, f), m.copy(f).cross(d);\n    const {\n      down: g,\n      west: y,\n      south: E\n    } = Te;\n    g.copy(f).scale(-1), y.copy(d).scale(-1), E.copy(m).scale(-1), a = Te[t], c = Te[n], u = Te[s];\n  }\n  return i[0] = a.x, i[1] = a.y, i[2] = a.z, i[3] = 0, i[4] = c.x, i[5] = c.y, i[6] = c.z, i[7] = 0, i[8] = u.x, i[9] = u.y, i[10] = u.z, i[11] = 0, i[12] = l.x, i[13] = l.y, i[14] = l.z, i[15] = 1, i;\n}\nconst ue = new A(), Xf = new A(), Qf = new A();\nfunction qf(e, t, n = []) {\n  const {\n    oneOverRadii: s,\n    oneOverRadiiSquared: r,\n    centerToleranceSquared: i\n  } = t;\n  ue.from(e);\n  const o = ue.x, a = ue.y, c = ue.z, u = s.x, l = s.y, h = s.z, f = o * o * u * u, d = a * a * l * l, m = c * c * h * h, g = f + d + m, y = Math.sqrt(1 / g);\n  if (!Number.isFinite(y))\n    return;\n  const E = Xf;\n  if (E.copy(e).scale(y), g < i)\n    return E.to(n);\n  const R = r.x, B = r.y, C = r.z, M = Qf;\n  M.set(E.x * R * 2, E.y * B * 2, E.z * C * 2);\n  let b = (1 - y) * ue.len() / (0.5 * M.len()), O = 0, F, v, L, k;\n  do {\n    b -= O, F = 1 / (1 + b * R), v = 1 / (1 + b * B), L = 1 / (1 + b * C);\n    const X = F * F, Q = v * v, P = L * L, at = X * F, Wt = Q * v, oe = P * L;\n    k = f * X + d * Q + m * P - 1;\n    const Lt = -2 * (f * at * R + d * Wt * B + m * oe * C);\n    O = k / Lt;\n  } while (Math.abs(k) > Lf);\n  return ue.scale([F, v, L]).to(n);\n}\nconst an = new A(), Ei = new A(), Yf = new A(), wt = new A(), $f = new A(), cn = new A();\nclass J {\n  constructor(t = 0, n = 0, s = 0) {\n    x(this, \"radii\", void 0), x(this, \"radiiSquared\", void 0), x(this, \"radiiToTheFourth\", void 0), x(this, \"oneOverRadii\", void 0), x(this, \"oneOverRadiiSquared\", void 0), x(this, \"minimumRadius\", void 0), x(this, \"maximumRadius\", void 0), x(this, \"centerToleranceSquared\", Df), x(this, \"squaredXOverSquaredZ\", void 0), j(t >= 0), j(n >= 0), j(s >= 0), this.radii = new A(t, n, s), this.radiiSquared = new A(t * t, n * n, s * s), this.radiiToTheFourth = new A(t * t * t * t, n * n * n * n, s * s * s * s), this.oneOverRadii = new A(t === 0 ? 0 : 1 / t, n === 0 ? 0 : 1 / n, s === 0 ? 0 : 1 / s), this.oneOverRadiiSquared = new A(t === 0 ? 0 : 1 / (t * t), n === 0 ? 0 : 1 / (n * n), s === 0 ? 0 : 1 / (s * s)), this.minimumRadius = Math.min(t, n, s), this.maximumRadius = Math.max(t, n, s), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);\n  }\n  equals(t) {\n    return this === t || !!(t && this.radii.equals(t.radii));\n  }\n  toString() {\n    return this.radii.toString();\n  }\n  cartographicToCartesian(t, n = [0, 0, 0]) {\n    const s = Ei, r = Yf, [, , i] = t;\n    this.geodeticSurfaceNormalCartographic(t, s), r.copy(this.radiiSquared).scale(s);\n    const o = Math.sqrt(s.dot(r));\n    return r.scale(1 / o), s.scale(i), r.add(s), r.to(n);\n  }\n  cartesianToCartographic(t, n = [0, 0, 0]) {\n    cn.from(t);\n    const s = this.scaleToGeodeticSurface(cn, wt);\n    if (!s)\n      return;\n    const r = this.geodeticSurfaceNormal(s, Ei), i = $f;\n    i.copy(cn).subtract(s);\n    const o = Math.atan2(r.y, r.x), a = Math.asin(r.z), c = Math.sign(Cr(i, cn)) * Ea(i);\n    return jf([o, a, c], n);\n  }\n  eastNorthUpToFixedFrame(t, n = new V()) {\n    return Ci(this, \"east\", \"north\", \"up\", t, n);\n  }\n  localFrameToFixedFrame(t, n, s, r, i = new V()) {\n    return Ci(this, t, n, s, r, i);\n  }\n  geocentricSurfaceNormal(t, n = [0, 0, 0]) {\n    return an.from(t).normalize().to(n);\n  }\n  geodeticSurfaceNormalCartographic(t, n = [0, 0, 0]) {\n    const s = Jf(t), r = s[0], i = s[1], o = Math.cos(i);\n    return an.set(o * Math.cos(r), o * Math.sin(r), Math.sin(i)).normalize(), an.to(n);\n  }\n  geodeticSurfaceNormal(t, n = [0, 0, 0]) {\n    return an.from(t).scale(this.oneOverRadiiSquared).normalize().to(n);\n  }\n  scaleToGeodeticSurface(t, n) {\n    return qf(t, this, n);\n  }\n  scaleToGeocentricSurface(t, n = [0, 0, 0]) {\n    wt.from(t);\n    const s = wt.x, r = wt.y, i = wt.z, o = this.oneOverRadiiSquared, a = 1 / Math.sqrt(s * s * o.x + r * r * o.y + i * i * o.z);\n    return wt.multiplyScalar(a).to(n);\n  }\n  transformPositionToScaledSpace(t, n = [0, 0, 0]) {\n    return wt.from(t).scale(this.oneOverRadii).to(n);\n  }\n  transformPositionFromScaledSpace(t, n = [0, 0, 0]) {\n    return wt.from(t).scale(this.radii).to(n);\n  }\n  getSurfaceNormalIntersectionWithZAxis(t, n = 0, s = [0, 0, 0]) {\n    j(Kt(this.radii.x, this.radii.y, Sa)), j(this.radii.z > 0), wt.from(t);\n    const r = wt.z * (1 - this.squaredXOverSquaredZ);\n    if (!(Math.abs(r) >= this.radii.z - n))\n      return wt.set(0, 0, r).to(s);\n  }\n}\nx(J, \"WGS84\", new J(Gf, Nf, Uf));\nconst pt = {\n  OUTSIDE: -1,\n  INTERSECTING: 0,\n  INSIDE: 1\n};\nnew A();\nnew A();\nconst be = new A(), Ti = new A();\nclass Qe {\n  constructor(t = [0, 0, 0], n = 0) {\n    x(this, \"center\", void 0), x(this, \"radius\", void 0), this.radius = -0, this.center = new A(), this.fromCenterRadius(t, n);\n  }\n  fromCenterRadius(t, n) {\n    return this.center.from(t), this.radius = n, this;\n  }\n  fromCornerPoints(t, n) {\n    return n = be.from(n), this.center = new A().from(t).add(n).scale(0.5), this.radius = this.center.distance(n), this;\n  }\n  equals(t) {\n    return this === t || !!t && this.center.equals(t.center) && this.radius === t.radius;\n  }\n  clone() {\n    return new Qe(this.center, this.radius);\n  }\n  union(t) {\n    const n = this.center, s = this.radius, r = t.center, i = t.radius, o = be.copy(r).subtract(n), a = o.magnitude();\n    if (s >= a + i)\n      return this.clone();\n    if (i >= a + s)\n      return t.clone();\n    const c = (s + a + i) * 0.5;\n    return Ti.copy(o).scale((-s + c) / a).add(n), this.center.copy(Ti), this.radius = c, this;\n  }\n  expand(t) {\n    const s = be.from(t).subtract(this.center).magnitude();\n    return s > this.radius && (this.radius = s), this;\n  }\n  transform(t) {\n    this.center.transform(t);\n    const n = zh(be, t);\n    return this.radius = Math.max(n[0], Math.max(n[1], n[2])) * this.radius, this;\n  }\n  distanceSquaredTo(t) {\n    const n = this.distanceTo(t);\n    return n * n;\n  }\n  distanceTo(t) {\n    const s = be.from(t).subtract(this.center);\n    return Math.max(0, s.len() - this.radius);\n  }\n  intersectPlane(t) {\n    const n = this.center, s = this.radius, i = t.normal.dot(n) + t.distance;\n    return i < -s ? pt.OUTSIDE : i < s ? pt.INTERSECTING : pt.INSIDE;\n  }\n}\nconst Zf = new A(), td = new A(), un = new A(), ln = new A(), hn = new A(), ed = new A(), nd = new A(), Gt = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\nclass qe {\n  constructor(t = [0, 0, 0], n = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    x(this, \"center\", void 0), x(this, \"halfAxes\", void 0), this.center = new A().from(t), this.halfAxes = new W(n);\n  }\n  get halfSize() {\n    const t = this.halfAxes.getColumn(0), n = this.halfAxes.getColumn(1), s = this.halfAxes.getColumn(2);\n    return [new A(t).len(), new A(n).len(), new A(s).len()];\n  }\n  get quaternion() {\n    const t = this.halfAxes.getColumn(0), n = this.halfAxes.getColumn(1), s = this.halfAxes.getColumn(2), r = new A(t).normalize(), i = new A(n).normalize(), o = new A(s).normalize();\n    return new On().fromMatrix3(new W([...r, ...i, ...o]));\n  }\n  fromCenterHalfSizeQuaternion(t, n, s) {\n    const r = new On(s), i = new W().fromQuaternion(r);\n    return i[0] = i[0] * n[0], i[1] = i[1] * n[0], i[2] = i[2] * n[0], i[3] = i[3] * n[1], i[4] = i[4] * n[1], i[5] = i[5] * n[1], i[6] = i[6] * n[2], i[7] = i[7] * n[2], i[8] = i[8] * n[2], this.center = new A().from(t), this.halfAxes = i, this;\n  }\n  clone() {\n    return new qe(this.center, this.halfAxes);\n  }\n  equals(t) {\n    return this === t || !!t && this.center.equals(t.center) && this.halfAxes.equals(t.halfAxes);\n  }\n  getBoundingSphere(t = new Qe()) {\n    const n = this.halfAxes, s = n.getColumn(0, un), r = n.getColumn(1, ln), i = n.getColumn(2, hn), o = Zf.copy(s).add(r).add(i);\n    return t.center.copy(this.center), t.radius = o.magnitude(), t;\n  }\n  intersectPlane(t) {\n    const n = this.center, s = t.normal, r = this.halfAxes, i = s.x, o = s.y, a = s.z, c = Math.abs(i * r[Gt.COLUMN0ROW0] + o * r[Gt.COLUMN0ROW1] + a * r[Gt.COLUMN0ROW2]) + Math.abs(i * r[Gt.COLUMN1ROW0] + o * r[Gt.COLUMN1ROW1] + a * r[Gt.COLUMN1ROW2]) + Math.abs(i * r[Gt.COLUMN2ROW0] + o * r[Gt.COLUMN2ROW1] + a * r[Gt.COLUMN2ROW2]), u = s.dot(n) + t.distance;\n    return u <= -c ? pt.OUTSIDE : u >= c ? pt.INSIDE : pt.INTERSECTING;\n  }\n  distanceTo(t) {\n    return Math.sqrt(this.distanceSquaredTo(t));\n  }\n  distanceSquaredTo(t) {\n    const n = td.from(t).subtract(this.center), s = this.halfAxes, r = s.getColumn(0, un), i = s.getColumn(1, ln), o = s.getColumn(2, hn), a = r.magnitude(), c = i.magnitude(), u = o.magnitude();\n    r.normalize(), i.normalize(), o.normalize();\n    let l = 0, h;\n    return h = Math.abs(n.dot(r)) - a, h > 0 && (l += h * h), h = Math.abs(n.dot(i)) - c, h > 0 && (l += h * h), h = Math.abs(n.dot(o)) - u, h > 0 && (l += h * h), l;\n  }\n  computePlaneDistances(t, n, s = [-0, -0]) {\n    let r = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;\n    const o = this.center, a = this.halfAxes, c = a.getColumn(0, un), u = a.getColumn(1, ln), l = a.getColumn(2, hn), h = ed.copy(c).add(u).add(l).add(o), f = nd.copy(h).subtract(t);\n    let d = n.dot(f);\n    return r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).add(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).subtract(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), h.copy(o).add(c).subtract(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).add(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).add(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).subtract(u).add(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), o.copy(h).subtract(c).subtract(u).subtract(l), f.copy(h).subtract(t), d = n.dot(f), r = Math.min(d, r), i = Math.max(d, i), s[0] = r, s[1] = i, s;\n  }\n  transform(t) {\n    this.center.transformAsPoint(t);\n    const n = this.halfAxes.getColumn(0, un);\n    n.transformAsPoint(t);\n    const s = this.halfAxes.getColumn(1, ln);\n    s.transformAsPoint(t);\n    const r = this.halfAxes.getColumn(2, hn);\n    return r.transformAsPoint(t), this.halfAxes = new W([...n, ...s, ...r]), this;\n  }\n  getTransform() {\n    throw new Error(\"not implemented\");\n  }\n}\nconst bi = new A(), _i = new A();\nclass tt {\n  constructor(t = [0, 0, 1], n = 0) {\n    x(this, \"normal\", void 0), x(this, \"distance\", void 0), this.normal = new A(), this.distance = -0, this.fromNormalDistance(t, n);\n  }\n  fromNormalDistance(t, n) {\n    return j(Number.isFinite(n)), this.normal.from(t).normalize(), this.distance = n, this;\n  }\n  fromPointNormal(t, n) {\n    t = bi.from(t), this.normal.from(n).normalize();\n    const s = -this.normal.dot(t);\n    return this.distance = s, this;\n  }\n  fromCoefficients(t, n, s, r) {\n    return this.normal.set(t, n, s), j(Kt(this.normal.len(), 1)), this.distance = r, this;\n  }\n  clone() {\n    return new tt(this.normal, this.distance);\n  }\n  equals(t) {\n    return Kt(this.distance, t.distance) && Kt(this.normal, t.normal);\n  }\n  getPointDistance(t) {\n    return this.normal.dot(t) + this.distance;\n  }\n  transform(t) {\n    const n = _i.copy(this.normal).transformAsVector(t).normalize(), s = this.normal.scale(-this.distance).transform(t);\n    return this.fromPointNormal(s, n);\n  }\n  projectPointOntoPlane(t, n = [0, 0, 0]) {\n    const s = bi.from(t), r = this.getPointDistance(s), i = _i.copy(this.normal).scale(r);\n    return s.subtract(i).to(n);\n  }\n}\nconst wi = [new A([1, 0, 0]), new A([0, 1, 0]), new A([0, 0, 1])], Ri = new A(), sd = new A();\nclass dt {\n  constructor(t = []) {\n    x(this, \"planes\", void 0), this.planes = t;\n  }\n  fromBoundingSphere(t) {\n    this.planes.length = 2 * wi.length;\n    const n = t.center, s = t.radius;\n    let r = 0;\n    for (const i of wi) {\n      let o = this.planes[r], a = this.planes[r + 1];\n      o || (o = this.planes[r] = new tt()), a || (a = this.planes[r + 1] = new tt());\n      const c = Ri.copy(i).scale(-s).add(n);\n      o.fromPointNormal(c, i);\n      const u = Ri.copy(i).scale(s).add(n), l = sd.copy(i).negate();\n      a.fromPointNormal(u, l), r += 2;\n    }\n    return this;\n  }\n  computeVisibility(t) {\n    let n = pt.INSIDE;\n    for (const s of this.planes)\n      switch (t.intersectPlane(s)) {\n        case pt.OUTSIDE:\n          return pt.OUTSIDE;\n        case pt.INTERSECTING:\n          n = pt.INTERSECTING;\n          break;\n      }\n    return n;\n  }\n  computeVisibilityWithPlaneMask(t, n) {\n    if (j(Number.isFinite(n), \"parentPlaneMask is required.\"), n === dt.MASK_OUTSIDE || n === dt.MASK_INSIDE)\n      return n;\n    let s = dt.MASK_INSIDE;\n    const r = this.planes;\n    for (let i = 0; i < this.planes.length; ++i) {\n      const o = i < 31 ? 1 << i : 0;\n      if (i < 31 && !(n & o))\n        continue;\n      const a = r[i], c = t.intersectPlane(a);\n      if (c === pt.OUTSIDE)\n        return dt.MASK_OUTSIDE;\n      c === pt.INTERSECTING && (s |= o);\n    }\n    return s;\n  }\n}\nx(dt, \"MASK_OUTSIDE\", 4294967295);\nx(dt, \"MASK_INSIDE\", 0);\nx(dt, \"MASK_INDETERMINATE\", 2147483647);\nconst rd = new A(), id = new A(), od = new A(), ad = new A(), cd = new A();\nclass Fn {\n  constructor(t = {}) {\n    x(this, \"left\", void 0), x(this, \"_left\", void 0), x(this, \"right\", void 0), x(this, \"_right\", void 0), x(this, \"top\", void 0), x(this, \"_top\", void 0), x(this, \"bottom\", void 0), x(this, \"_bottom\", void 0), x(this, \"near\", void 0), x(this, \"_near\", void 0), x(this, \"far\", void 0), x(this, \"_far\", void 0), x(this, \"_cullingVolume\", new dt([new tt(), new tt(), new tt(), new tt(), new tt(), new tt()])), x(this, \"_perspectiveMatrix\", new V()), x(this, \"_infinitePerspective\", new V());\n    const {\n      near: n = 1,\n      far: s = 5e8\n    } = t;\n    this.left = t.left, this._left = void 0, this.right = t.right, this._right = void 0, this.top = t.top, this._top = void 0, this.bottom = t.bottom, this._bottom = void 0, this.near = n, this._near = n, this.far = s, this._far = s;\n  }\n  clone() {\n    return new Fn({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n  equals(t) {\n    return t && t instanceof Fn && this.right === t.right && this.left === t.left && this.top === t.top && this.bottom === t.bottom && this.near === t.near && this.far === t.far;\n  }\n  get projectionMatrix() {\n    return this._update(), this._perspectiveMatrix;\n  }\n  get infiniteProjectionMatrix() {\n    return this._update(), this._infinitePerspective;\n  }\n  computeCullingVolume(t, n, s) {\n    j(t, \"position is required.\"), j(n, \"direction is required.\"), j(s, \"up is required.\");\n    const r = this._cullingVolume.planes;\n    s = rd.copy(s).normalize();\n    const i = id.copy(n).cross(s).normalize(), o = od.copy(n).multiplyByScalar(this.near).add(t), a = ad.copy(n).multiplyByScalar(this.far).add(t);\n    let c = cd;\n    return c.copy(i).multiplyByScalar(this.left).add(o).subtract(t).cross(s), r[0].fromPointNormal(t, c), c.copy(i).multiplyByScalar(this.right).add(o).subtract(t).cross(s).negate(), r[1].fromPointNormal(t, c), c.copy(s).multiplyByScalar(this.bottom).add(o).subtract(t).cross(i).negate(), r[2].fromPointNormal(t, c), c.copy(s).multiplyByScalar(this.top).add(o).subtract(t).cross(i), r[3].fromPointNormal(t, c), c = new A().copy(n), r[4].fromPointNormal(o, c), c.negate(), r[5].fromPointNormal(a, c), this._cullingVolume;\n  }\n  getPixelDimensions(t, n, s, r) {\n    this._update(), j(Number.isFinite(t) && Number.isFinite(n)), j(t > 0), j(n > 0), j(s > 0), j(r);\n    const i = 1 / this.near;\n    let o = this.top * i;\n    const a = 2 * s * o / n;\n    o = this.right * i;\n    const c = 2 * s * o / t;\n    return r.x = c, r.y = a, r;\n  }\n  _update() {\n    j(Number.isFinite(this.right) && Number.isFinite(this.left) && Number.isFinite(this.top) && Number.isFinite(this.bottom) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const {\n      top: t,\n      bottom: n,\n      right: s,\n      left: r,\n      near: i,\n      far: o\n    } = this;\n    (t !== this._top || n !== this._bottom || r !== this._left || s !== this._right || i !== this._near || o !== this._far) && (j(this.near > 0 && this.near < this.far, \"near must be greater than zero and less than far.\"), this._left = r, this._right = s, this._top = t, this._bottom = n, this._near = i, this._far = o, this._perspectiveMatrix = new V().frustum({\n      left: r,\n      right: s,\n      bottom: n,\n      top: t,\n      near: i,\n      far: o\n    }), this._infinitePerspective = new V().frustum({\n      left: r,\n      right: s,\n      bottom: n,\n      top: t,\n      near: i,\n      far: 1 / 0\n    }));\n  }\n}\nconst ud = (e) => e !== null && typeof e < \"u\";\nclass Dn {\n  constructor(t = {}) {\n    x(this, \"_offCenterFrustum\", new Fn()), x(this, \"fov\", void 0), x(this, \"_fov\", void 0), x(this, \"_fovy\", void 0), x(this, \"_sseDenominator\", void 0), x(this, \"aspectRatio\", void 0), x(this, \"_aspectRatio\", void 0), x(this, \"near\", void 0), x(this, \"_near\", void 0), x(this, \"far\", void 0), x(this, \"_far\", void 0), x(this, \"xOffset\", void 0), x(this, \"_xOffset\", void 0), x(this, \"yOffset\", void 0), x(this, \"_yOffset\", void 0);\n    const {\n      fov: n,\n      aspectRatio: s,\n      near: r = 1,\n      far: i = 5e8,\n      xOffset: o = 0,\n      yOffset: a = 0\n    } = t;\n    this.fov = n, this.aspectRatio = s, this.near = r, this.far = i, this.xOffset = o, this.yOffset = a;\n  }\n  clone() {\n    return new Dn({\n      aspectRatio: this.aspectRatio,\n      fov: this.fov,\n      near: this.near,\n      far: this.far\n    });\n  }\n  equals(t) {\n    return !ud(t) || !(t instanceof Dn) ? !1 : (this._update(), t._update(), this.fov === t.fov && this.aspectRatio === t.aspectRatio && this.near === t.near && this.far === t.far && this._offCenterFrustum.equals(t._offCenterFrustum));\n  }\n  get projectionMatrix() {\n    return this._update(), this._offCenterFrustum.projectionMatrix;\n  }\n  get infiniteProjectionMatrix() {\n    return this._update(), this._offCenterFrustum.infiniteProjectionMatrix;\n  }\n  get fovy() {\n    return this._update(), this._fovy;\n  }\n  get sseDenominator() {\n    return this._update(), this._sseDenominator;\n  }\n  computeCullingVolume(t, n, s) {\n    return this._update(), this._offCenterFrustum.computeCullingVolume(t, n, s);\n  }\n  getPixelDimensions(t, n, s, r) {\n    return this._update(), this._offCenterFrustum.getPixelDimensions(t, n, s, r || new Wn());\n  }\n  _update() {\n    j(Number.isFinite(this.fov) && Number.isFinite(this.aspectRatio) && Number.isFinite(this.near) && Number.isFinite(this.far));\n    const t = this._offCenterFrustum;\n    (this.fov !== this._fov || this.aspectRatio !== this._aspectRatio || this.near !== this._near || this.far !== this._far || this.xOffset !== this._xOffset || this.yOffset !== this._yOffset) && (j(this.fov >= 0 && this.fov < Math.PI), j(this.aspectRatio > 0), j(this.near >= 0 && this.near < this.far), this._aspectRatio = this.aspectRatio, this._fov = this.fov, this._fovy = this.aspectRatio <= 1 ? this.fov : Math.atan(Math.tan(this.fov * 0.5) / this.aspectRatio) * 2, this._near = this.near, this._far = this.far, this._sseDenominator = 2 * Math.tan(0.5 * this._fovy), this._xOffset = this.xOffset, this._yOffset = this.yOffset, t.top = this.near * Math.tan(0.5 * this._fovy), t.bottom = -t.top, t.right = this.aspectRatio * t.top, t.left = -t.right, t.near = this.near, t.far = this.far, t.right += this.xOffset, t.left += this.xOffset, t.top += this.yOffset, t.bottom += this.yOffset);\n  }\n}\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nnew A();\nconst vt = new W(), ld = new W(), hd = new W(), fn = new W(), Mi = new W();\nfunction fd(e, t = {}) {\n  const n = Pf, s = 10;\n  let r = 0, i = 0;\n  const o = ld, a = hd;\n  o.identity(), a.copy(e);\n  const c = n * dd(a);\n  for (; i < s && md(a) > c; )\n    gd(a, fn), Mi.copy(fn).transpose(), a.multiplyRight(fn), a.multiplyLeft(Mi), o.multiplyRight(fn), ++r > 2 && (++i, r = 0);\n  return t.unitary = o.toTarget(t.unitary), t.diagonal = a.toTarget(t.diagonal), t;\n}\nfunction dd(e) {\n  let t = 0;\n  for (let n = 0; n < 9; ++n) {\n    const s = e[n];\n    t += s * s;\n  }\n  return Math.sqrt(t);\n}\nconst zs = [1, 0, 0], Ws = [2, 2, 1];\nfunction md(e) {\n  let t = 0;\n  for (let n = 0; n < 3; ++n) {\n    const s = e[vt.getElementIndex(Ws[n], zs[n])];\n    t += 2 * s * s;\n  }\n  return Math.sqrt(t);\n}\nfunction gd(e, t) {\n  const n = Sa;\n  let s = 0, r = 1;\n  for (let u = 0; u < 3; ++u) {\n    const l = Math.abs(e[vt.getElementIndex(Ws[u], zs[u])]);\n    l > s && (r = u, s = l);\n  }\n  const i = zs[r], o = Ws[r];\n  let a = 1, c = 0;\n  if (Math.abs(e[vt.getElementIndex(o, i)]) > n) {\n    const u = e[vt.getElementIndex(o, o)], l = e[vt.getElementIndex(i, i)], h = e[vt.getElementIndex(o, i)], f = (u - l) / 2 / h;\n    let d;\n    f < 0 ? d = -1 / (-f + Math.sqrt(1 + f * f)) : d = 1 / (f + Math.sqrt(1 + f * f)), a = 1 / Math.sqrt(1 + d * d), c = d * a;\n  }\n  return W.IDENTITY.to(t), t[vt.getElementIndex(i, i)] = t[vt.getElementIndex(o, o)] = a, t[vt.getElementIndex(o, i)] = c, t[vt.getElementIndex(i, o)] = -c, t;\n}\nconst Vt = new A(), Ad = new A(), pd = new A(), yd = new A(), Bd = new A(), Cd = new W(), Ed = {\n  diagonal: new W(),\n  unitary: new W()\n};\nfunction Td(e, t = new qe()) {\n  if (!e || e.length === 0)\n    return t.halfAxes = new W([0, 0, 0, 0, 0, 0, 0, 0, 0]), t.center = new A(), t;\n  const n = e.length, s = new A(0, 0, 0);\n  for (const v of e)\n    s.add(v);\n  const r = 1 / n;\n  s.multiplyByScalar(r);\n  let i = 0, o = 0, a = 0, c = 0, u = 0, l = 0;\n  for (const v of e) {\n    const L = Vt.copy(v).subtract(s);\n    i += L.x * L.x, o += L.x * L.y, a += L.x * L.z, c += L.y * L.y, u += L.y * L.z, l += L.z * L.z;\n  }\n  i *= r, o *= r, a *= r, c *= r, u *= r, l *= r;\n  const h = Cd;\n  h[0] = i, h[1] = o, h[2] = a, h[3] = o, h[4] = c, h[5] = u, h[6] = a, h[7] = u, h[8] = l;\n  const {\n    unitary: f\n  } = fd(h, Ed), d = t.halfAxes.copy(f);\n  let m = d.getColumn(0, pd), g = d.getColumn(1, yd), y = d.getColumn(2, Bd), E = -Number.MAX_VALUE, R = -Number.MAX_VALUE, B = -Number.MAX_VALUE, C = Number.MAX_VALUE, M = Number.MAX_VALUE, b = Number.MAX_VALUE;\n  for (const v of e)\n    Vt.copy(v), E = Math.max(Vt.dot(m), E), R = Math.max(Vt.dot(g), R), B = Math.max(Vt.dot(y), B), C = Math.min(Vt.dot(m), C), M = Math.min(Vt.dot(g), M), b = Math.min(Vt.dot(y), b);\n  m = m.multiplyByScalar(0.5 * (C + E)), g = g.multiplyByScalar(0.5 * (M + R)), y = y.multiplyByScalar(0.5 * (b + B)), t.center.copy(m).add(g).add(y);\n  const O = Ad.set(E - C, R - M, B - b).multiplyByScalar(0.5), F = new W([O[0], 0, 0, 0, O[1], 0, 0, 0, O[2]]);\n  return t.halfAxes.multiplyRight(F), t;\n}\nlet Si = function(e) {\n  return e[e.ADD = 1] = \"ADD\", e[e.REPLACE = 2] = \"REPLACE\", e;\n}({}), dn = function(e) {\n  return e.EMPTY = \"empty\", e.SCENEGRAPH = \"scenegraph\", e.POINTCLOUD = \"pointcloud\", e.MESH = \"mesh\", e;\n}({}), bd = function(e) {\n  return e.I3S = \"I3S\", e.TILES3D = \"TILES3D\", e;\n}({}), Qn = function(e) {\n  return e.GEOMETRIC_ERROR = \"geometricError\", e.MAX_SCREEN_THRESHOLD = \"maxScreenThreshold\", e;\n}({});\nconst Ia = \"4.1.1\", _e = {\n  COMPOSITE: \"cmpt\",\n  POINT_CLOUD: \"pnts\",\n  BATCHED_3D_MODEL: \"b3dm\",\n  INSTANCED_3D_MODEL: \"i3dm\",\n  GEOMETRY: \"geom\",\n  VECTOR: \"vect\",\n  GLTF: \"glTF\"\n};\nfunction xa(e, t, n) {\n  K(e instanceof ArrayBuffer);\n  const s = new TextDecoder(\"utf8\"), r = new Uint8Array(e, t, n);\n  return s.decode(r);\n}\nfunction _d(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  const n = new DataView(e);\n  return `${String.fromCharCode(n.getUint8(t + 0))}${String.fromCharCode(n.getUint8(t + 1))}${String.fromCharCode(n.getUint8(t + 2))}${String.fromCharCode(n.getUint8(t + 3))}`;\n}\nconst wd = \"4.1.1\", Rd = {\n  name: \"Draco\",\n  id: \"draco\",\n  module: \"draco\",\n  version: wd,\n  worker: !0,\n  extensions: [\"drc\"],\n  mimeTypes: [\"application/octet-stream\"],\n  binary: !0,\n  tests: [\"DRACO\"],\n  options: {\n    draco: {\n      decoderType: typeof WebAssembly == \"object\" ? \"wasm\" : \"js\",\n      libraryPath: \"libs/\",\n      extraAttributes: {},\n      attributeNameEntry: void 0\n    }\n  }\n};\nfunction Md(e, t, n) {\n  const s = va(t.metadata), r = [], i = Sd(t.attributes);\n  for (const o in e) {\n    const a = e[o], c = Ii(o, a, i[o]);\n    r.push(c);\n  }\n  if (n) {\n    const o = Ii(\"indices\", n);\n    r.push(o);\n  }\n  return {\n    fields: r,\n    metadata: s\n  };\n}\nfunction Sd(e) {\n  const t = {};\n  for (const n in e) {\n    const s = e[n];\n    t[s.name || \"undefined\"] = s;\n  }\n  return t;\n}\nfunction Ii(e, t, n) {\n  const s = n ? va(n.metadata) : void 0;\n  return eh(e, t, s);\n}\nfunction va(e) {\n  Object.entries(e);\n  const t = {};\n  for (const n in e)\n    t[`${n}.string`] = JSON.stringify(e[n]);\n  return t;\n}\nconst xi = {\n  POSITION: \"POSITION\",\n  NORMAL: \"NORMAL\",\n  COLOR: \"COLOR_0\",\n  TEX_COORD: \"TEXCOORD_0\"\n}, Id = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n}, xd = 4;\nclass vd {\n  constructor(t) {\n    this.draco = void 0, this.decoder = void 0, this.metadataQuerier = void 0, this.draco = t, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n  destroy() {\n    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);\n  }\n  parseSync(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const s = new this.draco.DecoderBuffer();\n    s.Init(new Int8Array(t), t.byteLength), this._disableAttributeTransforms(n);\n    const r = this.decoder.GetEncodedGeometryType(s), i = r === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();\n    try {\n      let o;\n      switch (r) {\n        case this.draco.TRIANGULAR_MESH:\n          o = this.decoder.DecodeBufferToMesh(s, i);\n          break;\n        case this.draco.POINT_CLOUD:\n          o = this.decoder.DecodeBufferToPointCloud(s, i);\n          break;\n        default:\n          throw new Error(\"DRACO: Unknown geometry type.\");\n      }\n      if (!o.ok() || !i.ptr) {\n        const f = `DRACO decompression failed: ${o.error_msg()}`;\n        throw new Error(f);\n      }\n      const a = this._getDracoLoaderData(i, r, n), c = this._getMeshData(i, a, n), u = th(c.attributes), l = Md(c.attributes, a, c.indices);\n      return {\n        loader: \"draco\",\n        loaderData: a,\n        header: {\n          vertexCount: i.num_points(),\n          boundingBox: u\n        },\n        ...c,\n        schema: l\n      };\n    } finally {\n      this.draco.destroy(s), i && this.draco.destroy(i);\n    }\n  }\n  _getDracoLoaderData(t, n, s) {\n    const r = this._getTopLevelMetadata(t), i = this._getDracoAttributes(t, s);\n    return {\n      geometry_type: n,\n      num_attributes: t.num_attributes(),\n      num_points: t.num_points(),\n      num_faces: t instanceof this.draco.Mesh ? t.num_faces() : 0,\n      metadata: r,\n      attributes: i\n    };\n  }\n  _getDracoAttributes(t, n) {\n    const s = {};\n    for (let r = 0; r < t.num_attributes(); r++) {\n      const i = this.decoder.GetAttribute(t, r), o = this._getAttributeMetadata(t, r);\n      s[i.unique_id()] = {\n        unique_id: i.unique_id(),\n        attribute_type: i.attribute_type(),\n        data_type: i.data_type(),\n        num_components: i.num_components(),\n        byte_offset: i.byte_offset(),\n        byte_stride: i.byte_stride(),\n        normalized: i.normalized(),\n        attribute_index: r,\n        metadata: o\n      };\n      const a = this._getQuantizationTransform(i, n);\n      a && (s[i.unique_id()].quantization_transform = a);\n      const c = this._getOctahedronTransform(i, n);\n      c && (s[i.unique_id()].octahedron_transform = c);\n    }\n    return s;\n  }\n  _getMeshData(t, n, s) {\n    const r = this._getMeshAttributes(n, t, s);\n    if (!r.POSITION)\n      throw new Error(\"DRACO: No position attribute found.\");\n    if (t instanceof this.draco.Mesh)\n      switch (s.topology) {\n        case \"triangle-strip\":\n          return {\n            topology: \"triangle-strip\",\n            mode: 4,\n            attributes: r,\n            indices: {\n              value: this._getTriangleStripIndices(t),\n              size: 1\n            }\n          };\n        case \"triangle-list\":\n        default:\n          return {\n            topology: \"triangle-list\",\n            mode: 5,\n            attributes: r,\n            indices: {\n              value: this._getTriangleListIndices(t),\n              size: 1\n            }\n          };\n      }\n    return {\n      topology: \"point-list\",\n      mode: 0,\n      attributes: r\n    };\n  }\n  _getMeshAttributes(t, n, s) {\n    const r = {};\n    for (const i of Object.values(t.attributes)) {\n      const o = this._deduceAttributeName(i, s);\n      i.name = o;\n      const {\n        value: a,\n        size: c\n      } = this._getAttributeValues(n, i);\n      r[o] = {\n        value: a,\n        size: c,\n        byteOffset: i.byte_offset,\n        byteStride: i.byte_stride,\n        normalized: i.normalized\n      };\n    }\n    return r;\n  }\n  _getTriangleListIndices(t) {\n    const s = t.num_faces() * 3, r = s * xd, i = this.draco._malloc(r);\n    try {\n      return this.decoder.GetTrianglesUInt32Array(t, r, i), new Uint32Array(this.draco.HEAPF32.buffer, i, s).slice();\n    } finally {\n      this.draco._free(i);\n    }\n  }\n  _getTriangleStripIndices(t) {\n    const n = new this.draco.DracoInt32Array();\n    try {\n      return this.decoder.GetTriangleStripsFromMesh(t, n), Dd(n);\n    } finally {\n      this.draco.destroy(n);\n    }\n  }\n  _getAttributeValues(t, n) {\n    const s = Id[n.data_type], r = n.num_components, o = t.num_points() * r, a = o * s.BYTES_PER_ELEMENT, c = Od(this.draco, s);\n    let u;\n    const l = this.draco._malloc(a);\n    try {\n      const h = this.decoder.GetAttribute(t, n.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(t, h, c, a, l), u = new s(this.draco.HEAPF32.buffer, l, o).slice();\n    } finally {\n      this.draco._free(l);\n    }\n    return {\n      value: u,\n      size: r\n    };\n  }\n  _deduceAttributeName(t, n) {\n    const s = t.unique_id;\n    for (const [o, a] of Object.entries(n.extraAttributes || {}))\n      if (a === s)\n        return o;\n    const r = t.attribute_type;\n    for (const o in xi)\n      if (this.draco[o] === r)\n        return xi[o];\n    const i = n.attributeNameEntry || \"name\";\n    return t.metadata[i] ? t.metadata[i].string : `CUSTOM_ATTRIBUTE_${s}`;\n  }\n  _getTopLevelMetadata(t) {\n    const n = this.decoder.GetMetadata(t);\n    return this._getDracoMetadata(n);\n  }\n  _getAttributeMetadata(t, n) {\n    const s = this.decoder.GetAttributeMetadata(t, n);\n    return this._getDracoMetadata(s);\n  }\n  _getDracoMetadata(t) {\n    if (!t || !t.ptr)\n      return {};\n    const n = {}, s = this.metadataQuerier.NumEntries(t);\n    for (let r = 0; r < s; r++) {\n      const i = this.metadataQuerier.GetEntryName(t, r);\n      n[i] = this._getDracoMetadataField(t, i);\n    }\n    return n;\n  }\n  _getDracoMetadataField(t, n) {\n    const s = new this.draco.DracoInt32Array();\n    try {\n      this.metadataQuerier.GetIntEntryArray(t, n, s);\n      const r = Fd(s);\n      return {\n        int: this.metadataQuerier.GetIntEntry(t, n),\n        string: this.metadataQuerier.GetStringEntry(t, n),\n        double: this.metadataQuerier.GetDoubleEntry(t, n),\n        intArray: r\n      };\n    } finally {\n      this.draco.destroy(s);\n    }\n  }\n  _disableAttributeTransforms(t) {\n    const {\n      quantizedAttributes: n = [],\n      octahedronAttributes: s = []\n    } = t, r = [...n, ...s];\n    for (const i of r)\n      this.decoder.SkipAttributeTransform(this.draco[i]);\n  }\n  _getQuantizationTransform(t, n) {\n    const {\n      quantizedAttributes: s = []\n    } = n, r = t.attribute_type();\n    if (s.map((o) => this.decoder[o]).includes(r)) {\n      const o = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (o.InitFromAttribute(t))\n          return {\n            quantization_bits: o.quantization_bits(),\n            range: o.range(),\n            min_values: new Float32Array([1, 2, 3]).map((a) => o.min_value(a))\n          };\n      } finally {\n        this.draco.destroy(o);\n      }\n    }\n    return null;\n  }\n  _getOctahedronTransform(t, n) {\n    const {\n      octahedronAttributes: s = []\n    } = n, r = t.attribute_type();\n    if (s.map((o) => this.decoder[o]).includes(r)) {\n      const o = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (o.InitFromAttribute(t))\n          return {\n            quantization_bits: o.quantization_bits()\n          };\n      } finally {\n        this.draco.destroy(o);\n      }\n    }\n    return null;\n  }\n}\nfunction Od(e, t) {\n  switch (t) {\n    case Float32Array:\n      return e.DT_FLOAT32;\n    case Int8Array:\n      return e.DT_INT8;\n    case Int16Array:\n      return e.DT_INT16;\n    case Int32Array:\n      return e.DT_INT32;\n    case Uint8Array:\n      return e.DT_UINT8;\n    case Uint16Array:\n      return e.DT_UINT16;\n    case Uint32Array:\n      return e.DT_UINT32;\n    default:\n      return e.DT_INVALID;\n  }\n}\nfunction Fd(e) {\n  const t = e.size(), n = new Int32Array(t);\n  for (let s = 0; s < t; s++)\n    n[s] = e.GetValue(s);\n  return n;\n}\nfunction Dd(e) {\n  const t = e.size(), n = new Int32Array(t);\n  for (let s = 0; s < t; s++)\n    n[s] = e.GetValue(s);\n  return n;\n}\nconst Ld = \"1.5.6\", Pd = \"1.4.1\", As = `https://www.gstatic.com/draco/versioned/decoders/${Ld}`, ft = {\n  DECODER: \"draco_wasm_wrapper.js\",\n  DECODER_WASM: \"draco_decoder.wasm\",\n  FALLBACK_DECODER: \"draco_decoder.js\",\n  ENCODER: \"draco_encoder.js\"\n}, ps = {\n  [ft.DECODER]: `${As}/${ft.DECODER}`,\n  [ft.DECODER_WASM]: `${As}/${ft.DECODER_WASM}`,\n  [ft.FALLBACK_DECODER]: `${As}/${ft.FALLBACK_DECODER}`,\n  [ft.ENCODER]: `https://raw.githubusercontent.com/google/draco/${Pd}/javascript/${ft.ENCODER}`\n};\nlet we;\nasync function Gd(e) {\n  const t = e.modules || {};\n  return t.draco3d ? we = we || t.draco3d.createDecoderModule({}).then((n) => ({\n    draco: n\n  })) : we = we || Nd(e), await we;\n}\nasync function Nd(e) {\n  let t, n;\n  switch (e.draco && e.draco.decoderType) {\n    case \"js\":\n      t = await Zt(ps[ft.FALLBACK_DECODER], \"draco\", e, ft.FALLBACK_DECODER);\n      break;\n    case \"wasm\":\n    default:\n      [t, n] = await Promise.all([await Zt(ps[ft.DECODER], \"draco\", e, ft.DECODER), await Zt(ps[ft.DECODER_WASM], \"draco\", e, ft.DECODER_WASM)]);\n  }\n  return t = t || globalThis.DracoDecoderModule, await Ud(t, n);\n}\nfunction Ud(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise((s) => {\n    e({\n      ...n,\n      onModuleLoaded: (r) => s({\n        draco: r\n      })\n    });\n  });\n}\nconst Oa = {\n  ...Rd,\n  parse: Hd\n};\nasync function Hd(e, t) {\n  const {\n    draco: n\n  } = await Gd(t), s = new vd(n);\n  try {\n    return s.parseSync(e, t == null ? void 0 : t.draco);\n  } finally {\n    s.destroy();\n  }\n}\nconst Jd = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6\n}, Y = {\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  DOUBLE: 5130\n}, G = {\n  ...Jd,\n  ...Y\n}, ys = {\n  [Y.DOUBLE]: Float64Array,\n  [Y.FLOAT]: Float32Array,\n  [Y.UNSIGNED_SHORT]: Uint16Array,\n  [Y.UNSIGNED_INT]: Uint32Array,\n  [Y.UNSIGNED_BYTE]: Uint8Array,\n  [Y.BYTE]: Int8Array,\n  [Y.SHORT]: Int16Array,\n  [Y.INT]: Int32Array\n}, Vd = {\n  DOUBLE: Y.DOUBLE,\n  FLOAT: Y.FLOAT,\n  UNSIGNED_SHORT: Y.UNSIGNED_SHORT,\n  UNSIGNED_INT: Y.UNSIGNED_INT,\n  UNSIGNED_BYTE: Y.UNSIGNED_BYTE,\n  BYTE: Y.BYTE,\n  SHORT: Y.SHORT,\n  INT: Y.INT\n}, Bs = \"Failed to convert GL type\";\nclass Dt {\n  static fromTypedArray(t) {\n    t = ArrayBuffer.isView(t) ? t.constructor : t;\n    for (const n in ys)\n      if (ys[n] === t)\n        return n;\n    throw new Error(Bs);\n  }\n  static fromName(t) {\n    const n = Vd[t];\n    if (!n)\n      throw new Error(Bs);\n    return n;\n  }\n  static getArrayType(t) {\n    switch (t) {\n      case Y.UNSIGNED_SHORT_5_6_5:\n      case Y.UNSIGNED_SHORT_4_4_4_4:\n      case Y.UNSIGNED_SHORT_5_5_5_1:\n        return Uint16Array;\n      default:\n        const n = ys[t];\n        if (!n)\n          throw new Error(Bs);\n        return n;\n    }\n  }\n  static getByteSize(t) {\n    return Dt.getArrayType(t).BYTES_PER_ELEMENT;\n  }\n  static validate(t) {\n    return !!Dt.getArrayType(t);\n  }\n  static createTypedArray(t, n) {\n    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 ? arguments[3] : void 0;\n    r === void 0 && (r = (n.byteLength - s) / Dt.getByteSize(t));\n    const i = Dt.getArrayType(t);\n    return new i(n, s, r);\n  }\n}\nfunction jd(e, t) {\n  if (!e)\n    throw new Error(`math.gl assertion failed. ${t}`);\n}\nfunction kd(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];\n  const n = e >> 11 & 31, s = e >> 5 & 63, r = e & 31;\n  return t[0] = n << 3, t[1] = s << 2, t[2] = r << 3, t;\n}\nnew Wn();\nnew A();\nnew Wn();\nnew Wn();\nfunction vi(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;\n  return lh(e, 0, t) / t * 2 - 1;\n}\nfunction Oi(e) {\n  return e < 0 ? -1 : 1;\n}\nfunction Kd(e, t, n, s) {\n  if (jd(s), e < 0 || e > n || t < 0 || t > n)\n    throw new Error(`x and y must be unsigned normalized integers between 0 and ${n}`);\n  if (s.x = vi(e, n), s.y = vi(t, n), s.z = 1 - (Math.abs(s.x) + Math.abs(s.y)), s.z < 0) {\n    const r = s.x;\n    s.x = (1 - Math.abs(s.y)) * Oi(r), s.y = (1 - Math.abs(r)) * Oi(s.y);\n  }\n  return s.normalize();\n}\nfunction zd(e, t, n) {\n  return Kd(e, t, 255, n);\n}\nclass br {\n  constructor(t, n) {\n    this.json = void 0, this.buffer = void 0, this.featuresLength = 0, this._cachedTypedArrays = {}, this.json = t, this.buffer = n;\n  }\n  getExtension(t) {\n    return this.json.extensions && this.json.extensions[t];\n  }\n  hasProperty(t) {\n    return !!this.json[t];\n  }\n  getGlobalProperty(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : G.UNSIGNED_INT, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    const r = this.json[t];\n    return r && Number.isFinite(r.byteOffset) ? this._getTypedArrayFromBinary(t, n, s, 1, r.byteOffset) : r;\n  }\n  getPropertyArray(t, n, s) {\n    const r = this.json[t];\n    return r && Number.isFinite(r.byteOffset) ? (\"componentType\" in r && (n = Dt.fromName(r.componentType)), this._getTypedArrayFromBinary(t, n, s, this.featuresLength, r.byteOffset)) : this._getTypedArrayFromArray(t, n, r);\n  }\n  getProperty(t, n, s, r, i) {\n    const o = this.json[t];\n    if (!o)\n      return o;\n    const a = this.getPropertyArray(t, n, s);\n    if (s === 1)\n      return a[r];\n    for (let c = 0; c < s; ++c)\n      i[c] = a[s * r + c];\n    return i;\n  }\n  _getTypedArrayFromBinary(t, n, s, r, i) {\n    const o = this._cachedTypedArrays;\n    let a = o[t];\n    return a || (a = Dt.createTypedArray(n, this.buffer.buffer, this.buffer.byteOffset + i, r * s), o[t] = a), a;\n  }\n  _getTypedArrayFromArray(t, n, s) {\n    const r = this._cachedTypedArrays;\n    let i = r[t];\n    return i || (i = Dt.createTypedArray(n, s), r[t] = i), i;\n  }\n}\nconst Wd = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, Xd = {\n  SCALAR: (e, t) => e[t],\n  VEC2: (e, t) => [e[2 * t + 0], e[2 * t + 1]],\n  VEC3: (e, t) => [e[3 * t + 0], e[3 * t + 1], e[3 * t + 2]],\n  VEC4: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],\n  MAT2: (e, t) => [e[4 * t + 0], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]],\n  MAT3: (e, t) => [e[9 * t + 0], e[9 * t + 1], e[9 * t + 2], e[9 * t + 3], e[9 * t + 4], e[9 * t + 5], e[9 * t + 6], e[9 * t + 7], e[9 * t + 8]],\n  MAT4: (e, t) => [e[16 * t + 0], e[16 * t + 1], e[16 * t + 2], e[16 * t + 3], e[16 * t + 4], e[16 * t + 5], e[16 * t + 6], e[16 * t + 7], e[16 * t + 8], e[16 * t + 9], e[16 * t + 10], e[16 * t + 11], e[16 * t + 12], e[16 * t + 13], e[16 * t + 14], e[16 * t + 15]]\n}, Qd = {\n  SCALAR: (e, t, n) => {\n    t[n] = e;\n  },\n  VEC2: (e, t, n) => {\n    t[2 * n + 0] = e[0], t[2 * n + 1] = e[1];\n  },\n  VEC3: (e, t, n) => {\n    t[3 * n + 0] = e[0], t[3 * n + 1] = e[1], t[3 * n + 2] = e[2];\n  },\n  VEC4: (e, t, n) => {\n    t[4 * n + 0] = e[0], t[4 * n + 1] = e[1], t[4 * n + 2] = e[2], t[4 * n + 3] = e[3];\n  },\n  MAT2: (e, t, n) => {\n    t[4 * n + 0] = e[0], t[4 * n + 1] = e[1], t[4 * n + 2] = e[2], t[4 * n + 3] = e[3];\n  },\n  MAT3: (e, t, n) => {\n    t[9 * n + 0] = e[0], t[9 * n + 1] = e[1], t[9 * n + 2] = e[2], t[9 * n + 3] = e[3], t[9 * n + 4] = e[4], t[9 * n + 5] = e[5], t[9 * n + 6] = e[6], t[9 * n + 7] = e[7], t[9 * n + 8] = e[8], t[9 * n + 9] = e[9];\n  },\n  MAT4: (e, t, n) => {\n    t[16 * n + 0] = e[0], t[16 * n + 1] = e[1], t[16 * n + 2] = e[2], t[16 * n + 3] = e[3], t[16 * n + 4] = e[4], t[16 * n + 5] = e[5], t[16 * n + 6] = e[6], t[16 * n + 7] = e[7], t[16 * n + 8] = e[8], t[16 * n + 9] = e[9], t[16 * n + 10] = e[10], t[16 * n + 11] = e[11], t[16 * n + 12] = e[12], t[16 * n + 13] = e[13], t[16 * n + 14] = e[14], t[16 * n + 15] = e[15];\n  }\n};\nfunction qd(e, t, n, s) {\n  const {\n    componentType: r\n  } = e;\n  K(e.componentType);\n  const i = typeof r == \"string\" ? Dt.fromName(r) : r, o = Wd[e.type], a = Xd[e.type], c = Qd[e.type];\n  return n += e.byteOffset, {\n    values: Dt.createTypedArray(i, t, n, o * s),\n    type: i,\n    size: o,\n    unpacker: a,\n    packer: c\n  };\n}\nconst Ot = (e) => e !== void 0;\nfunction Yd(e, t, n) {\n  if (!t)\n    return null;\n  let s = e.getExtension(\"3DTILES_batch_table_hierarchy\");\n  const r = t.HIERARCHY;\n  return r && (console.warn(\"3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.\"), t.extensions = t.extensions || {}, t.extensions[\"3DTILES_batch_table_hierarchy\"] = r, s = r), s ? $d(s, n) : null;\n}\nfunction $d(e, t) {\n  let n, s, r;\n  const i = e.instancesLength, o = e.classes;\n  let a = e.classIds, c = e.parentCounts, u = e.parentIds, l = i;\n  Ot(a.byteOffset) && (a.componentType = defaultValue(a.componentType, GL.UNSIGNED_SHORT), a.type = AttributeType.SCALAR, r = getBinaryAccessor(a), a = r.createArrayBufferView(t.buffer, t.byteOffset + a.byteOffset, i));\n  let h;\n  if (Ot(c))\n    for (Ot(c.byteOffset) && (c.componentType = defaultValue(c.componentType, GL.UNSIGNED_SHORT), c.type = AttributeType.SCALAR, r = getBinaryAccessor(c), c = r.createArrayBufferView(t.buffer, t.byteOffset + c.byteOffset, i)), h = new Uint16Array(i), l = 0, n = 0; n < i; ++n)\n      h[n] = l, l += c[n];\n  Ot(u) && Ot(u.byteOffset) && (u.componentType = defaultValue(u.componentType, GL.UNSIGNED_SHORT), u.type = AttributeType.SCALAR, r = getBinaryAccessor(u), u = r.createArrayBufferView(t.buffer, t.byteOffset + u.byteOffset, l));\n  const f = o.length;\n  for (n = 0; n < f; ++n) {\n    const y = o[n].length, E = o[n].instances, R = getBinaryProperties(y, E, t);\n    o[n].instances = combine(R, E);\n  }\n  const d = new Array(f).fill(0), m = new Uint16Array(i);\n  for (n = 0; n < i; ++n)\n    s = a[n], m[n] = d[s], ++d[s];\n  const g = {\n    classes: o,\n    classIds: a,\n    classIndexes: m,\n    parentCounts: c,\n    parentIndexes: h,\n    parentIds: u\n  };\n  return em(g), g;\n}\nfunction Re(e, t, n) {\n  if (!e)\n    return;\n  const s = e.parentCounts;\n  return e.parentIds ? n(e, t) : s > 0 ? Zd(e, t, n) : tm(e, t, n);\n}\nfunction Zd(e, t, n) {\n  const s = e.classIds, r = e.parentCounts, i = e.parentIds, o = e.parentIndexes, a = s.length, c = scratchVisited;\n  c.length = Math.max(c.length, a);\n  const u = ++marker, l = scratchStack;\n  for (l.length = 0, l.push(t); l.length > 0; ) {\n    if (t = l.pop(), c[t] === u)\n      continue;\n    c[t] = u;\n    const h = n(e, t);\n    if (Ot(h))\n      return h;\n    const f = r[t], d = o[t];\n    for (let m = 0; m < f; ++m) {\n      const g = i[d + m];\n      g !== t && l.push(g);\n    }\n  }\n  return null;\n}\nfunction tm(e, t, n) {\n  let s = !0;\n  for (; s; ) {\n    const r = n(e, t);\n    if (Ot(r))\n      return r;\n    const i = e.parentIds[t];\n    s = i !== t, t = i;\n  }\n  throw new Error(\"traverseHierarchySingleParent\");\n}\nfunction em(e) {\n  const n = e.classIds.length;\n  for (let s = 0; s < n; ++s)\n    Fa(e, s, stack);\n}\nfunction Fa(e, t, n) {\n  const s = e.parentCounts, r = e.parentIds, i = e.parentIndexes, a = e.classIds.length;\n  if (!Ot(r))\n    return;\n  assert(t < a, `Parent index ${t} exceeds the total number of instances: ${a}`), assert(n.indexOf(t) === -1, \"Circular dependency detected in the batch table hierarchy.\"), n.push(t);\n  const c = Ot(s) ? s[t] : 1, u = Ot(s) ? i[t] : t;\n  for (let l = 0; l < c; ++l) {\n    const h = r[u + l];\n    h !== t && Fa(e, h, n);\n  }\n  n.pop(t);\n}\nfunction ut(e) {\n  return e != null;\n}\nconst mn = (e, t) => e, nm = {\n  HIERARCHY: !0,\n  extensions: !0,\n  extras: !0\n};\nclass Da {\n  constructor(t, n, s) {\n    var r;\n    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    this.json = void 0, this.binary = void 0, this.featureCount = void 0, this._extensions = void 0, this._properties = void 0, this._binaryProperties = void 0, this._hierarchy = void 0, K(s >= 0), this.json = t || {}, this.binary = n, this.featureCount = s, this._extensions = ((r = this.json) === null || r === void 0 ? void 0 : r.extensions) || {}, this._properties = {};\n    for (const o in this.json)\n      nm[o] || (this._properties[o] = this.json[o]);\n    this._binaryProperties = this._initializeBinaryProperties(), i[\"3DTILES_batch_table_hierarchy\"] && (this._hierarchy = Yd(this, this.json, this.binary));\n  }\n  getExtension(t) {\n    return this.json && this.json.extensions && this.json.extensions[t];\n  }\n  memorySizeInBytes() {\n    return 0;\n  }\n  isClass(t, n) {\n    if (this._checkBatchId(t), K(typeof n == \"string\", n), this._hierarchy) {\n      const s = Re(this._hierarchy, t, (r, i) => {\n        const o = r.classIds[i];\n        return r.classes[o].name === n;\n      });\n      return ut(s);\n    }\n    return !1;\n  }\n  isExactClass(t, n) {\n    return K(typeof n == \"string\", n), this.getExactClassName(t) === n;\n  }\n  getExactClassName(t) {\n    if (this._checkBatchId(t), this._hierarchy) {\n      const n = this._hierarchy.classIds[t];\n      return this._hierarchy.classes[n].name;\n    }\n  }\n  hasProperty(t, n) {\n    return this._checkBatchId(t), K(typeof n == \"string\", n), ut(this._properties[n]) || this._hasPropertyInHierarchy(t, n);\n  }\n  getPropertyNames(t, n) {\n    this._checkBatchId(t), n = ut(n) ? n : [], n.length = 0;\n    const s = Object.keys(this._properties);\n    return n.push(...s), this._hierarchy && this._getPropertyNamesInHierarchy(t, n), n;\n  }\n  getProperty(t, n) {\n    if (this._checkBatchId(t), K(typeof n == \"string\", n), this._binaryProperties) {\n      const r = this._binaryProperties[n];\n      if (ut(r))\n        return this._getBinaryProperty(r, t);\n    }\n    const s = this._properties[n];\n    if (ut(s))\n      return mn(s[t]);\n    if (this._hierarchy) {\n      const r = this._getHierarchyProperty(t, n);\n      if (ut(r))\n        return r;\n    }\n  }\n  setProperty(t, n, s) {\n    const r = this.featureCount;\n    if (this._checkBatchId(t), K(typeof n == \"string\", n), this._binaryProperties) {\n      const o = this._binaryProperties[n];\n      if (o) {\n        this._setBinaryProperty(o, t, s);\n        return;\n      }\n    }\n    if (this._hierarchy && this._setHierarchyProperty(this, t, n, s))\n      return;\n    let i = this._properties[n];\n    ut(i) || (this._properties[n] = new Array(r), i = this._properties[n]), i[t] = mn(s);\n  }\n  _checkBatchId(t) {\n    if (!(t >= 0 && t < this.featureCount))\n      throw new Error(\"batchId not in range [0, featureCount - 1].\");\n  }\n  _getBinaryProperty(t, n) {\n    return t.unpack(t.typedArray, n);\n  }\n  _setBinaryProperty(t, n, s) {\n    t.pack(s, t.typedArray, n);\n  }\n  _initializeBinaryProperties() {\n    let t = null;\n    for (const n in this._properties) {\n      const s = this._properties[n], r = this._initializeBinaryProperty(n, s);\n      r && (t = t || {}, t[n] = r);\n    }\n    return t;\n  }\n  _initializeBinaryProperty(t, n) {\n    if (\"byteOffset\" in n) {\n      const s = n;\n      K(this.binary, `Property ${t} requires a batch table binary.`), K(s.type, `Property ${t} requires a type.`);\n      const r = qd(s, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n      return {\n        typedArray: r.values,\n        componentCount: r.size,\n        unpack: r.unpacker,\n        pack: r.packer\n      };\n    }\n    return null;\n  }\n  _hasPropertyInHierarchy(t, n) {\n    if (!this._hierarchy)\n      return !1;\n    const s = Re(this._hierarchy, t, (r, i) => {\n      const o = r.classIds[i], a = r.classes[o].instances;\n      return ut(a[n]);\n    });\n    return ut(s);\n  }\n  _getPropertyNamesInHierarchy(t, n) {\n    Re(this._hierarchy, t, (s, r) => {\n      const i = s.classIds[r], o = s.classes[i].instances;\n      for (const a in o)\n        o.hasOwnProperty(a) && n.indexOf(a) === -1 && n.push(a);\n    });\n  }\n  _getHierarchyProperty(t, n) {\n    return Re(this._hierarchy, t, (s, r) => {\n      const i = s.classIds[r], o = s.classes[i], a = s.classIndexes[r], c = o.instances[n];\n      return ut(c) ? ut(c.typedArray) ? this._getBinaryProperty(c, a) : mn(c[a]) : null;\n    });\n  }\n  _setHierarchyProperty(t, n, s, r) {\n    const i = Re(this._hierarchy, n, (o, a) => {\n      const c = o.classIds[a], u = o.classes[c], l = o.classIndexes[a], h = u.instances[s];\n      return ut(h) ? (K(a === n, `Inherited property \"${s}\" is read-only.`), ut(h.typedArray) ? this._setBinaryProperty(h, l, r) : h[l] = mn(r), !0) : !1;\n    });\n    return ut(i);\n  }\n}\nconst Cs = 4;\nfunction qn(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = new DataView(t);\n  if (e.magic = s.getUint32(n, !0), n += Cs, e.version = s.getUint32(n, !0), n += Cs, e.byteLength = s.getUint32(n, !0), n += Cs, e.version !== 1)\n    throw new Error(`3D Tile Version ${e.version} not supported`);\n  return n;\n}\nconst le = 4, Fi = \"b3dm tile in legacy format.\";\nfunction _r(e, t, n) {\n  const s = new DataView(t);\n  let r;\n  e.header = e.header || {};\n  let i = s.getUint32(n, !0);\n  n += le;\n  let o = s.getUint32(n, !0);\n  n += le;\n  let a = s.getUint32(n, !0);\n  n += le;\n  let c = s.getUint32(n, !0);\n  return n += le, a >= 570425344 ? (n -= le * 2, r = i, a = o, c = 0, i = 0, o = 0, console.warn(Fi)) : c >= 570425344 && (n -= le, r = a, a = i, c = o, i = 0, o = 0, console.warn(Fi)), e.header.featureTableJsonByteLength = i, e.header.featureTableBinaryByteLength = o, e.header.batchTableJsonByteLength = a, e.header.batchTableBinaryByteLength = c, e.header.batchLength = r, n;\n}\nfunction wr(e, t, n, s) {\n  return n = sm(e, t, n), n = rm(e, t, n), n;\n}\nfunction sm(e, t, n, s) {\n  const {\n    featureTableJsonByteLength: r,\n    featureTableBinaryByteLength: i,\n    batchLength: o\n  } = e.header || {};\n  if (e.featureTableJson = {\n    BATCH_LENGTH: o || 0\n  }, r && r > 0) {\n    const a = xa(t, n, r);\n    e.featureTableJson = JSON.parse(a);\n  }\n  return n += r || 0, e.featureTableBinary = new Uint8Array(t, n, i), n += i || 0, n;\n}\nfunction rm(e, t, n, s) {\n  const {\n    batchTableJsonByteLength: r,\n    batchTableBinaryByteLength: i\n  } = e.header || {};\n  if (r && r > 0) {\n    const o = xa(t, n, r);\n    e.batchTableJson = JSON.parse(o), n += r, i && i > 0 && (e.batchTableBinary = new Uint8Array(t, n, i), e.batchTableBinary = new Uint8Array(e.batchTableBinary), n += i);\n  }\n  return n;\n}\nfunction La(e, t, n) {\n  if (!t && (!e || !e.batchIds || !n))\n    return null;\n  const {\n    batchIds: s,\n    isRGB565: r,\n    pointCount: i = 0\n  } = e;\n  if (s && n) {\n    const o = new Uint8ClampedArray(i * 3);\n    for (let a = 0; a < i; a++) {\n      const c = s[a], l = n.getProperty(c, \"dimensions\").map((h) => h * 255);\n      o[a * 3] = l[0], o[a * 3 + 1] = l[1], o[a * 3 + 2] = l[2];\n    }\n    return {\n      type: G.UNSIGNED_BYTE,\n      value: o,\n      size: 3,\n      normalized: !0\n    };\n  }\n  if (t && r) {\n    const o = new Uint8ClampedArray(i * 3);\n    for (let a = 0; a < i; a++) {\n      const c = kd(t[a]);\n      o[a * 3] = c[0], o[a * 3 + 1] = c[1], o[a * 3 + 2] = c[2];\n    }\n    return {\n      type: G.UNSIGNED_BYTE,\n      value: o,\n      size: 3,\n      normalized: !0\n    };\n  }\n  return t && t.length === i * 3 ? {\n    type: G.UNSIGNED_BYTE,\n    value: t,\n    size: 3,\n    normalized: !0\n  } : {\n    type: G.UNSIGNED_BYTE,\n    value: t || new Uint8ClampedArray(),\n    size: 4,\n    normalized: !0\n  };\n}\nconst Di = new A();\nfunction im(e, t) {\n  if (!t)\n    return null;\n  if (e.isOctEncoded16P) {\n    const n = new Float32Array((e.pointsLength || 0) * 3);\n    for (let s = 0; s < (e.pointsLength || 0); s++)\n      zd(t[s * 2], t[s * 2 + 1], Di), Di.toArray(n, s * 3);\n    return {\n      type: G.FLOAT,\n      size: 2,\n      value: n\n    };\n  }\n  return {\n    type: G.FLOAT,\n    size: 2,\n    value: t\n  };\n}\nfunction om(e, t, n) {\n  return e.isQuantized ? n[\"3d-tiles\"] && n[\"3d-tiles\"].decodeQuantizedPositions ? (e.isQuantized = !1, am(e, t)) : {\n    type: G.UNSIGNED_SHORT,\n    value: t,\n    size: 3,\n    normalized: !0\n  } : t;\n}\nfunction am(e, t) {\n  const n = new A(), s = new Float32Array(e.pointCount * 3);\n  for (let r = 0; r < e.pointCount; r++)\n    n.set(t[r * 3], t[r * 3 + 1], t[r * 3 + 2]).scale(1 / e.quantizedRange).multiply(e.quantizedVolumeScale).add(e.quantizedVolumeOffset).toArray(s, r * 3);\n  return s;\n}\nasync function cm(e, t, n, s, r) {\n  n = qn(e, t, n), n = _r(e, t, n), n = wr(e, t, n), um(e);\n  const {\n    featureTable: i,\n    batchTable: o\n  } = lm(e);\n  return await gm(e, i, o, s, r), hm(e, i, s), fm(e, i, o), dm(e, i), n;\n}\nfunction um(e) {\n  e.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, e.isQuantized = !1, e.isTranslucent = !1, e.isRGB565 = !1, e.isOctEncoded16P = !1;\n}\nfunction lm(e) {\n  const t = new br(e.featureTableJson, e.featureTableBinary), n = t.getGlobalProperty(\"POINTS_LENGTH\");\n  if (!Number.isFinite(n))\n    throw new Error(\"POINTS_LENGTH must be defined\");\n  t.featuresLength = n, e.featuresLength = n, e.pointsLength = n, e.pointCount = n, e.rtcCenter = t.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3);\n  const s = mm(e, t);\n  return {\n    featureTable: t,\n    batchTable: s\n  };\n}\nfunction hm(e, t, n) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.positions) {\n    if (t.hasProperty(\"POSITION\"))\n      e.attributes.positions = t.getPropertyArray(\"POSITION\", G.FLOAT, 3);\n    else if (t.hasProperty(\"POSITION_QUANTIZED\")) {\n      const s = t.getPropertyArray(\"POSITION_QUANTIZED\", G.UNSIGNED_SHORT, 3);\n      if (e.isQuantized = !0, e.quantizedRange = 65535, e.quantizedVolumeScale = t.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", G.FLOAT, 3), !e.quantizedVolumeScale)\n        throw new Error(\"QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      if (e.quantizedVolumeOffset = t.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", G.FLOAT, 3), !e.quantizedVolumeOffset)\n        throw new Error(\"QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      e.attributes.positions = om(e, s, n);\n    }\n  }\n  if (!e.attributes.positions)\n    throw new Error(\"Either POSITION or POSITION_QUANTIZED must be defined.\");\n}\nfunction fm(e, t, n) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.colors) {\n    let s = null;\n    t.hasProperty(\"RGBA\") ? (s = t.getPropertyArray(\"RGBA\", G.UNSIGNED_BYTE, 4), e.isTranslucent = !0) : t.hasProperty(\"RGB\") ? s = t.getPropertyArray(\"RGB\", G.UNSIGNED_BYTE, 3) : t.hasProperty(\"RGB565\") && (s = t.getPropertyArray(\"RGB565\", G.UNSIGNED_SHORT, 1), e.isRGB565 = !0), e.attributes.colors = La(e, s, n);\n  }\n  t.hasProperty(\"CONSTANT_RGBA\") && (e.constantRGBA = t.getGlobalProperty(\"CONSTANT_RGBA\", G.UNSIGNED_BYTE, 4));\n}\nfunction dm(e, t) {\n  if (e.attributes = e.attributes || {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  }, !e.attributes.normals) {\n    let n = null;\n    t.hasProperty(\"NORMAL\") ? n = t.getPropertyArray(\"NORMAL\", G.FLOAT, 3) : t.hasProperty(\"NORMAL_OCT16P\") && (n = t.getPropertyArray(\"NORMAL_OCT16P\", G.UNSIGNED_BYTE, 2), e.isOctEncoded16P = !0), e.attributes.normals = im(e, n);\n  }\n}\nfunction mm(e, t) {\n  let n = null;\n  if (!e.batchIds && t.hasProperty(\"BATCH_ID\") && (e.batchIds = t.getPropertyArray(\"BATCH_ID\", G.UNSIGNED_SHORT, 1), e.batchIds)) {\n    const s = t.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!s)\n      throw new Error(\"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\");\n    const {\n      batchTableJson: r,\n      batchTableBinary: i\n    } = e;\n    n = new Da(r, i, s);\n  }\n  return n;\n}\nasync function gm(e, t, n, s, r) {\n  let i, o, a;\n  const c = e.batchTableJson && e.batchTableJson.extensions && e.batchTableJson.extensions[\"3DTILES_draco_point_compression\"];\n  c && (a = c.properties);\n  const u = t.getExtension(\"3DTILES_draco_point_compression\");\n  if (u) {\n    o = u.properties;\n    const h = u.byteOffset, f = u.byteLength;\n    if (!o || !Number.isFinite(h) || !f)\n      throw new Error(\"Draco properties, byteOffset, and byteLength must be defined\");\n    i = (e.featureTableBinary || []).slice(h, h + f), e.hasPositions = Number.isFinite(o.POSITION), e.hasColors = Number.isFinite(o.RGB) || Number.isFinite(o.RGBA), e.hasNormals = Number.isFinite(o.NORMAL), e.hasBatchIds = Number.isFinite(o.BATCH_ID), e.isTranslucent = Number.isFinite(o.RGBA);\n  }\n  if (!i)\n    return !0;\n  const l = {\n    buffer: i,\n    properties: {\n      ...o,\n      ...a\n    },\n    featureTableProperties: o,\n    batchTableProperties: a,\n    dequantizeInShader: !1\n  };\n  return await Am(e, l, s, r);\n}\nasync function Am(e, t, n, s) {\n  if (!s)\n    return;\n  const r = {\n    ...n,\n    draco: {\n      ...n == null ? void 0 : n.draco,\n      extraAttributes: t.batchTableProperties || {}\n    }\n  };\n  delete r[\"3d-tiles\"];\n  const i = await Ke(t.buffer, Oa, r, s), o = i.attributes.POSITION && i.attributes.POSITION.value, a = i.attributes.COLOR_0 && i.attributes.COLOR_0.value, c = i.attributes.NORMAL && i.attributes.NORMAL.value, u = i.attributes.BATCH_ID && i.attributes.BATCH_ID.value, l = o && i.attributes.POSITION.value.quantization, h = c && i.attributes.NORMAL.value.quantization;\n  if (l) {\n    const d = i.POSITION.data.quantization, m = d.range;\n    e.quantizedVolumeScale = new A(m, m, m), e.quantizedVolumeOffset = new A(d.minValues), e.quantizedRange = (1 << d.quantizationBits) - 1, e.isQuantizedDraco = !0;\n  }\n  h && (e.octEncodedRange = (1 << i.NORMAL.data.quantization.quantizationBits) - 1, e.isOctEncodedDraco = !0);\n  const f = {};\n  if (t.batchTableProperties)\n    for (const d of Object.keys(t.batchTableProperties))\n      i.attributes[d] && i.attributes[d].value && (f[d.toLowerCase()] = i.attributes[d].value);\n  e.attributes = {\n    positions: o,\n    colors: La(e, a, void 0),\n    normals: c,\n    batchIds: u,\n    ...f\n  };\n}\nconst pm = \"4.1.1\";\nvar Es;\nconst ym = (Es = globalThis.loaders) === null || Es === void 0 ? void 0 : Es.parseImageNode, Xs = typeof Image < \"u\", Qs = typeof ImageBitmap < \"u\", Bm = !!ym, qs = kn ? !0 : Bm;\nfunction Cm(e) {\n  switch (e) {\n    case \"auto\":\n      return Qs || Xs || qs;\n    case \"imagebitmap\":\n      return Qs;\n    case \"image\":\n      return Xs;\n    case \"data\":\n      return qs;\n    default:\n      throw new Error(`@loaders.gl/images: image ${e} not supported in this environment`);\n  }\n}\nfunction Em() {\n  if (Qs)\n    return \"imagebitmap\";\n  if (Xs)\n    return \"image\";\n  if (qs)\n    return \"data\";\n  throw new Error(\"Install '@loaders.gl/polyfills' to parse images under Node.js\");\n}\nfunction Tm(e) {\n  const t = bm(e);\n  if (!t)\n    throw new Error(\"Not an image\");\n  return t;\n}\nfunction Pa(e) {\n  switch (Tm(e)) {\n    case \"data\":\n      return e;\n    case \"image\":\n    case \"imagebitmap\":\n      const t = document.createElement(\"canvas\"), n = t.getContext(\"2d\");\n      if (!n)\n        throw new Error(\"getImageData\");\n      return t.width = e.width, t.height = e.height, n.drawImage(e, 0, 0), n.getImageData(0, 0, e.width, e.height);\n    default:\n      throw new Error(\"getImageData\");\n  }\n}\nfunction bm(e) {\n  return typeof ImageBitmap < \"u\" && e instanceof ImageBitmap ? \"imagebitmap\" : typeof Image < \"u\" && e instanceof Image ? \"image\" : e && typeof e == \"object\" && e.data && e.width && e.height ? \"data\" : null;\n}\nconst _m = /^data:image\\/svg\\+xml/, wm = /\\.svg((\\?|#).*)?$/;\nfunction Rr(e) {\n  return e && (_m.test(e) || wm.test(e));\n}\nfunction Rm(e, t) {\n  if (Rr(t)) {\n    let s = new TextDecoder().decode(e);\n    try {\n      typeof unescape == \"function\" && typeof encodeURIComponent == \"function\" && (s = unescape(encodeURIComponent(s)));\n    } catch (i) {\n      throw new Error(i.message);\n    }\n    return `data:image/svg+xml;base64,${btoa(s)}`;\n  }\n  return Ga(e, t);\n}\nfunction Ga(e, t) {\n  if (Rr(t))\n    throw new Error(\"SVG cannot be parsed directly to imagebitmap\");\n  return new Blob([new Uint8Array(e)]);\n}\nasync function Na(e, t, n) {\n  const s = Rm(e, n), r = self.URL || self.webkitURL, i = typeof s != \"string\" && r.createObjectURL(s);\n  try {\n    return await Mm(i || s, t);\n  } finally {\n    i && r.revokeObjectURL(i);\n  }\n}\nasync function Mm(e, t) {\n  const n = new Image();\n  return n.src = e, t.image && t.image.decode && n.decode ? (await n.decode(), n) : await new Promise((s, r) => {\n    try {\n      n.onload = () => s(n), n.onerror = (i) => {\n        const o = i instanceof Error ? i.message : \"error\";\n        r(new Error(o));\n      };\n    } catch (i) {\n      r(i);\n    }\n  });\n}\nconst Sm = {};\nlet Li = !0;\nasync function Im(e, t, n) {\n  let s;\n  Rr(n) ? s = await Na(e, t, n) : s = Ga(e, n);\n  const r = t && t.imagebitmap;\n  return await xm(s, r);\n}\nasync function xm(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;\n  if ((vm(t) || !Li) && (t = null), t)\n    try {\n      return await createImageBitmap(e, t);\n    } catch (n) {\n      console.warn(n), Li = !1;\n    }\n  return await createImageBitmap(e);\n}\nfunction vm(e) {\n  for (const t in e || Sm)\n    return !1;\n  return !0;\n}\nfunction Om(e) {\n  return !Pm(e, \"ftyp\", 4) || !(e[8] & 96) ? null : Fm(e);\n}\nfunction Fm(e) {\n  switch (Dm(e, 8, 12).replace(\"\\0\", \" \").trim()) {\n    case \"avif\":\n    case \"avis\":\n      return {\n        extension: \"avif\",\n        mimeType: \"image/avif\"\n      };\n    default:\n      return null;\n  }\n}\nfunction Dm(e, t, n) {\n  return String.fromCharCode(...e.slice(t, n));\n}\nfunction Lm(e) {\n  return [...e].map((t) => t.charCodeAt(0));\n}\nfunction Pm(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = Lm(t);\n  for (let r = 0; r < s.length; ++r)\n    if (s[r] !== e[r + n])\n      return !1;\n  return !0;\n}\nconst Ft = !1, De = !0;\nfunction Mr(e) {\n  const t = Ye(e);\n  return Nm(t) || Jm(t) || Um(t) || Hm(t) || Gm(t);\n}\nfunction Gm(e) {\n  const t = new Uint8Array(e instanceof DataView ? e.buffer : e), n = Om(t);\n  return n ? {\n    mimeType: n.mimeType,\n    width: 0,\n    height: 0\n  } : null;\n}\nfunction Nm(e) {\n  const t = Ye(e);\n  return t.byteLength >= 24 && t.getUint32(0, Ft) === 2303741511 ? {\n    mimeType: \"image/png\",\n    width: t.getUint32(16, Ft),\n    height: t.getUint32(20, Ft)\n  } : null;\n}\nfunction Um(e) {\n  const t = Ye(e);\n  return t.byteLength >= 10 && t.getUint32(0, Ft) === 1195984440 ? {\n    mimeType: \"image/gif\",\n    width: t.getUint16(6, De),\n    height: t.getUint16(8, De)\n  } : null;\n}\nfunction Hm(e) {\n  const t = Ye(e);\n  return t.byteLength >= 14 && t.getUint16(0, Ft) === 16973 && t.getUint32(2, De) === t.byteLength ? {\n    mimeType: \"image/bmp\",\n    width: t.getUint32(18, De),\n    height: t.getUint32(22, De)\n  } : null;\n}\nfunction Jm(e) {\n  const t = Ye(e);\n  if (!(t.byteLength >= 3 && t.getUint16(0, Ft) === 65496 && t.getUint8(2) === 255))\n    return null;\n  const {\n    tableMarkers: s,\n    sofMarkers: r\n  } = Vm();\n  let i = 2;\n  for (; i + 9 < t.byteLength; ) {\n    const o = t.getUint16(i, Ft);\n    if (r.has(o))\n      return {\n        mimeType: \"image/jpeg\",\n        height: t.getUint16(i + 5, Ft),\n        width: t.getUint16(i + 7, Ft)\n      };\n    if (!s.has(o))\n      return null;\n    i += 2, i += t.getUint16(i, Ft);\n  }\n  return null;\n}\nfunction Vm() {\n  const e = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);\n  for (let n = 65504; n < 65520; ++n)\n    e.add(n);\n  return {\n    tableMarkers: e,\n    sofMarkers: /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])\n  };\n}\nfunction Ye(e) {\n  if (e instanceof DataView)\n    return e;\n  if (ArrayBuffer.isView(e))\n    return new DataView(e.buffer);\n  if (e instanceof ArrayBuffer)\n    return new DataView(e);\n  throw new Error(\"toDataView\");\n}\nasync function jm(e, t) {\n  var n;\n  const {\n    mimeType: s\n  } = Mr(e) || {}, r = (n = globalThis.loaders) === null || n === void 0 ? void 0 : n.parseImageNode;\n  return K(r), await r(e, s);\n}\nasync function km(e, t, n) {\n  t = t || {};\n  const r = (t.image || {}).type || \"auto\", {\n    url: i\n  } = n || {}, o = Km(r);\n  let a;\n  switch (o) {\n    case \"imagebitmap\":\n      a = await Im(e, t, i);\n      break;\n    case \"image\":\n      a = await Na(e, t, i);\n      break;\n    case \"data\":\n      a = await jm(e);\n      break;\n    default:\n      K(!1);\n  }\n  return r === \"data\" && (a = Pa(a)), a;\n}\nfunction Km(e) {\n  switch (e) {\n    case \"auto\":\n    case \"data\":\n      return Em();\n    default:\n      return Cm(e), e;\n  }\n}\nconst zm = [\"png\", \"jpg\", \"jpeg\", \"gif\", \"webp\", \"bmp\", \"ico\", \"svg\", \"avif\"], Wm = [\"image/png\", \"image/jpeg\", \"image/gif\", \"image/webp\", \"image/avif\", \"image/bmp\", \"image/vnd.microsoft.icon\", \"image/svg+xml\"], Xm = {\n  image: {\n    type: \"auto\",\n    decode: !0\n  }\n}, Qm = {\n  id: \"image\",\n  module: \"images\",\n  name: \"Images\",\n  version: pm,\n  mimeTypes: Wm,\n  extensions: zm,\n  parse: km,\n  tests: [(e) => !!Mr(new DataView(e))],\n  options: Xm\n}, Ts = {};\nfunction qm(e) {\n  if (Ts[e] === void 0) {\n    const t = kn ? $m(e) : Ym(e);\n    Ts[e] = t;\n  }\n  return Ts[e];\n}\nfunction Ym(e) {\n  var t, n;\n  const s = [\"image/png\", \"image/jpeg\", \"image/gif\"], r = ((t = globalThis.loaders) === null || t === void 0 ? void 0 : t.imageFormatsNode) || s;\n  return !!((n = globalThis.loaders) === null || n === void 0 ? void 0 : n.parseImageNode) && r.includes(e);\n}\nfunction $m(e) {\n  switch (e) {\n    case \"image/avif\":\n    case \"image/webp\":\n      return Zm(e);\n    default:\n      return !0;\n  }\n}\nfunction Zm(e) {\n  try {\n    return document.createElement(\"canvas\").toDataURL(e).indexOf(`data:${e}`) === 0;\n  } catch {\n    return !1;\n  }\n}\nfunction yt(e, t) {\n  if (!e)\n    throw new Error(t || \"assert failed: gltf\");\n}\nconst Ua = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, Ha = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n}, tg = 1.33, Pi = [\"SCALAR\", \"VEC2\", \"VEC3\", \"VEC4\"], eg = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]], ng = new Map(eg), sg = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, rg = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n}, ig = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nfunction Ja(e) {\n  return Pi[e - 1] || Pi[0];\n}\nfunction Sr(e) {\n  const t = ng.get(e.constructor);\n  if (!t)\n    throw new Error(\"Illegal typed array\");\n  return t;\n}\nfunction Ir(e, t) {\n  const n = ig[e.componentType], s = sg[e.type], r = rg[e.componentType], i = e.count * s, o = e.count * s * r;\n  yt(o >= 0 && o <= t.byteLength);\n  const a = Ha[e.componentType], c = Ua[e.type];\n  return {\n    ArrayType: n,\n    length: i,\n    byteLength: o,\n    componentByteSize: a,\n    numberOfComponentsInElement: c\n  };\n}\nfunction Va(e) {\n  let {\n    images: t,\n    bufferViews: n\n  } = e;\n  t = t || [], n = n || [];\n  const s = t.map((o) => o.bufferView);\n  n = n.filter((o) => !s.includes(o));\n  const r = n.reduce((o, a) => o + a.byteLength, 0), i = t.reduce((o, a) => {\n    const {\n      width: c,\n      height: u\n    } = a.image;\n    return o + c * u;\n  }, 0);\n  return r + Math.ceil(4 * i * tg);\n}\nfunction og(e, t, n) {\n  const s = e.bufferViews[n];\n  yt(s);\n  const r = s.buffer, i = t[r];\n  yt(i);\n  const o = (s.byteOffset || 0) + i.byteOffset;\n  return new Uint8Array(i.arrayBuffer, o, s.byteLength);\n}\nfunction ag(e, t, n) {\n  var s, r;\n  const i = typeof n == \"number\" ? (s = e.accessors) === null || s === void 0 ? void 0 : s[n] : n;\n  if (!i)\n    throw new Error(`No gltf accessor ${JSON.stringify(n)}`);\n  const o = (r = e.bufferViews) === null || r === void 0 ? void 0 : r[i.bufferView || 0];\n  if (!o)\n    throw new Error(`No gltf buffer view for accessor ${o}`);\n  const {\n    arrayBuffer: a,\n    byteOffset: c\n  } = t[o.buffer], u = (c || 0) + (i.byteOffset || 0) + (o.byteOffset || 0), {\n    ArrayType: l,\n    length: h,\n    componentByteSize: f,\n    numberOfComponentsInElement: d\n  } = Ir(i, o), m = f * d, g = o.byteStride || m;\n  if (typeof o.byteStride > \"u\" || o.byteStride === m)\n    return new l(a, u, h);\n  const y = new l(h);\n  for (let E = 0; E < i.count; E++) {\n    const R = new l(a, u + E * g, d);\n    y.set(R, E * d);\n  }\n  return y;\n}\nfunction cg() {\n  return {\n    asset: {\n      version: \"2.0\",\n      generator: \"loaders.gl\"\n    },\n    buffers: [],\n    extensions: {},\n    extensionsRequired: [],\n    extensionsUsed: []\n  };\n}\nclass it {\n  constructor(t) {\n    this.gltf = void 0, this.sourceBuffers = void 0, this.byteLength = void 0, this.gltf = {\n      json: (t == null ? void 0 : t.json) || cg(),\n      buffers: (t == null ? void 0 : t.buffers) || [],\n      images: (t == null ? void 0 : t.images) || []\n    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);\n  }\n  get json() {\n    return this.gltf.json;\n  }\n  getApplicationData(t) {\n    return this.json[t];\n  }\n  getExtraData(t) {\n    return (this.json.extras || {})[t];\n  }\n  hasExtension(t) {\n    const n = this.getUsedExtensions().find((r) => r === t), s = this.getRequiredExtensions().find((r) => r === t);\n    return typeof n == \"string\" || typeof s == \"string\";\n  }\n  getExtension(t) {\n    const n = this.getUsedExtensions().find((r) => r === t), s = this.json.extensions || {};\n    return n ? s[t] : null;\n  }\n  getRequiredExtension(t) {\n    return this.getRequiredExtensions().find((s) => s === t) ? this.getExtension(t) : null;\n  }\n  getRequiredExtensions() {\n    return this.json.extensionsRequired || [];\n  }\n  getUsedExtensions() {\n    return this.json.extensionsUsed || [];\n  }\n  getRemovedExtensions() {\n    return this.json.extensionsRemoved || [];\n  }\n  getObjectExtension(t, n) {\n    return (t.extensions || {})[n];\n  }\n  getScene(t) {\n    return this.getObject(\"scenes\", t);\n  }\n  getNode(t) {\n    return this.getObject(\"nodes\", t);\n  }\n  getSkin(t) {\n    return this.getObject(\"skins\", t);\n  }\n  getMesh(t) {\n    return this.getObject(\"meshes\", t);\n  }\n  getMaterial(t) {\n    return this.getObject(\"materials\", t);\n  }\n  getAccessor(t) {\n    return this.getObject(\"accessors\", t);\n  }\n  getTexture(t) {\n    return this.getObject(\"textures\", t);\n  }\n  getSampler(t) {\n    return this.getObject(\"samplers\", t);\n  }\n  getImage(t) {\n    return this.getObject(\"images\", t);\n  }\n  getBufferView(t) {\n    return this.getObject(\"bufferViews\", t);\n  }\n  getBuffer(t) {\n    return this.getObject(\"buffers\", t);\n  }\n  getObject(t, n) {\n    if (typeof n == \"object\")\n      return n;\n    const s = this.json[t] && this.json[t][n];\n    if (!s)\n      throw new Error(`glTF file error: Could not find ${t}[${n}]`);\n    return s;\n  }\n  getTypedArrayForBufferView(t) {\n    t = this.getBufferView(t);\n    const n = t.buffer, s = this.gltf.buffers[n];\n    yt(s);\n    const r = (t.byteOffset || 0) + s.byteOffset;\n    return new Uint8Array(s.arrayBuffer, r, t.byteLength);\n  }\n  getTypedArrayForAccessor(t) {\n    const n = this.getAccessor(t);\n    return ag(this.gltf.json, this.gltf.buffers, n);\n  }\n  getTypedArrayForImageData(t) {\n    t = this.getAccessor(t);\n    const n = this.getBufferView(t.bufferView), r = this.getBuffer(n.buffer).data, i = n.byteOffset || 0;\n    return new Uint8Array(r, i, n.byteLength);\n  }\n  addApplicationData(t, n) {\n    return this.json[t] = n, this;\n  }\n  addExtraData(t, n) {\n    return this.json.extras = this.json.extras || {}, this.json.extras[t] = n, this;\n  }\n  addObjectExtension(t, n, s) {\n    return t.extensions = t.extensions || {}, t.extensions[n] = s, this.registerUsedExtension(n), this;\n  }\n  setObjectExtension(t, n, s) {\n    const r = t.extensions || {};\n    r[n] = s;\n  }\n  removeObjectExtension(t, n) {\n    const s = (t == null ? void 0 : t.extensions) || {};\n    if (s[n]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const r = this.json.extensionsRemoved;\n      r.includes(n) || r.push(n);\n    }\n    delete s[n];\n  }\n  addExtension(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return yt(n), this.json.extensions = this.json.extensions || {}, this.json.extensions[t] = n, this.registerUsedExtension(t), n;\n  }\n  addRequiredExtension(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return yt(n), this.addExtension(t, n), this.registerRequiredExtension(t), n;\n  }\n  registerUsedExtension(t) {\n    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((n) => n === t) || this.json.extensionsUsed.push(t);\n  }\n  registerRequiredExtension(t) {\n    this.registerUsedExtension(t), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((n) => n === t) || this.json.extensionsRequired.push(t);\n  }\n  removeExtension(t) {\n    var n;\n    if ((n = this.json.extensions) !== null && n !== void 0 && n[t]) {\n      this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n      const s = this.json.extensionsRemoved;\n      s.includes(t) || s.push(t);\n    }\n    this.json.extensions && delete this.json.extensions[t], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, t), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, t);\n  }\n  setDefaultScene(t) {\n    this.json.scene = t;\n  }\n  addScene(t) {\n    const {\n      nodeIndices: n\n    } = t;\n    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({\n      nodes: n\n    }), this.json.scenes.length - 1;\n  }\n  addNode(t) {\n    const {\n      meshIndex: n,\n      matrix: s\n    } = t;\n    this.json.nodes = this.json.nodes || [];\n    const r = {\n      mesh: n\n    };\n    return s && (r.matrix = s), this.json.nodes.push(r), this.json.nodes.length - 1;\n  }\n  addMesh(t) {\n    const {\n      attributes: n,\n      indices: s,\n      material: r,\n      mode: i = 4\n    } = t, a = {\n      primitives: [{\n        attributes: this._addAttributes(n),\n        mode: i\n      }]\n    };\n    if (s) {\n      const c = this._addIndices(s);\n      a.primitives[0].indices = c;\n    }\n    return Number.isFinite(r) && (a.primitives[0].material = r), this.json.meshes = this.json.meshes || [], this.json.meshes.push(a), this.json.meshes.length - 1;\n  }\n  addPointCloud(t) {\n    const s = {\n      primitives: [{\n        attributes: this._addAttributes(t),\n        mode: 0\n      }]\n    };\n    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(s), this.json.meshes.length - 1;\n  }\n  addImage(t, n) {\n    const s = Mr(t), r = n || (s == null ? void 0 : s.mimeType), o = {\n      bufferView: this.addBufferView(t),\n      mimeType: r\n    };\n    return this.json.images = this.json.images || [], this.json.images.push(o), this.json.images.length - 1;\n  }\n  addBufferView(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.byteLength;\n    const r = t.byteLength;\n    yt(Number.isFinite(r)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(t);\n    const i = {\n      buffer: n,\n      byteOffset: s,\n      byteLength: r\n    };\n    return this.byteLength += ze(r, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(i), this.json.bufferViews.length - 1;\n  }\n  addAccessor(t, n) {\n    const s = {\n      bufferView: t,\n      type: Ja(n.size),\n      componentType: n.componentType,\n      count: n.count,\n      max: n.max,\n      min: n.min\n    };\n    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(s), this.json.accessors.length - 1;\n  }\n  addBinaryBuffer(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n      size: 3\n    };\n    const s = this.addBufferView(t);\n    let r = {\n      min: n.min,\n      max: n.max\n    };\n    (!r.min || !r.max) && (r = this._getAccessorMinMax(t, n.size));\n    const i = {\n      size: n.size,\n      componentType: Sr(t),\n      count: Math.round(t.length / n.size),\n      min: r.min,\n      max: r.max\n    };\n    return this.addAccessor(s, Object.assign(i, n));\n  }\n  addTexture(t) {\n    const {\n      imageIndex: n\n    } = t, s = {\n      source: n\n    };\n    return this.json.textures = this.json.textures || [], this.json.textures.push(s), this.json.textures.length - 1;\n  }\n  addMaterial(t) {\n    return this.json.materials = this.json.materials || [], this.json.materials.push(t), this.json.materials.length - 1;\n  }\n  createBinaryChunk() {\n    var t, n;\n    this.gltf.buffers = [];\n    const s = this.byteLength, r = new ArrayBuffer(s), i = new Uint8Array(r);\n    let o = 0;\n    for (const a of this.sourceBuffers || [])\n      o = Du(a, i, o);\n    (t = this.json) !== null && t !== void 0 && (n = t.buffers) !== null && n !== void 0 && n[0] ? this.json.buffers[0].byteLength = s : this.json.buffers = [{\n      byteLength: s\n    }], this.gltf.binary = r, this.sourceBuffers = [r];\n  }\n  _removeStringFromArray(t, n) {\n    let s = !0;\n    for (; s; ) {\n      const r = t.indexOf(n);\n      r > -1 ? t.splice(r, 1) : s = !1;\n    }\n  }\n  _addAttributes() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const n = {};\n    for (const s in t) {\n      const r = t[s], i = this._getGltfAttributeName(s), o = this.addBinaryBuffer(r.value, r);\n      n[i] = o;\n    }\n    return n;\n  }\n  _addIndices(t) {\n    return this.addBinaryBuffer(t, {\n      size: 1\n    });\n  }\n  _getGltfAttributeName(t) {\n    switch (t.toLowerCase()) {\n      case \"position\":\n      case \"positions\":\n      case \"vertices\":\n        return \"POSITION\";\n      case \"normal\":\n      case \"normals\":\n        return \"NORMAL\";\n      case \"color\":\n      case \"colors\":\n        return \"COLOR_0\";\n      case \"texcoord\":\n      case \"texcoords\":\n        return \"TEXCOORD_0\";\n      default:\n        return t;\n    }\n  }\n  _getAccessorMinMax(t, n) {\n    const s = {\n      min: null,\n      max: null\n    };\n    if (t.length < n)\n      return s;\n    s.min = [], s.max = [];\n    const r = t.subarray(0, n);\n    for (const i of r)\n      s.min.push(i), s.max.push(i);\n    for (let i = n; i < t.length; i += n)\n      for (let o = 0; o < n; o++)\n        s.min[0 + o] = Math.min(s.min[0 + o], t[i + o]), s.max[0 + o] = Math.max(s.max[0 + o], t[i + o]);\n    return s;\n  }\n}\nfunction Gi(e) {\n  return (e % 1 + 1) % 1;\n}\nconst ja = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n  BOOLEAN: 1,\n  STRING: 1,\n  ENUM: 1\n}, ug = {\n  INT8: Int8Array,\n  UINT8: Uint8Array,\n  INT16: Int16Array,\n  UINT16: Uint16Array,\n  INT32: Int32Array,\n  UINT32: Uint32Array,\n  INT64: BigInt64Array,\n  UINT64: BigUint64Array,\n  FLOAT32: Float32Array,\n  FLOAT64: Float64Array\n}, ka = {\n  INT8: 1,\n  UINT8: 1,\n  INT16: 2,\n  UINT16: 2,\n  INT32: 4,\n  UINT32: 4,\n  INT64: 8,\n  UINT64: 8,\n  FLOAT32: 4,\n  FLOAT64: 8\n};\nfunction xr(e, t) {\n  return ka[t] * ja[e];\n}\nfunction Yn(e, t, n, s) {\n  if (n !== \"UINT8\" && n !== \"UINT16\" && n !== \"UINT32\" && n !== \"UINT64\")\n    return null;\n  const r = e.getTypedArrayForBufferView(t), i = $n(r, \"SCALAR\", n, s + 1);\n  return i instanceof BigInt64Array || i instanceof BigUint64Array ? null : i;\n}\nfunction $n(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n  const r = ja[t], i = ug[n], o = ka[n], a = s * r, c = a * o;\n  let u = e.buffer, l = e.byteOffset;\n  return l % o !== 0 && (u = new Uint8Array(u).slice(l, l + c).buffer, l = 0), new i(u, l, a);\n}\nfunction vr(e, t, n) {\n  var s, r;\n  const i = `TEXCOORD_${t.texCoord || 0}`, o = n.attributes[i], a = e.getTypedArrayForAccessor(o), c = e.gltf.json, u = t.index, l = (s = c.textures) === null || s === void 0 || (r = s[u]) === null || r === void 0 ? void 0 : r.source;\n  if (typeof l < \"u\") {\n    var h, f, d;\n    const m = (h = c.images) === null || h === void 0 || (f = h[l]) === null || f === void 0 ? void 0 : f.mimeType, g = (d = e.gltf.images) === null || d === void 0 ? void 0 : d[l];\n    if (g && typeof g.width < \"u\") {\n      const y = [];\n      for (let E = 0; E < a.length; E += 2) {\n        const R = lg(g, m, a, E, t.channels);\n        y.push(R);\n      }\n      return y;\n    }\n  }\n  return [];\n}\nfunction Ka(e, t, n, s, r) {\n  if (!(n != null && n.length))\n    return;\n  const i = [];\n  for (const l of n) {\n    let h = s.findIndex((f) => f === l);\n    h === -1 && (h = s.push(l) - 1), i.push(h);\n  }\n  const o = new Uint32Array(i), a = e.gltf.buffers.push({\n    arrayBuffer: o.buffer,\n    byteOffset: o.byteOffset,\n    byteLength: o.byteLength\n  }) - 1, c = e.addBufferView(o, a, 0), u = e.addAccessor(c, {\n    size: 1,\n    componentType: Sr(o),\n    count: o.length\n  });\n  r.attributes[t] = u;\n}\nfunction lg(e, t, n, s) {\n  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];\n  const i = {\n    r: {\n      offset: 0,\n      shift: 0\n    },\n    g: {\n      offset: 1,\n      shift: 8\n    },\n    b: {\n      offset: 2,\n      shift: 16\n    },\n    a: {\n      offset: 3,\n      shift: 24\n    }\n  }, o = n[s], a = n[s + 1];\n  let c = 1;\n  t && (t.indexOf(\"image/jpeg\") !== -1 || t.indexOf(\"image/png\") !== -1) && (c = 4);\n  const u = hg(o, a, e, c);\n  let l = 0;\n  for (const h of r) {\n    const f = typeof h == \"number\" ? Object.values(i)[h] : i[h], d = u + f.offset, m = Pa(e);\n    if (m.data.length <= d)\n      throw new Error(`${m.data.length} <= ${d}`);\n    const g = m.data[d];\n    l |= g << f.shift;\n  }\n  return l;\n}\nfunction hg(e, t, n) {\n  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n  const r = n.width, i = Gi(e) * (r - 1), o = Math.round(i), a = n.height, c = Gi(t) * (a - 1), u = Math.round(c), l = n.components ? n.components : s;\n  return (u * r + o) * l;\n}\nfunction za(e, t, n, s, r) {\n  const i = [];\n  for (let o = 0; o < t; o++) {\n    const a = n[o], c = n[o + 1] - n[o];\n    if (c + a > s)\n      break;\n    const u = a / r, l = c / r;\n    i.push(e.slice(u, u + l));\n  }\n  return i;\n}\nfunction Wa(e, t, n) {\n  const s = [];\n  for (let r = 0; r < t; r++) {\n    const i = r * n;\n    s.push(e.slice(i, i + n));\n  }\n  return s;\n}\nfunction Xa(e, t, n, s) {\n  if (n)\n    throw new Error(\"Not implemented - arrayOffsets for strings is specified\");\n  if (s) {\n    const r = [], i = new TextDecoder(\"utf8\");\n    let o = 0;\n    for (let a = 0; a < e; a++) {\n      const c = s[a + 1] - s[a];\n      if (c + o <= t.length) {\n        const u = t.subarray(o, c + o), l = i.decode(u);\n        r.push(l), o += c;\n      }\n    }\n    return r;\n  }\n  return [];\n}\nconst Qa = \"EXT_mesh_features\", fg = Qa;\nasync function dg(e, t) {\n  const n = new it(e);\n  mg(n, t);\n}\nfunction mg(e, t) {\n  const n = e.gltf.json;\n  if (n.meshes)\n    for (const s of n.meshes)\n      for (const r of s.primitives)\n        gg(e, r, t);\n}\nfunction gg(e, t, n) {\n  var s, r;\n  if (!(n != null && (s = n.gltf) !== null && s !== void 0 && s.loadBuffers))\n    return;\n  const i = (r = t.extensions) === null || r === void 0 ? void 0 : r[Qa], o = i == null ? void 0 : i.featureIds;\n  if (o)\n    for (const c of o) {\n      var a;\n      let u;\n      if (typeof c.attribute < \"u\") {\n        const l = `_FEATURE_ID_${c.attribute}`, h = t.attributes[l];\n        u = e.getTypedArrayForAccessor(h);\n      } else\n        typeof c.texture < \"u\" && n !== null && n !== void 0 && (a = n.gltf) !== null && a !== void 0 && a.loadImages ? u = vr(e, c.texture, t) : u = [];\n      c.data = u;\n    }\n}\nconst Ag = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: dg,\n  name: fg\n}, Symbol.toStringTag, { value: \"Module\" })), Or = \"EXT_structural_metadata\", pg = Or;\nasync function yg(e, t) {\n  const n = new it(e);\n  Bg(n, t);\n}\nfunction Bg(e, t) {\n  var n, s;\n  if (!((n = t.gltf) !== null && n !== void 0 && n.loadBuffers))\n    return;\n  const r = e.getExtension(Or);\n  r && ((s = t.gltf) !== null && s !== void 0 && s.loadImages && Cg(e, r), Eg(e, r));\n}\nfunction Cg(e, t) {\n  const n = t.propertyTextures, s = e.gltf.json;\n  if (n && s.meshes)\n    for (const r of s.meshes)\n      for (const i of r.primitives)\n        bg(e, n, i, t);\n}\nfunction Eg(e, t) {\n  const n = t.schema;\n  if (!n)\n    return;\n  const s = n.classes, r = t.propertyTables;\n  if (s && r)\n    for (const i in s) {\n      const o = Tg(r, i);\n      o && wg(e, n, o);\n    }\n}\nfunction Tg(e, t) {\n  for (const n of e)\n    if (n.class === t)\n      return n;\n  return null;\n}\nfunction bg(e, t, n, s) {\n  var r;\n  if (!t)\n    return;\n  const i = (r = n.extensions) === null || r === void 0 ? void 0 : r[Or], o = i == null ? void 0 : i.propertyTextures;\n  if (o)\n    for (const a of o) {\n      const c = t[a];\n      _g(e, c, n, s);\n    }\n}\nfunction _g(e, t, n, s) {\n  if (!t.properties)\n    return;\n  s.dataAttributeNames || (s.dataAttributeNames = []);\n  const r = t.class;\n  for (const o in t.properties) {\n    var i;\n    const a = `${r}_${o}`, c = (i = t.properties) === null || i === void 0 ? void 0 : i[o];\n    if (!c)\n      continue;\n    c.data || (c.data = []);\n    const u = c.data, l = vr(e, c, n);\n    l !== null && (Ka(e, a, l, u, n), c.data = u, s.dataAttributeNames.push(a));\n  }\n}\nfunction wg(e, t, n) {\n  var s;\n  const r = (s = t.classes) === null || s === void 0 ? void 0 : s[n.class];\n  if (!r)\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);\n  const i = n.count;\n  for (const a in r.properties) {\n    var o;\n    const c = r.properties[a], u = (o = n.properties) === null || o === void 0 ? void 0 : o[a];\n    if (u) {\n      const l = Rg(e, t, c, i, u);\n      u.data = l;\n    }\n  }\n}\nfunction Rg(e, t, n, s, r) {\n  let i = [];\n  const o = r.values, a = e.getTypedArrayForBufferView(o), c = Mg(e, n, r, s), u = Sg(e, r, s);\n  switch (n.type) {\n    case \"SCALAR\":\n    case \"VEC2\":\n    case \"VEC3\":\n    case \"VEC4\":\n    case \"MAT2\":\n    case \"MAT3\":\n    case \"MAT4\": {\n      i = Ig(n, s, a, c);\n      break;\n    }\n    case \"BOOLEAN\":\n      throw new Error(`Not implemented - classProperty.type=${n.type}`);\n    case \"STRING\": {\n      i = Xa(s, a, c, u);\n      break;\n    }\n    case \"ENUM\": {\n      i = xg(t, n, s, a, c);\n      break;\n    }\n    default:\n      throw new Error(`Unknown classProperty type ${n.type}`);\n  }\n  return i;\n}\nfunction Mg(e, t, n, s) {\n  return t.array && typeof t.count > \"u\" && typeof n.arrayOffsets < \"u\" ? Yn(e, n.arrayOffsets, n.arrayOffsetType || \"UINT32\", s) : null;\n}\nfunction Sg(e, t, n) {\n  return typeof t.stringOffsets < \"u\" ? Yn(e, t.stringOffsets, t.stringOffsetType || \"UINT32\", n) : null;\n}\nfunction Ig(e, t, n, s) {\n  const r = e.array, i = e.count, o = xr(e.type, e.componentType), a = n.byteLength / o;\n  let c;\n  return e.componentType ? c = $n(n, e.type, e.componentType, a) : c = n, r ? s ? za(c, t, s, n.length, o) : i ? Wa(c, t, i) : [] : c;\n}\nfunction xg(e, t, n, s, r) {\n  var i;\n  const o = t.enumType;\n  if (!o)\n    throw new Error(\"Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM\");\n  const a = (i = e.enums) === null || i === void 0 ? void 0 : i[o];\n  if (!a)\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${o}`);\n  const c = a.valueType || \"UINT16\", u = xr(t.type, c), l = s.byteLength / u;\n  let h = $n(s, t.type, c, l);\n  if (h || (h = s), t.array) {\n    if (r)\n      return vg({\n        valuesData: h,\n        numberOfElements: n,\n        arrayOffsets: r,\n        valuesDataBytesLength: s.length,\n        elementSize: u,\n        enumEntry: a\n      });\n    const f = t.count;\n    return f ? Og(h, n, f, a) : [];\n  }\n  return Fr(h, 0, n, a);\n}\nfunction vg(e) {\n  const {\n    valuesData: t,\n    numberOfElements: n,\n    arrayOffsets: s,\n    valuesDataBytesLength: r,\n    elementSize: i,\n    enumEntry: o\n  } = e, a = [];\n  for (let c = 0; c < n; c++) {\n    const u = s[c], l = s[c + 1] - s[c];\n    if (l + u > r)\n      break;\n    const h = u / i, f = l / i, d = Fr(t, h, f, o);\n    a.push(d);\n  }\n  return a;\n}\nfunction Og(e, t, n, s) {\n  const r = [];\n  for (let i = 0; i < t; i++) {\n    const o = n * i, a = Fr(e, o, n, s);\n    r.push(a);\n  }\n  return r;\n}\nfunction Fr(e, t, n, s) {\n  const r = [];\n  for (let i = 0; i < n; i++)\n    if (e instanceof BigInt64Array || e instanceof BigUint64Array)\n      r.push(\"\");\n    else {\n      const o = e[t + i], a = Fg(s, o);\n      a ? r.push(a.name) : r.push(\"\");\n    }\n  return r;\n}\nfunction Fg(e, t) {\n  for (const n of e.values)\n    if (n.value === t)\n      return n;\n  return null;\n}\nconst Dg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: yg,\n  name: pg\n}, Symbol.toStringTag, { value: \"Module\" })), qa = \"EXT_feature_metadata\", Lg = qa;\nasync function Pg(e, t) {\n  const n = new it(e);\n  Gg(n, t);\n}\nfunction Gg(e, t) {\n  var n, s;\n  if (!((n = t.gltf) !== null && n !== void 0 && n.loadBuffers))\n    return;\n  const r = e.getExtension(qa);\n  r && ((s = t.gltf) !== null && s !== void 0 && s.loadImages && Ng(e, r), Ug(e, r));\n}\nfunction Ng(e, t) {\n  const n = t.schema;\n  if (!n)\n    return;\n  const s = n.classes, {\n    featureTextures: r\n  } = t;\n  if (s && r)\n    for (const i in s) {\n      const o = s[i], a = Jg(r, i);\n      a && jg(e, a, o);\n    }\n}\nfunction Ug(e, t) {\n  const n = t.schema;\n  if (!n)\n    return;\n  const s = n.classes, r = t.featureTables;\n  if (s && r)\n    for (const i in s) {\n      const o = Hg(r, i);\n      o && Vg(e, n, o);\n    }\n}\nfunction Hg(e, t) {\n  for (const n in e) {\n    const s = e[n];\n    if (s.class === t)\n      return s;\n  }\n  return null;\n}\nfunction Jg(e, t) {\n  for (const n in e) {\n    const s = e[n];\n    if (s.class === t)\n      return s;\n  }\n  return null;\n}\nfunction Vg(e, t, n) {\n  var s;\n  if (!n.class)\n    return;\n  const r = (s = t.classes) === null || s === void 0 ? void 0 : s[n.class];\n  if (!r)\n    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${n.class}`);\n  const i = n.count;\n  for (const a in r.properties) {\n    var o;\n    const c = r.properties[a], u = (o = n.properties) === null || o === void 0 ? void 0 : o[a];\n    if (u) {\n      const l = kg(e, t, c, i, u);\n      u.data = l;\n    }\n  }\n}\nfunction jg(e, t, n) {\n  const s = t.class;\n  for (const i in n.properties) {\n    var r;\n    const o = t == null || (r = t.properties) === null || r === void 0 ? void 0 : r[i];\n    if (o) {\n      const a = Qg(e, o, s);\n      o.data = a;\n    }\n  }\n}\nfunction kg(e, t, n, s, r) {\n  let i = [];\n  const o = r.bufferView, a = e.getTypedArrayForBufferView(o), c = Kg(e, n, r, s), u = zg(e, n, r, s);\n  return n.type === \"STRING\" || n.componentType === \"STRING\" ? i = Xa(s, a, c, u) : Wg(n) && (i = Xg(n, s, a, c)), i;\n}\nfunction Kg(e, t, n, s) {\n  return t.type === \"ARRAY\" && typeof t.componentCount > \"u\" && typeof n.arrayOffsetBufferView < \"u\" ? Yn(e, n.arrayOffsetBufferView, n.offsetType || \"UINT32\", s) : null;\n}\nfunction zg(e, t, n, s) {\n  return typeof n.stringOffsetBufferView < \"u\" ? Yn(e, n.stringOffsetBufferView, n.offsetType || \"UINT32\", s) : null;\n}\nfunction Wg(e) {\n  const t = [\"UINT8\", \"INT16\", \"UINT16\", \"INT32\", \"UINT32\", \"INT64\", \"UINT64\", \"FLOAT32\", \"FLOAT64\"];\n  return t.includes(e.type) || typeof e.componentType < \"u\" && t.includes(e.componentType);\n}\nfunction Xg(e, t, n, s) {\n  const r = e.type === \"ARRAY\", i = e.componentCount, o = \"SCALAR\", a = e.componentType || e.type, c = xr(o, a), u = n.byteLength / c, l = $n(n, o, a, u);\n  return r ? s ? za(l, t, s, n.length, c) : i ? Wa(l, t, i) : [] : l;\n}\nfunction Qg(e, t, n) {\n  const s = e.gltf.json;\n  if (!s.meshes)\n    return [];\n  const r = [];\n  for (const i of s.meshes)\n    for (const o of i.primitives)\n      qg(e, n, t, r, o);\n  return r;\n}\nfunction qg(e, t, n, s, r) {\n  const i = {\n    channels: n.channels,\n    ...n.texture\n  }, o = vr(e, i, r);\n  o && Ka(e, t, o, s, r);\n}\nconst Yg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: Pg,\n  name: Lg\n}, Symbol.toStringTag, { value: \"Module\" })), $g = \"4.1.1\", Zg = \"4.1.1\", Ln = {\n  TRANSCODER: \"basis_transcoder.js\",\n  TRANSCODER_WASM: \"basis_transcoder.wasm\",\n  ENCODER: \"basis_encoder.js\",\n  ENCODER_WASM: \"basis_encoder.wasm\"\n};\nlet bs;\nasync function Ni(e) {\n  const t = e.modules || {};\n  return t.basis ? t.basis : (bs = bs || t0(e), await bs);\n}\nasync function t0(e) {\n  let t = null, n = null;\n  return [t, n] = await Promise.all([await Zt(Ln.TRANSCODER, \"textures\", e), await Zt(Ln.TRANSCODER_WASM, \"textures\", e)]), t = t || globalThis.BASIS, await e0(t, n);\n}\nfunction e0(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise((s) => {\n    e(n).then((r) => {\n      const {\n        BasisFile: i,\n        initializeBasis: o\n      } = r;\n      o(), s({\n        BasisFile: i\n      });\n    });\n  });\n}\nlet _s;\nasync function Ui(e) {\n  const t = e.modules || {};\n  return t.basisEncoder ? t.basisEncoder : (_s = _s || n0(e), await _s);\n}\nasync function n0(e) {\n  let t = null, n = null;\n  return [t, n] = await Promise.all([await Zt(Ln.ENCODER, \"textures\", e), await Zt(Ln.ENCODER_WASM, \"textures\", e)]), t = t || globalThis.BASIS, await s0(t, n);\n}\nfunction s0(e, t) {\n  const n = {};\n  return t && (n.wasmBinary = t), new Promise((s) => {\n    e(n).then((r) => {\n      const {\n        BasisFile: i,\n        KTX2File: o,\n        initializeBasis: a,\n        BasisEncoder: c\n      } = r;\n      a(), s({\n        BasisFile: i,\n        KTX2File: o,\n        BasisEncoder: c\n      });\n    });\n  });\n}\nconst he = {\n  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,\n  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,\n  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,\n  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,\n  COMPRESSED_R11_EAC: 37488,\n  COMPRESSED_SIGNED_R11_EAC: 37489,\n  COMPRESSED_RG11_EAC: 37490,\n  COMPRESSED_SIGNED_RG11_EAC: 37491,\n  COMPRESSED_RGB8_ETC2: 37492,\n  COMPRESSED_RGBA8_ETC2_EAC: 37493,\n  COMPRESSED_SRGB8_ETC2: 37494,\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,\n  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,\n  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,\n  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,\n  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,\n  COMPRESSED_RGB_ETC1_WEBGL: 36196,\n  COMPRESSED_RGB_ATC_WEBGL: 35986,\n  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,\n  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,\n  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,\n  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,\n  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,\n  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,\n  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,\n  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,\n  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,\n  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,\n  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,\n  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,\n  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,\n  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,\n  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,\n  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,\n  COMPRESSED_RED_RGTC1_EXT: 36283,\n  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,\n  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,\n  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,\n  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919\n}, r0 = [\"\", \"WEBKIT_\", \"MOZ_\"], Hi = {\n  WEBGL_compressed_texture_s3tc: \"dxt\",\n  WEBGL_compressed_texture_s3tc_srgb: \"dxt-srgb\",\n  WEBGL_compressed_texture_etc1: \"etc1\",\n  WEBGL_compressed_texture_etc: \"etc2\",\n  WEBGL_compressed_texture_pvrtc: \"pvrtc\",\n  WEBGL_compressed_texture_atc: \"atc\",\n  WEBGL_compressed_texture_astc: \"astc\",\n  EXT_texture_compression_rgtc: \"rgtc\"\n};\nlet gn = null;\nfunction i0(e) {\n  if (!gn) {\n    e = e || o0() || void 0, gn = /* @__PURE__ */ new Set();\n    for (const t of r0)\n      for (const n in Hi)\n        if (e && e.getExtension(`${t}${n}`)) {\n          const s = Hi[n];\n          gn.add(s);\n        }\n  }\n  return gn;\n}\nfunction o0() {\n  try {\n    return document.createElement(\"canvas\").getContext(\"webgl\");\n  } catch {\n    return null;\n  }\n}\nvar Ji, Vi, ji, ki, Ki, zi, Wi, Xi;\n(function(e) {\n  e[e.NONE = 0] = \"NONE\", e[e.BASISLZ = 1] = \"BASISLZ\", e[e.ZSTD = 2] = \"ZSTD\", e[e.ZLIB = 3] = \"ZLIB\";\n})(Ji || (Ji = {})), function(e) {\n  e[e.BASICFORMAT = 0] = \"BASICFORMAT\";\n}(Vi || (Vi = {})), function(e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.ETC1S = 163] = \"ETC1S\", e[e.UASTC = 166] = \"UASTC\";\n}(ji || (ji = {})), function(e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.SRGB = 1] = \"SRGB\";\n}(ki || (ki = {})), function(e) {\n  e[e.UNSPECIFIED = 0] = \"UNSPECIFIED\", e[e.LINEAR = 1] = \"LINEAR\", e[e.SRGB = 2] = \"SRGB\", e[e.ITU = 3] = \"ITU\", e[e.NTSC = 4] = \"NTSC\", e[e.SLOG = 5] = \"SLOG\", e[e.SLOG2 = 6] = \"SLOG2\";\n}(Ki || (Ki = {})), function(e) {\n  e[e.ALPHA_STRAIGHT = 0] = \"ALPHA_STRAIGHT\", e[e.ALPHA_PREMULTIPLIED = 1] = \"ALPHA_PREMULTIPLIED\";\n}(zi || (zi = {})), function(e) {\n  e[e.RGB = 0] = \"RGB\", e[e.RRR = 3] = \"RRR\", e[e.GGG = 4] = \"GGG\", e[e.AAA = 15] = \"AAA\";\n}(Wi || (Wi = {})), function(e) {\n  e[e.RGB = 0] = \"RGB\", e[e.RGBA = 3] = \"RGBA\", e[e.RRR = 4] = \"RRR\", e[e.RRRG = 5] = \"RRRG\";\n}(Xi || (Xi = {}));\nconst gt = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];\nfunction a0(e) {\n  const t = new Uint8Array(e);\n  return !(t.byteLength < gt.length || t[0] !== gt[0] || t[1] !== gt[1] || t[2] !== gt[2] || t[3] !== gt[3] || t[4] !== gt[4] || t[5] !== gt[5] || t[6] !== gt[6] || t[7] !== gt[7] || t[8] !== gt[8] || t[9] !== gt[9] || t[10] !== gt[10] || t[11] !== gt[11]);\n}\nconst c0 = {\n  etc1: {\n    basisFormat: 0,\n    compressed: !0,\n    format: he.COMPRESSED_RGB_ETC1_WEBGL\n  },\n  etc2: {\n    basisFormat: 1,\n    compressed: !0\n  },\n  bc1: {\n    basisFormat: 2,\n    compressed: !0,\n    format: he.COMPRESSED_RGB_S3TC_DXT1_EXT\n  },\n  bc3: {\n    basisFormat: 3,\n    compressed: !0,\n    format: he.COMPRESSED_RGBA_S3TC_DXT5_EXT\n  },\n  bc4: {\n    basisFormat: 4,\n    compressed: !0\n  },\n  bc5: {\n    basisFormat: 5,\n    compressed: !0\n  },\n  \"bc7-m6-opaque-only\": {\n    basisFormat: 6,\n    compressed: !0\n  },\n  \"bc7-m5\": {\n    basisFormat: 7,\n    compressed: !0\n  },\n  \"pvrtc1-4-rgb\": {\n    basisFormat: 8,\n    compressed: !0,\n    format: he.COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n  },\n  \"pvrtc1-4-rgba\": {\n    basisFormat: 9,\n    compressed: !0,\n    format: he.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n  },\n  \"astc-4x4\": {\n    basisFormat: 10,\n    compressed: !0,\n    format: he.COMPRESSED_RGBA_ASTC_4X4_KHR\n  },\n  \"atc-rgb\": {\n    basisFormat: 11,\n    compressed: !0\n  },\n  \"atc-rgba-interpolated-alpha\": {\n    basisFormat: 12,\n    compressed: !0\n  },\n  rgba32: {\n    basisFormat: 13,\n    compressed: !1\n  },\n  rgb565: {\n    basisFormat: 14,\n    compressed: !1\n  },\n  bgr565: {\n    basisFormat: 15,\n    compressed: !1\n  },\n  rgba4444: {\n    basisFormat: 16,\n    compressed: !1\n  }\n};\nasync function u0(e, t) {\n  if (t.basis.containerFormat === \"auto\") {\n    if (a0(e)) {\n      const s = await Ui(t);\n      return Qi(s.KTX2File, e, t);\n    }\n    const {\n      BasisFile: n\n    } = await Ni(t);\n    return ws(n, e, t);\n  }\n  switch (t.basis.module) {\n    case \"encoder\":\n      const n = await Ui(t);\n      switch (t.basis.containerFormat) {\n        case \"ktx2\":\n          return Qi(n.KTX2File, e, t);\n        case \"basis\":\n        default:\n          return ws(n.BasisFile, e, t);\n      }\n    case \"transcoder\":\n    default:\n      const {\n        BasisFile: s\n      } = await Ni(t);\n      return ws(s, e, t);\n  }\n}\nfunction ws(e, t, n) {\n  const s = new e(new Uint8Array(t));\n  try {\n    if (!s.startTranscoding())\n      throw new Error(\"Failed to start basis transcoding\");\n    const r = s.getNumImages(), i = [];\n    for (let o = 0; o < r; o++) {\n      const a = s.getNumLevels(o), c = [];\n      for (let u = 0; u < a; u++)\n        c.push(l0(s, o, u, n));\n      i.push(c);\n    }\n    return i;\n  } finally {\n    s.close(), s.delete();\n  }\n}\nfunction l0(e, t, n, s) {\n  const r = e.getImageWidth(t, n), i = e.getImageHeight(t, n), o = e.getHasAlpha(), {\n    compressed: a,\n    format: c,\n    basisFormat: u\n  } = Ya(s, o), l = e.getImageTranscodedSizeInBytes(t, n, u), h = new Uint8Array(l);\n  if (!e.transcodeImage(h, t, n, u, 0, 0))\n    throw new Error(\"failed to start Basis transcoding\");\n  return {\n    width: r,\n    height: i,\n    data: h,\n    compressed: a,\n    format: c,\n    hasAlpha: o\n  };\n}\nfunction Qi(e, t, n) {\n  const s = new e(new Uint8Array(t));\n  try {\n    if (!s.startTranscoding())\n      throw new Error(\"failed to start KTX2 transcoding\");\n    const r = s.getLevels(), i = [];\n    for (let o = 0; o < r; o++) {\n      i.push(h0(s, o, n));\n      break;\n    }\n    return [i];\n  } finally {\n    s.close(), s.delete();\n  }\n}\nfunction h0(e, t, n) {\n  const {\n    alphaFlag: s,\n    height: r,\n    width: i\n  } = e.getImageLevelInfo(t, 0, 0), {\n    compressed: o,\n    format: a,\n    basisFormat: c\n  } = Ya(n, s), u = e.getImageTranscodedSizeInBytes(t, 0, 0, c), l = new Uint8Array(u);\n  if (!e.transcodeImage(l, t, 0, 0, c, 0, -1, -1))\n    throw new Error(\"Failed to transcode KTX2 image\");\n  return {\n    width: i,\n    height: r,\n    data: l,\n    compressed: o,\n    levelSize: u,\n    hasAlpha: s,\n    format: a\n  };\n}\nfunction Ya(e, t) {\n  let n = e && e.basis && e.basis.format;\n  return n === \"auto\" && (n = $a()), typeof n == \"object\" && (n = t ? n.alpha : n.noAlpha), n = n.toLowerCase(), c0[n];\n}\nfunction $a() {\n  const e = i0();\n  return e.has(\"astc\") ? \"astc-4x4\" : e.has(\"dxt\") ? {\n    alpha: \"bc3\",\n    noAlpha: \"bc1\"\n  } : e.has(\"pvrtc\") ? {\n    alpha: \"pvrtc1-4-rgba\",\n    noAlpha: \"pvrtc1-4-rgb\"\n  } : e.has(\"etc1\") ? \"etc1\" : e.has(\"etc2\") ? \"etc2\" : \"rgb565\";\n}\nconst f0 = {\n  name: \"Basis\",\n  id: \"basis\",\n  module: \"textures\",\n  version: Zg,\n  worker: !0,\n  extensions: [\"basis\", \"ktx2\"],\n  mimeTypes: [\"application/octet-stream\", \"image/ktx2\"],\n  tests: [\"sB\"],\n  binary: !0,\n  options: {\n    basis: {\n      format: \"auto\",\n      libraryPath: \"libs/\",\n      containerFormat: \"auto\",\n      module: \"transcoder\"\n    }\n  }\n}, d0 = {\n  ...f0,\n  parse: u0\n}, pe = !0, qi = 1735152710, Dr = 12, Pn = 8, m0 = 1313821514, g0 = 5130562, A0 = 0, p0 = 0, y0 = 1;\nfunction B0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n  return `${String.fromCharCode(e.getUint8(t + 0))}${String.fromCharCode(e.getUint8(t + 1))}${String.fromCharCode(e.getUint8(t + 2))}${String.fromCharCode(e.getUint8(t + 3))}`;\n}\nfunction C0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  const s = new DataView(e), {\n    magic: r = qi\n  } = n, i = s.getUint32(t, !1);\n  return i === r || i === qi;\n}\nfunction E0(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n  const s = new DataView(t), r = B0(s, n + 0), i = s.getUint32(n + 4, pe), o = s.getUint32(n + 8, pe);\n  switch (Object.assign(e, {\n    header: {\n      byteOffset: n,\n      byteLength: o,\n      hasBinChunk: !1\n    },\n    type: r,\n    version: i,\n    json: {},\n    binChunks: []\n  }), n += Dr, e.version) {\n    case 1:\n      return T0(e, s, n);\n    case 2:\n      return b0(e, s, n, {});\n    default:\n      throw new Error(`Invalid GLB version ${e.version}. Only supports version 1 and 2.`);\n  }\n}\nfunction T0(e, t, n) {\n  K(e.header.byteLength > Dr + Pn);\n  const s = t.getUint32(n + 0, pe), r = t.getUint32(n + 4, pe);\n  return n += Pn, K(r === A0), Ys(e, t, n, s), n += s, n += $s(e, t, n, e.header.byteLength), n;\n}\nfunction b0(e, t, n, s) {\n  return K(e.header.byteLength > Dr + Pn), _0(e, t, n, s), n + e.header.byteLength;\n}\nfunction _0(e, t, n, s) {\n  for (; n + 8 <= e.header.byteLength; ) {\n    const r = t.getUint32(n + 0, pe), i = t.getUint32(n + 4, pe);\n    switch (n += Pn, i) {\n      case m0:\n        Ys(e, t, n, r);\n        break;\n      case g0:\n        $s(e, t, n, r);\n        break;\n      case p0:\n        s.strict || Ys(e, t, n, r);\n        break;\n      case y0:\n        s.strict || $s(e, t, n, r);\n        break;\n    }\n    n += ze(r, 4);\n  }\n  return n;\n}\nfunction Ys(e, t, n, s) {\n  const r = new Uint8Array(t.buffer, n, s), o = new TextDecoder(\"utf8\").decode(r);\n  return e.json = JSON.parse(o), ze(s, 4);\n}\nfunction $s(e, t, n, s) {\n  return e.header.hasBinChunk = !0, e.binChunks.push({\n    byteOffset: n,\n    byteLength: s,\n    arrayBuffer: t.buffer\n  }), ze(s, 4);\n}\nfunction Za(e, t) {\n  if (e.startsWith(\"data:\") || e.startsWith(\"http:\") || e.startsWith(\"https:\"))\n    return e;\n  const s = t.baseUri || t.uri;\n  if (!s)\n    throw new Error(`'baseUri' must be provided to resolve relative url ${e}`);\n  return s.substr(0, s.lastIndexOf(\"/\") + 1) + e;\n}\nconst w0 = \"B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB\", R0 = \"B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB\", M0 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), S0 = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]), I0 = {\n  0: \"\",\n  1: \"meshopt_decodeFilterOct\",\n  2: \"meshopt_decodeFilterQuat\",\n  3: \"meshopt_decodeFilterExp\",\n  NONE: \"\",\n  OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n  QUATERNION: \"meshopt_decodeFilterQuat\",\n  EXPONENTIAL: \"meshopt_decodeFilterExp\"\n}, x0 = {\n  0: \"meshopt_decodeVertexBuffer\",\n  1: \"meshopt_decodeIndexBuffer\",\n  2: \"meshopt_decodeIndexSequence\",\n  ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n  TRIANGLES: \"meshopt_decodeIndexBuffer\",\n  INDICES: \"meshopt_decodeIndexSequence\"\n};\nasync function v0(e, t, n, s, r) {\n  let i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"NONE\";\n  const o = await O0();\n  L0(o, o.exports[x0[r]], e, t, n, s, o.exports[I0[i || \"NONE\"]]);\n}\nlet Rs;\nasync function O0() {\n  return Rs || (Rs = F0()), Rs;\n}\nasync function F0() {\n  let e = w0;\n  WebAssembly.validate(M0) && (e = R0, console.log(\"Warning: meshopt_decoder is using experimental SIMD support\"));\n  const t = await WebAssembly.instantiate(D0(e), {});\n  return await t.instance.exports.__wasm_call_ctors(), t.instance;\n}\nfunction D0(e) {\n  const t = new Uint8Array(e.length);\n  for (let s = 0; s < e.length; ++s) {\n    const r = e.charCodeAt(s);\n    t[s] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62;\n  }\n  let n = 0;\n  for (let s = 0; s < e.length; ++s)\n    t[n++] = t[s] < 60 ? S0[t[s]] : (t[s] - 60) * 64 + t[++s];\n  return t.buffer.slice(0, n);\n}\nfunction L0(e, t, n, s, r, i, o) {\n  const a = e.exports.sbrk, c = s + 3 & -4, u = a(c * r), l = a(i.length), h = new Uint8Array(e.exports.memory.buffer);\n  h.set(i, l);\n  const f = t(u, s, r, l, i.length);\n  if (f === 0 && o && o(u, c, r), n.set(h.subarray(u, u + s * r)), a(u - a(0)), f !== 0)\n    throw new Error(`Malformed buffer data: ${f}`);\n}\nconst Gn = \"EXT_meshopt_compression\", P0 = Gn;\nasync function G0(e, t) {\n  var n, s;\n  const r = new it(e);\n  if (!(t != null && (n = t.gltf) !== null && n !== void 0 && n.decompressMeshes) || !((s = t.gltf) !== null && s !== void 0 && s.loadBuffers))\n    return;\n  const i = [];\n  for (const o of e.json.bufferViews || [])\n    i.push(N0(r, o));\n  await Promise.all(i), r.removeExtension(Gn);\n}\nasync function N0(e, t) {\n  const n = e.getObjectExtension(t, Gn);\n  if (n) {\n    const {\n      byteOffset: s = 0,\n      byteLength: r = 0,\n      byteStride: i,\n      count: o,\n      mode: a,\n      filter: c = \"NONE\",\n      buffer: u\n    } = n, l = e.gltf.buffers[u], h = new Uint8Array(l.arrayBuffer, l.byteOffset + s, r), f = new Uint8Array(e.gltf.buffers[t.buffer].arrayBuffer, t.byteOffset, t.byteLength);\n    await v0(f, o, i, h, a, c), e.removeObjectExtension(t, Gn);\n  }\n}\nconst U0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: G0,\n  name: P0\n}, Symbol.toStringTag, { value: \"Module\" })), fe = \"EXT_texture_webp\", H0 = fe;\nfunction J0(e, t) {\n  const n = new it(e);\n  if (!qm(\"image/webp\")) {\n    if (n.getRequiredExtensions().includes(fe))\n      throw new Error(`gltf: Required extension ${fe} not supported by browser`);\n    return;\n  }\n  const {\n    json: s\n  } = n;\n  for (const r of s.textures || []) {\n    const i = n.getObjectExtension(r, fe);\n    i && (r.source = i.source), n.removeObjectExtension(r, fe);\n  }\n  n.removeExtension(fe);\n}\nconst V0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  name: H0,\n  preprocess: J0\n}, Symbol.toStringTag, { value: \"Module\" })), _n = \"KHR_texture_basisu\", j0 = _n;\nfunction k0(e, t) {\n  const n = new it(e), {\n    json: s\n  } = n;\n  for (const r of s.textures || []) {\n    const i = n.getObjectExtension(r, _n);\n    i && (r.source = i.source, n.removeObjectExtension(r, _n));\n  }\n  n.removeExtension(_n);\n}\nconst K0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  name: j0,\n  preprocess: k0\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction z0(e) {\n  const t = {};\n  for (const n in e) {\n    const s = e[n];\n    if (n !== \"indices\") {\n      const r = tc(s);\n      t[n] = r;\n    }\n  }\n  return t;\n}\nfunction tc(e) {\n  const {\n    buffer: t,\n    size: n,\n    count: s\n  } = W0(e);\n  return {\n    value: t,\n    size: n,\n    byteOffset: 0,\n    count: s,\n    type: Ja(n),\n    componentType: Sr(t)\n  };\n}\nfunction W0(e) {\n  let t = e, n = 1, s = 0;\n  return e && e.value && (t = e.value, n = e.size || 1), t && (ArrayBuffer.isView(t) || (t = X0(t, Float32Array)), s = t.length / n), {\n    buffer: t,\n    size: n,\n    count: s\n  };\n}\nfunction X0(e, t) {\n  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n  return e ? Array.isArray(e) ? new t(e) : n && !(e instanceof t) ? new t(e) : e : null;\n}\nconst zt = \"KHR_draco_mesh_compression\", Q0 = zt;\nfunction q0(e, t, n) {\n  const s = new it(e);\n  for (const r of ec(s))\n    s.getObjectExtension(r, zt);\n}\nasync function Y0(e, t, n) {\n  var s;\n  if (!(t != null && (s = t.gltf) !== null && s !== void 0 && s.decompressMeshes))\n    return;\n  const r = new it(e), i = [];\n  for (const o of ec(r))\n    r.getObjectExtension(o, zt) && i.push(Z0(r, o, t, n));\n  await Promise.all(i), r.removeExtension(zt);\n}\nfunction $0(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  const n = new it(e);\n  for (const s of n.json.meshes || [])\n    tA(s, t), n.addRequiredExtension(zt);\n}\nasync function Z0(e, t, n, s) {\n  const r = e.getObjectExtension(t, zt);\n  if (!r)\n    return;\n  const i = e.getTypedArrayForBufferView(r.bufferView), o = dr(i.buffer, i.byteOffset), a = {\n    ...n\n  };\n  delete a[\"3d-tiles\"];\n  const c = await Ke(o, Oa, a, s), u = z0(c.attributes);\n  for (const [l, h] of Object.entries(u))\n    if (l in t.attributes) {\n      const f = t.attributes[l], d = e.getAccessor(f);\n      d != null && d.min && d !== null && d !== void 0 && d.max && (h.min = d.min, h.max = d.max);\n    }\n  t.attributes = u, c.indices && (t.indices = tc(c.indices)), e.removeObjectExtension(t, zt), eA(t);\n}\nfunction tA(e, t) {\n  var n;\n  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4, r = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 ? arguments[4] : void 0;\n  if (!r.DracoWriter)\n    throw new Error(\"options.gltf.DracoWriter not provided\");\n  const o = r.DracoWriter.encodeSync({\n    attributes: e\n  }), a = i == null || (n = i.parseSync) === null || n === void 0 ? void 0 : n.call(i, {\n    attributes: e\n  }), c = r._addFauxAttributes(a.attributes), u = r.addBufferView(o);\n  return {\n    primitives: [{\n      attributes: c,\n      mode: s,\n      extensions: {\n        [zt]: {\n          bufferView: u,\n          attributes: c\n        }\n      }\n    }]\n  };\n}\nfunction eA(e) {\n  if (!e.attributes && Object.keys(e.attributes).length > 0)\n    throw new Error(\"glTF: Empty primitive detected: Draco decompression failure?\");\n}\nfunction* ec(e) {\n  for (const t of e.json.meshes || [])\n    for (const n of t.primitives)\n      yield n;\n}\nconst nA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: Y0,\n  encode: $0,\n  name: Q0,\n  preprocess: q0\n}, Symbol.toStringTag, { value: \"Module\" })), Lr = \"KHR_texture_transform\", sA = Lr, An = new A(), rA = new W(), iA = new W();\nasync function oA(e, t) {\n  var n;\n  if (!new it(e).hasExtension(Lr) || !((n = t.gltf) !== null && n !== void 0 && n.loadBuffers))\n    return;\n  const i = e.json.materials || [];\n  for (let o = 0; o < i.length; o++)\n    aA(o, e);\n}\nfunction aA(e, t) {\n  var n, s, r;\n  const i = [], o = (n = t.json.materials) === null || n === void 0 ? void 0 : n[e], a = o == null || (s = o.pbrMetallicRoughness) === null || s === void 0 ? void 0 : s.baseColorTexture;\n  a && Me(t, e, a, i);\n  const c = o == null ? void 0 : o.emissiveTexture;\n  c && Me(t, e, c, i);\n  const u = o == null ? void 0 : o.normalTexture;\n  u && Me(t, e, u, i);\n  const l = o == null ? void 0 : o.occlusionTexture;\n  l && Me(t, e, l, i);\n  const h = o == null || (r = o.pbrMetallicRoughness) === null || r === void 0 ? void 0 : r.metallicRoughnessTexture;\n  h && Me(t, e, h, i);\n}\nfunction Me(e, t, n, s) {\n  const r = cA(n, s);\n  if (!r)\n    return;\n  const i = e.json.meshes || [];\n  for (const o of i)\n    for (const a of o.primitives) {\n      const c = a.material;\n      Number.isFinite(c) && t === c && uA(e, a, r);\n    }\n}\nfunction cA(e, t) {\n  var n;\n  const s = (n = e.extensions) === null || n === void 0 ? void 0 : n[Lr], {\n    texCoord: r = 0\n  } = e, {\n    texCoord: i = r\n  } = s;\n  if (!(t.findIndex((a) => {\n    let [c, u] = a;\n    return c === r && u === i;\n  }) !== -1)) {\n    const a = fA(s);\n    return r !== i && (e.texCoord = i), t.push([r, i]), {\n      originalTexCoord: r,\n      texCoord: i,\n      matrix: a\n    };\n  }\n  return null;\n}\nfunction uA(e, t, n) {\n  const {\n    originalTexCoord: s,\n    texCoord: r,\n    matrix: i\n  } = n, o = t.attributes[`TEXCOORD_${s}`];\n  if (Number.isFinite(o)) {\n    var a;\n    const u = (a = e.json.accessors) === null || a === void 0 ? void 0 : a[o];\n    if (u && u.bufferView) {\n      var c;\n      const l = (c = e.json.bufferViews) === null || c === void 0 ? void 0 : c[u.bufferView];\n      if (l) {\n        const {\n          arrayBuffer: h,\n          byteOffset: f\n        } = e.buffers[l.buffer], d = (f || 0) + (u.byteOffset || 0) + (l.byteOffset || 0), {\n          ArrayType: m,\n          length: g\n        } = Ir(u, l), y = Ha[u.componentType], E = Ua[u.type], R = l.byteStride || y * E, B = new Float32Array(g);\n        for (let C = 0; C < u.count; C++) {\n          const M = new m(h, d + C * R, 2);\n          An.set(M[0], M[1], 1), An.transformByMatrix3(i), B.set([An[0], An[1]], C * E);\n        }\n        s === r ? lA(u, l, e.buffers, B) : hA(r, u, t, e, B);\n      }\n    }\n  }\n}\nfunction lA(e, t, n, s) {\n  e.componentType = 5126, n.push({\n    arrayBuffer: s.buffer,\n    byteOffset: 0,\n    byteLength: s.buffer.byteLength\n  }), t.buffer = n.length - 1, t.byteLength = s.buffer.byteLength, t.byteOffset = 0, delete t.byteStride;\n}\nfunction hA(e, t, n, s, r) {\n  s.buffers.push({\n    arrayBuffer: r.buffer,\n    byteOffset: 0,\n    byteLength: r.buffer.byteLength\n  });\n  const i = s.json.bufferViews;\n  if (!i)\n    return;\n  i.push({\n    buffer: s.buffers.length - 1,\n    byteLength: r.buffer.byteLength,\n    byteOffset: 0\n  });\n  const o = s.json.accessors;\n  o && (o.push({\n    bufferView: (i == null ? void 0 : i.length) - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: t.count,\n    type: \"VEC2\"\n  }), n.attributes[`TEXCOORD_${e}`] = o.length - 1);\n}\nfunction fA(e) {\n  const {\n    offset: t = [0, 0],\n    rotation: n = 0,\n    scale: s = [1, 1]\n  } = e, r = new W().set(1, 0, 0, 0, 1, 0, t[0], t[1], 1), i = rA.set(Math.cos(n), Math.sin(n), 0, -Math.sin(n), Math.cos(n), 0, 0, 0, 1), o = iA.set(s[0], 0, 0, 0, s[1], 0, 0, 0, 1);\n  return r.multiplyRight(i).multiplyRight(o);\n}\nconst dA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: oA,\n  name: sA\n}, Symbol.toStringTag, { value: \"Module\" })), Yt = \"KHR_lights_punctual\", mA = Yt;\nasync function gA(e) {\n  const t = new it(e), {\n    json: n\n  } = t, s = t.getExtension(Yt);\n  s && (t.json.lights = s.lights, t.removeExtension(Yt));\n  for (const r of n.nodes || []) {\n    const i = t.getObjectExtension(r, Yt);\n    i && (r.light = i.light), t.removeObjectExtension(r, Yt);\n  }\n}\nasync function AA(e) {\n  const t = new it(e), {\n    json: n\n  } = t;\n  if (n.lights) {\n    const s = t.addExtension(Yt);\n    yt(!s.lights), s.lights = n.lights, delete n.lights;\n  }\n  if (t.json.lights) {\n    for (const s of t.json.lights) {\n      const r = s.node;\n      t.addObjectExtension(r, Yt, s);\n    }\n    delete t.json.lights;\n  }\n}\nconst pA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: gA,\n  encode: AA,\n  name: mA\n}, Symbol.toStringTag, { value: \"Module\" })), Ue = \"KHR_materials_unlit\", yA = Ue;\nasync function BA(e) {\n  const t = new it(e), {\n    json: n\n  } = t;\n  for (const s of n.materials || [])\n    s.extensions && s.extensions.KHR_materials_unlit && (s.unlit = !0), t.removeObjectExtension(s, Ue);\n  t.removeExtension(Ue);\n}\nfunction CA(e) {\n  const t = new it(e), {\n    json: n\n  } = t;\n  if (t.materials)\n    for (const s of n.materials || [])\n      s.unlit && (delete s.unlit, t.addObjectExtension(s, Ue, {}), t.addExtension(Ue));\n}\nconst EA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: BA,\n  encode: CA,\n  name: yA\n}, Symbol.toStringTag, { value: \"Module\" })), xe = \"KHR_techniques_webgl\", TA = xe;\nasync function bA(e) {\n  const t = new it(e), {\n    json: n\n  } = t, s = t.getExtension(xe);\n  if (s) {\n    const r = wA(s, t);\n    for (const i of n.materials || []) {\n      const o = t.getObjectExtension(i, xe);\n      o && (i.technique = Object.assign({}, o, r[o.technique]), i.technique.values = RA(i.technique, t)), t.removeObjectExtension(i, xe);\n    }\n    t.removeExtension(xe);\n  }\n}\nasync function _A(e, t) {\n}\nfunction wA(e, t) {\n  const {\n    programs: n = [],\n    shaders: s = [],\n    techniques: r = []\n  } = e, i = new TextDecoder();\n  return s.forEach((o) => {\n    if (Number.isFinite(o.bufferView))\n      o.code = i.decode(t.getTypedArrayForBufferView(o.bufferView));\n    else\n      throw new Error(\"KHR_techniques_webgl: no shader code\");\n  }), n.forEach((o) => {\n    o.fragmentShader = s[o.fragmentShader], o.vertexShader = s[o.vertexShader];\n  }), r.forEach((o) => {\n    o.program = n[o.program];\n  }), r;\n}\nfunction RA(e, t) {\n  const n = Object.assign({}, e.values);\n  return Object.keys(e.uniforms || {}).forEach((s) => {\n    e.uniforms[s].value && !(s in n) && (n[s] = e.uniforms[s].value);\n  }), Object.keys(n).forEach((s) => {\n    typeof n[s] == \"object\" && n[s].index !== void 0 && (n[s].texture = t.getTexture(n[s].index));\n  }), n;\n}\nconst MA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  decode: bA,\n  encode: _A,\n  name: TA\n}, Symbol.toStringTag, { value: \"Module\" })), nc = [Dg, Ag, U0, V0, K0, nA, pA, EA, MA, dA, Yg];\nfunction SA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = nc.filter((i) => sc(i.name, t));\n  for (const i of s) {\n    var r;\n    (r = i.preprocess) === null || r === void 0 || r.call(i, e, t, n);\n  }\n}\nasync function IA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = nc.filter((i) => sc(i.name, t));\n  for (const i of s) {\n    var r;\n    await ((r = i.decode) === null || r === void 0 ? void 0 : r.call(i, e, t, n));\n  }\n}\nfunction sc(e, t) {\n  var n;\n  const s = (t == null || (n = t.gltf) === null || n === void 0 ? void 0 : n.excludeExtensions) || {};\n  return !(e in s && !s[e]);\n}\nconst Ms = \"KHR_binary_glTF\";\nfunction xA(e) {\n  const t = new it(e), {\n    json: n\n  } = t;\n  for (const s of n.images || []) {\n    const r = t.getObjectExtension(s, Ms);\n    r && Object.assign(s, r), t.removeObjectExtension(s, Ms);\n  }\n  n.buffers && n.buffers[0] && delete n.buffers[0].uri, t.removeExtension(Ms);\n}\nconst Yi = {\n  accessors: \"accessor\",\n  animations: \"animation\",\n  buffers: \"buffer\",\n  bufferViews: \"bufferView\",\n  images: \"image\",\n  materials: \"material\",\n  meshes: \"mesh\",\n  nodes: \"node\",\n  samplers: \"sampler\",\n  scenes: \"scene\",\n  skins: \"skin\",\n  textures: \"texture\"\n}, vA = {\n  accessor: \"accessors\",\n  animations: \"animation\",\n  buffer: \"buffers\",\n  bufferView: \"bufferViews\",\n  image: \"images\",\n  material: \"materials\",\n  mesh: \"meshes\",\n  node: \"nodes\",\n  sampler: \"samplers\",\n  scene: \"scenes\",\n  skin: \"skins\",\n  texture: \"textures\"\n};\nclass OA {\n  constructor() {\n    this.idToIndexMap = {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    }, this.json = void 0;\n  }\n  normalize(t, n) {\n    this.json = t.json;\n    const s = t.json;\n    switch (s.asset && s.asset.version) {\n      case \"2.0\":\n        return;\n      case void 0:\n      case \"1.0\":\n        break;\n      default:\n        console.warn(`glTF: Unknown version ${s.asset.version}`);\n        return;\n    }\n    if (!n.normalize)\n      throw new Error(\"glTF v1 is not supported.\");\n    console.warn(\"Converting glTF v1 to glTF v2 format. This is experimental and may fail.\"), this._addAsset(s), this._convertTopLevelObjectsToArrays(s), xA(t), this._convertObjectIdsToArrayIndices(s), this._updateObjects(s), this._updateMaterial(s);\n  }\n  _addAsset(t) {\n    t.asset = t.asset || {}, t.asset.version = \"2.0\", t.asset.generator = t.asset.generator || \"Normalized to glTF 2.0 by loaders.gl\";\n  }\n  _convertTopLevelObjectsToArrays(t) {\n    for (const n in Yi)\n      this._convertTopLevelObjectToArray(t, n);\n  }\n  _convertTopLevelObjectToArray(t, n) {\n    const s = t[n];\n    if (!(!s || Array.isArray(s))) {\n      t[n] = [];\n      for (const r in s) {\n        const i = s[r];\n        i.id = i.id || r;\n        const o = t[n].length;\n        t[n].push(i), this.idToIndexMap[n][r] = o;\n      }\n    }\n  }\n  _convertObjectIdsToArrayIndices(t) {\n    for (const n in Yi)\n      this._convertIdsToIndices(t, n);\n    \"scene\" in t && (t.scene = this._convertIdToIndex(t.scene, \"scene\"));\n    for (const n of t.textures)\n      this._convertTextureIds(n);\n    for (const n of t.meshes)\n      this._convertMeshIds(n);\n    for (const n of t.nodes)\n      this._convertNodeIds(n);\n    for (const n of t.scenes)\n      this._convertSceneIds(n);\n  }\n  _convertTextureIds(t) {\n    t.source && (t.source = this._convertIdToIndex(t.source, \"image\"));\n  }\n  _convertMeshIds(t) {\n    for (const n of t.primitives) {\n      const {\n        attributes: s,\n        indices: r,\n        material: i\n      } = n;\n      for (const o in s)\n        s[o] = this._convertIdToIndex(s[o], \"accessor\");\n      r && (n.indices = this._convertIdToIndex(r, \"accessor\")), i && (n.material = this._convertIdToIndex(i, \"material\"));\n    }\n  }\n  _convertNodeIds(t) {\n    t.children && (t.children = t.children.map((n) => this._convertIdToIndex(n, \"node\"))), t.meshes && (t.meshes = t.meshes.map((n) => this._convertIdToIndex(n, \"mesh\")));\n  }\n  _convertSceneIds(t) {\n    t.nodes && (t.nodes = t.nodes.map((n) => this._convertIdToIndex(n, \"node\")));\n  }\n  _convertIdsToIndices(t, n) {\n    t[n] || (console.warn(`gltf v1: json doesn't contain attribute ${n}`), t[n] = []);\n    for (const s of t[n])\n      for (const r in s) {\n        const i = s[r], o = this._convertIdToIndex(i, r);\n        s[r] = o;\n      }\n  }\n  _convertIdToIndex(t, n) {\n    const s = vA[n];\n    if (s in this.idToIndexMap) {\n      const r = this.idToIndexMap[s][t];\n      if (!Number.isFinite(r))\n        throw new Error(`gltf v1: failed to resolve ${n} with id ${t}`);\n      return r;\n    }\n    return t;\n  }\n  _updateObjects(t) {\n    for (const n of this.json.buffers)\n      delete n.type;\n  }\n  _updateMaterial(t) {\n    for (const i of t.materials) {\n      var n, s, r;\n      i.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n      const o = ((n = i.values) === null || n === void 0 ? void 0 : n.tex) || ((s = i.values) === null || s === void 0 ? void 0 : s.texture2d_0) || ((r = i.values) === null || r === void 0 ? void 0 : r.diffuseTex), a = t.textures.findIndex((c) => c.id === o);\n      a !== -1 && (i.pbrMetallicRoughness.baseColorTexture = {\n        index: a\n      });\n    }\n  }\n}\nfunction FA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  return new OA().normalize(e, t);\n}\nasync function DA(e, t) {\n  var n, s, r;\n  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = arguments.length > 3 ? arguments[3] : void 0, a = arguments.length > 4 ? arguments[4] : void 0;\n  return LA(e, t, i, o), FA(e, {\n    normalize: o == null || (n = o.gltf) === null || n === void 0 ? void 0 : n.normalize\n  }), SA(e, o, a), o != null && (s = o.gltf) !== null && s !== void 0 && s.loadBuffers && e.json.buffers && await PA(e, o, a), o != null && (r = o.gltf) !== null && r !== void 0 && r.loadImages && await GA(e, o, a), await IA(e, o, a), e;\n}\nfunction LA(e, t, n, s) {\n  if (s.uri && (e.baseUri = s.uri), t instanceof ArrayBuffer && !C0(t, n, s) && (t = new TextDecoder().decode(t)), typeof t == \"string\")\n    e.json = xu(t);\n  else if (t instanceof ArrayBuffer) {\n    const o = {};\n    n = E0(o, t, n, s.glb), yt(o.type === \"glTF\", `Invalid GLB magic string ${o.type}`), e._glb = o, e.json = o.json;\n  } else\n    yt(!1, \"GLTF: must be ArrayBuffer or string\");\n  const r = e.json.buffers || [];\n  if (e.buffers = new Array(r.length).fill(null), e._glb && e._glb.header.hasBinChunk) {\n    const {\n      binChunks: o\n    } = e._glb;\n    e.buffers[0] = {\n      arrayBuffer: o[0].arrayBuffer,\n      byteOffset: o[0].byteOffset,\n      byteLength: o[0].byteLength\n    };\n  }\n  const i = e.json.images || [];\n  e.images = new Array(i.length).fill({});\n}\nasync function PA(e, t, n) {\n  const s = e.json.buffers || [];\n  for (let o = 0; o < s.length; ++o) {\n    const a = s[o];\n    if (a.uri) {\n      var r, i;\n      const {\n        fetch: c\n      } = n;\n      yt(c);\n      const u = Za(a.uri, t), l = await (n == null || (r = n.fetch) === null || r === void 0 ? void 0 : r.call(n, u)), h = await (l == null || (i = l.arrayBuffer) === null || i === void 0 ? void 0 : i.call(l));\n      e.buffers[o] = {\n        arrayBuffer: h,\n        byteOffset: 0,\n        byteLength: h.byteLength\n      }, delete a.uri;\n    } else\n      e.buffers[o] === null && (e.buffers[o] = {\n        arrayBuffer: new ArrayBuffer(a.byteLength),\n        byteOffset: 0,\n        byteLength: a.byteLength\n      });\n  }\n}\nasync function GA(e, t, n) {\n  const s = NA(e), r = e.json.images || [], i = [];\n  for (const o of s)\n    i.push(UA(e, r[o], o, t, n));\n  return await Promise.all(i);\n}\nfunction NA(e) {\n  const t = /* @__PURE__ */ new Set(), n = e.json.textures || [];\n  for (const s of n)\n    s.source !== void 0 && t.add(s.source);\n  return Array.from(t).sort();\n}\nasync function UA(e, t, n, s, r) {\n  let i;\n  if (t.uri && !t.hasOwnProperty(\"bufferView\")) {\n    const a = Za(t.uri, s), {\n      fetch: c\n    } = r;\n    i = await (await c(a)).arrayBuffer(), t.bufferView = {\n      data: i\n    };\n  }\n  if (Number.isFinite(t.bufferView)) {\n    const a = og(e.json, e.buffers, t.bufferView);\n    i = dr(a.buffer, a.byteOffset, a.byteLength);\n  }\n  yt(i, \"glTF image has no data\");\n  let o = await Ke(i, [Qm, d0], {\n    ...s,\n    mimeType: t.mimeType,\n    basis: s.basis || {\n      format: $a()\n    }\n  }, r);\n  o && o[0] && (o = {\n    compressed: !0,\n    mipmaps: !1,\n    width: o[0].width,\n    height: o[0].height,\n    data: o[0]\n  }), e.images = e.images || [], e.images[n] = o;\n}\nconst Nn = {\n  name: \"glTF\",\n  id: \"gltf\",\n  module: \"gltf\",\n  version: $g,\n  extensions: [\"gltf\", \"glb\"],\n  mimeTypes: [\"model/gltf+json\", \"model/gltf-binary\"],\n  text: !0,\n  binary: !0,\n  tests: [\"glTF\"],\n  parse: HA,\n  options: {\n    gltf: {\n      normalize: !0,\n      loadBuffers: !0,\n      loadImages: !0,\n      decompressMeshes: !0\n    },\n    log: console\n  }\n};\nasync function HA(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  t = {\n    ...Nn.options,\n    ...t\n  }, t.gltf = {\n    ...Nn.options.gltf,\n    ...t.gltf\n  };\n  const {\n    byteOffset: s = 0\n  } = t;\n  return await DA({}, e, s, t, n);\n}\nconst JA = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n}, VA = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n}, Bt = {\n  TEXTURE_MAG_FILTER: 10240,\n  TEXTURE_MIN_FILTER: 10241,\n  TEXTURE_WRAP_S: 10242,\n  TEXTURE_WRAP_T: 10243,\n  REPEAT: 10497,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_LINEAR: 9986\n}, jA = {\n  magFilter: Bt.TEXTURE_MAG_FILTER,\n  minFilter: Bt.TEXTURE_MIN_FILTER,\n  wrapS: Bt.TEXTURE_WRAP_S,\n  wrapT: Bt.TEXTURE_WRAP_T\n}, kA = {\n  [Bt.TEXTURE_MAG_FILTER]: Bt.LINEAR,\n  [Bt.TEXTURE_MIN_FILTER]: Bt.NEAREST_MIPMAP_LINEAR,\n  [Bt.TEXTURE_WRAP_S]: Bt.REPEAT,\n  [Bt.TEXTURE_WRAP_T]: Bt.REPEAT\n};\nfunction KA() {\n  return {\n    id: \"default-sampler\",\n    parameters: kA\n  };\n}\nfunction zA(e) {\n  return VA[e];\n}\nfunction WA(e) {\n  return JA[e];\n}\nclass XA {\n  constructor() {\n    this.baseUri = \"\", this.jsonUnprocessed = void 0, this.json = void 0, this.buffers = [], this.images = [];\n  }\n  postProcess(t) {\n    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const {\n      json: s,\n      buffers: r = [],\n      images: i = []\n    } = t, {\n      baseUri: o = \"\"\n    } = t;\n    return yt(s), this.baseUri = o, this.buffers = r, this.images = i, this.jsonUnprocessed = s, this.json = this._resolveTree(t.json, n), this.json;\n  }\n  _resolveTree(t) {\n    const n = {\n      ...t\n    };\n    return this.json = n, t.bufferViews && (n.bufferViews = t.bufferViews.map((s, r) => this._resolveBufferView(s, r))), t.images && (n.images = t.images.map((s, r) => this._resolveImage(s, r))), t.samplers && (n.samplers = t.samplers.map((s, r) => this._resolveSampler(s, r))), t.textures && (n.textures = t.textures.map((s, r) => this._resolveTexture(s, r))), t.accessors && (n.accessors = t.accessors.map((s, r) => this._resolveAccessor(s, r))), t.materials && (n.materials = t.materials.map((s, r) => this._resolveMaterial(s, r))), t.meshes && (n.meshes = t.meshes.map((s, r) => this._resolveMesh(s, r))), t.nodes && (n.nodes = t.nodes.map((s, r) => this._resolveNode(s, r)), n.nodes = n.nodes.map((s, r) => this._resolveNodeChildren(s))), t.skins && (n.skins = t.skins.map((s, r) => this._resolveSkin(s, r))), t.scenes && (n.scenes = t.scenes.map((s, r) => this._resolveScene(s, r))), typeof this.json.scene == \"number\" && n.scenes && (n.scene = n.scenes[this.json.scene]), n;\n  }\n  getScene(t) {\n    return this._get(this.json.scenes, t);\n  }\n  getNode(t) {\n    return this._get(this.json.nodes, t);\n  }\n  getSkin(t) {\n    return this._get(this.json.skins, t);\n  }\n  getMesh(t) {\n    return this._get(this.json.meshes, t);\n  }\n  getMaterial(t) {\n    return this._get(this.json.materials, t);\n  }\n  getAccessor(t) {\n    return this._get(this.json.accessors, t);\n  }\n  getCamera(t) {\n    return this._get(this.json.cameras, t);\n  }\n  getTexture(t) {\n    return this._get(this.json.textures, t);\n  }\n  getSampler(t) {\n    return this._get(this.json.samplers, t);\n  }\n  getImage(t) {\n    return this._get(this.json.images, t);\n  }\n  getBufferView(t) {\n    return this._get(this.json.bufferViews, t);\n  }\n  getBuffer(t) {\n    return this._get(this.json.buffers, t);\n  }\n  _get(t, n) {\n    if (typeof n == \"object\")\n      return n;\n    const s = t && t[n];\n    return s || console.warn(`glTF file error: Could not find ${t}[${n}]`), s;\n  }\n  _resolveScene(t, n) {\n    return {\n      ...t,\n      id: t.id || `scene-${n}`,\n      nodes: (t.nodes || []).map((s) => this.getNode(s))\n    };\n  }\n  _resolveNode(t, n) {\n    const s = {\n      ...t,\n      id: (t == null ? void 0 : t.id) || `node-${n}`\n    };\n    return t.mesh !== void 0 && (s.mesh = this.getMesh(t.mesh)), t.camera !== void 0 && (s.camera = this.getCamera(t.camera)), t.skin !== void 0 && (s.skin = this.getSkin(t.skin)), t.meshes !== void 0 && t.meshes.length && (s.mesh = t.meshes.reduce((r, i) => {\n      const o = this.getMesh(i);\n      return r.id = o.id, r.primitives = r.primitives.concat(o.primitives), r;\n    }, {\n      primitives: []\n    })), s;\n  }\n  _resolveNodeChildren(t) {\n    return t.children && (t.children = t.children.map((n) => this.getNode(n))), t;\n  }\n  _resolveSkin(t, n) {\n    const s = typeof t.inverseBindMatrices == \"number\" ? this.getAccessor(t.inverseBindMatrices) : void 0;\n    return {\n      ...t,\n      id: t.id || `skin-${n}`,\n      inverseBindMatrices: s\n    };\n  }\n  _resolveMesh(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `mesh-${n}`,\n      primitives: []\n    };\n    return t.primitives && (s.primitives = t.primitives.map((r) => {\n      const i = {\n        ...r,\n        attributes: {},\n        indices: void 0,\n        material: void 0\n      }, o = r.attributes;\n      for (const a in o)\n        i.attributes[a] = this.getAccessor(o[a]);\n      return r.indices !== void 0 && (i.indices = this.getAccessor(r.indices)), r.material !== void 0 && (i.material = this.getMaterial(r.material)), i;\n    })), s;\n  }\n  _resolveMaterial(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `material-${n}`\n    };\n    if (s.normalTexture && (s.normalTexture = {\n      ...s.normalTexture\n    }, s.normalTexture.texture = this.getTexture(s.normalTexture.index)), s.occlusionTexture && (s.occlusionTexture = {\n      ...s.occlusionTexture\n    }, s.occlusionTexture.texture = this.getTexture(s.occlusionTexture.index)), s.emissiveTexture && (s.emissiveTexture = {\n      ...s.emissiveTexture\n    }, s.emissiveTexture.texture = this.getTexture(s.emissiveTexture.index)), s.emissiveFactor || (s.emissiveFactor = s.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), s.pbrMetallicRoughness) {\n      s.pbrMetallicRoughness = {\n        ...s.pbrMetallicRoughness\n      };\n      const r = s.pbrMetallicRoughness;\n      r.baseColorTexture && (r.baseColorTexture = {\n        ...r.baseColorTexture\n      }, r.baseColorTexture.texture = this.getTexture(r.baseColorTexture.index)), r.metallicRoughnessTexture && (r.metallicRoughnessTexture = {\n        ...r.metallicRoughnessTexture\n      }, r.metallicRoughnessTexture.texture = this.getTexture(r.metallicRoughnessTexture.index));\n    }\n    return s;\n  }\n  _resolveAccessor(t, n) {\n    const s = zA(t.componentType), r = WA(t.type), i = s * r, o = {\n      ...t,\n      id: t.id || `accessor-${n}`,\n      bytesPerComponent: s,\n      components: r,\n      bytesPerElement: i,\n      value: void 0,\n      bufferView: void 0,\n      sparse: void 0\n    };\n    if (t.bufferView !== void 0 && (o.bufferView = this.getBufferView(t.bufferView)), o.bufferView) {\n      const a = o.bufferView.buffer, {\n        ArrayType: c,\n        byteLength: u\n      } = Ir(o, o.bufferView), l = (o.bufferView.byteOffset || 0) + (o.byteOffset || 0) + a.byteOffset;\n      let h = a.arrayBuffer.slice(l, l + u);\n      o.bufferView.byteStride && (h = this._getValueFromInterleavedBuffer(a, l, o.bufferView.byteStride, o.bytesPerElement, o.count)), o.value = new c(h);\n    }\n    return o;\n  }\n  _getValueFromInterleavedBuffer(t, n, s, r, i) {\n    const o = new Uint8Array(i * r);\n    for (let a = 0; a < i; a++) {\n      const c = n + a * s;\n      o.set(new Uint8Array(t.arrayBuffer.slice(c, c + r)), a * r);\n    }\n    return o.buffer;\n  }\n  _resolveTexture(t, n) {\n    return {\n      ...t,\n      id: t.id || `texture-${n}`,\n      sampler: typeof t.sampler == \"number\" ? this.getSampler(t.sampler) : KA(),\n      source: typeof t.source == \"number\" ? this.getImage(t.source) : void 0\n    };\n  }\n  _resolveSampler(t, n) {\n    const s = {\n      id: t.id || `sampler-${n}`,\n      ...t,\n      parameters: {}\n    };\n    for (const r in s) {\n      const i = this._enumSamplerParameter(r);\n      i !== void 0 && (s.parameters[i] = s[r]);\n    }\n    return s;\n  }\n  _enumSamplerParameter(t) {\n    return jA[t];\n  }\n  _resolveImage(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `image-${n}`,\n      image: null,\n      bufferView: t.bufferView !== void 0 ? this.getBufferView(t.bufferView) : void 0\n    }, r = this.images[n];\n    return r && (s.image = r), s;\n  }\n  _resolveBufferView(t, n) {\n    const s = t.buffer, r = this.buffers[s].arrayBuffer;\n    let i = this.buffers[s].byteOffset || 0;\n    return t.byteOffset && (i += t.byteOffset), {\n      id: `bufferView-${n}`,\n      ...t,\n      buffer: this.buffers[s],\n      data: new Uint8Array(r, i, t.byteLength)\n    };\n  }\n  _resolveCamera(t, n) {\n    const s = {\n      ...t,\n      id: t.id || `camera-${n}`\n    };\n    return s.perspective, s.orthographic, s;\n  }\n}\nfunction rc(e, t) {\n  return new XA().postProcess(e, t);\n}\nconst Zs = {\n  URI: 0,\n  EMBEDDED: 1\n};\nfunction ic(e, t, n, s) {\n  e.rotateYtoZ = !0;\n  const r = (e.byteOffset || 0) + (e.byteLength || 0) - n;\n  if (r === 0)\n    throw new Error(\"glTF byte length must be greater than 0.\");\n  return e.gltfUpAxis = s != null && s[\"3d-tiles\"] && s[\"3d-tiles\"].assetGltfUpAxis ? s[\"3d-tiles\"].assetGltfUpAxis : \"Y\", e.gltfArrayBuffer = dr(t, n, r), e.gltfByteOffset = 0, e.gltfByteLength = r, n % 4 === 0 || console.warn(`${e.type}: embedded glb is not aligned to a 4-byte boundary.`), (e.byteOffset || 0) + (e.byteLength || 0);\n}\nasync function oc(e, t, n, s) {\n  const r = (n == null ? void 0 : n[\"3d-tiles\"]) || {};\n  if (QA(e, t), r.loadGLTF) {\n    if (!s)\n      return;\n    if (e.gltfUrl) {\n      const {\n        fetch: i\n      } = s, o = await i(e.gltfUrl, n);\n      e.gltfArrayBuffer = await o.arrayBuffer(), e.gltfByteOffset = 0;\n    }\n    if (e.gltfArrayBuffer) {\n      const i = await Ke(e.gltfArrayBuffer, Nn, n, s);\n      e.gltf = rc(i), e.gpuMemoryUsageInBytes = Va(e.gltf), delete e.gltfArrayBuffer, delete e.gltfByteOffset, delete e.gltfByteLength;\n    }\n  }\n}\nfunction QA(e, t, n) {\n  switch (t) {\n    case Zs.URI:\n      if (e.gltfArrayBuffer) {\n        const s = new Uint8Array(e.gltfArrayBuffer, e.gltfByteOffset), i = new TextDecoder().decode(s);\n        e.gltfUrl = i.replace(/[\\s\\0]+$/, \"\");\n      }\n      delete e.gltfArrayBuffer, delete e.gltfByteOffset, delete e.gltfByteLength;\n      break;\n    case Zs.EMBEDDED:\n      break;\n    default:\n      throw new Error(\"b3dm: Illegal glTF format field\");\n  }\n}\nasync function qA(e, t, n, s, r) {\n  var i;\n  n = YA(e, t, n, s), await oc(e, Zs.EMBEDDED, s, r);\n  const o = e == null || (i = e.gltf) === null || i === void 0 ? void 0 : i.extensions;\n  return o && o.CESIUM_RTC && (e.rtcCenter = o.CESIUM_RTC.center), n;\n}\nfunction YA(e, t, n, s, r) {\n  n = qn(e, t, n), n = _r(e, t, n), n = wr(e, t, n), n = ic(e, t, n, s);\n  const i = new br(e.featureTableJson, e.featureTableBinary);\n  return e.rtcCenter = i.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3), n;\n}\nasync function $A(e, t, n, s, r) {\n  return n = ZA(e, t, n, s), await oc(e, e.gltfFormat || 0, s, r), n;\n}\nfunction ZA(e, t, n, s, r) {\n  var i;\n  if (n = qn(e, t, n), e.version !== 1)\n    throw new Error(`Instanced 3D Model version ${e.version} is not supported`);\n  n = _r(e, t, n);\n  const o = new DataView(t);\n  if (e.gltfFormat = o.getUint32(n, !0), n += 4, n = wr(e, t, n), n = ic(e, t, n, s), !(e != null && (i = e.header) !== null && i !== void 0 && i.featureTableJsonByteLength) || e.header.featureTableJsonByteLength === 0)\n    throw new Error(\"i3dm parser: featureTableJsonByteLength is zero.\");\n  const a = new br(e.featureTableJson, e.featureTableBinary), c = a.getGlobalProperty(\"INSTANCES_LENGTH\");\n  if (a.featuresLength = c, !Number.isFinite(c))\n    throw new Error(\"i3dm parser: INSTANCES_LENGTH must be defined\");\n  e.eastNorthUp = a.getGlobalProperty(\"EAST_NORTH_UP\"), e.rtcCenter = a.getGlobalProperty(\"RTC_CENTER\", G.FLOAT, 3);\n  const u = new Da(e.batchTableJson, e.batchTableBinary, c);\n  return tp(e, a, u, c), n;\n}\nfunction tp(e, t, n, s) {\n  const r = new Array(s), i = new A();\n  new A(), new A(), new A();\n  const o = new W(), a = new On(), c = new A(), u = {}, l = new V(), h = [], f = [], d = [], m = [];\n  for (let g = 0; g < s; g++) {\n    let y;\n    if (t.hasProperty(\"POSITION\"))\n      y = t.getProperty(\"POSITION\", G.FLOAT, 3, g, i);\n    else if (t.hasProperty(\"POSITION_QUANTIZED\")) {\n      y = t.getProperty(\"POSITION_QUANTIZED\", G.UNSIGNED_SHORT, 3, g, i);\n      const b = t.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", G.FLOAT, 3);\n      if (!b)\n        throw new Error(\"i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      const O = t.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", G.FLOAT, 3);\n      if (!O)\n        throw new Error(\"i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      const F = 65535;\n      for (let v = 0; v < 3; v++)\n        y[v] = y[v] / F * O[v] + b[v];\n    }\n    if (!y)\n      throw new Error(\"i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.\");\n    if (i.copy(y), u.translation = i, e.normalUp = t.getProperty(\"NORMAL_UP\", G.FLOAT, 3, g, h), e.normalRight = t.getProperty(\"NORMAL_RIGHT\", G.FLOAT, 3, g, f), e.normalUp) {\n      if (!e.normalRight)\n        throw new Error(\"i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.\");\n      e.hasCustomOrientation = !0;\n    } else {\n      if (e.octNormalUp = t.getProperty(\"NORMAL_UP_OCT32P\", G.UNSIGNED_SHORT, 2, g, h), e.octNormalRight = t.getProperty(\"NORMAL_RIGHT_OCT32P\", G.UNSIGNED_SHORT, 2, g, f), e.octNormalUp)\n        throw e.octNormalRight ? new Error(\"i3dm: oct-encoded orientation not implemented\") : new Error(\"i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P\");\n      e.eastNorthUp ? (J.WGS84.eastNorthUpToFixedFrame(i, l), l.getRotationMatrix3(o)) : o.identity();\n    }\n    a.fromMatrix3(o), u.rotation = a, c.set(1, 1, 1);\n    const E = t.getProperty(\"SCALE\", G.FLOAT, 1, g, d);\n    Number.isFinite(E) && c.multiplyByScalar(E);\n    const R = t.getProperty(\"SCALE_NON_UNIFORM\", G.FLOAT, 3, g, h);\n    R && c.scale(R), u.scale = c;\n    let B = t.getProperty(\"BATCH_ID\", G.UNSIGNED_SHORT, 1, g, m);\n    B === void 0 && (B = g);\n    const C = new V().fromQuaternion(u.rotation);\n    l.identity(), l.translate(u.translation), l.multiplyRight(C), l.scale(u.scale);\n    const M = l.clone();\n    r[g] = {\n      modelMatrix: M,\n      batchId: B\n    };\n  }\n  e.instances = r;\n}\nasync function ep(e, t, n, s, r, i) {\n  n = qn(e, t, n);\n  const o = new DataView(t);\n  for (e.tilesLength = o.getUint32(n, !0), n += 4, e.tiles = []; e.tiles.length < e.tilesLength && (e.byteLength || 0) - n > 12; ) {\n    const a = {\n      shape: \"tile3d\"\n    };\n    e.tiles.push(a), n = await i(t, n, s, r, a);\n  }\n  return n;\n}\nasync function np(e, t, n, s) {\n  var r, i;\n  if (e.rotateYtoZ = !0, e.gltfUpAxis = n != null && (r = n[\"3d-tiles\"]) !== null && r !== void 0 && r.assetGltfUpAxis ? n[\"3d-tiles\"].assetGltfUpAxis : \"Y\", n != null && (i = n[\"3d-tiles\"]) !== null && i !== void 0 && i.loadGLTF) {\n    if (!s)\n      return t.byteLength;\n    const o = await Ke(t, Nn, n, s);\n    e.gltf = rc(o), e.gpuMemoryUsageInBytes = Va(e.gltf);\n  } else\n    e.gltfArrayBuffer = t;\n  return t.byteLength;\n}\nasync function ac(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 ? arguments[2] : void 0, s = arguments.length > 3 ? arguments[3] : void 0, r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {\n    shape: \"tile3d\"\n  };\n  switch (r.byteOffset = t, r.type = _d(e, t), r.type) {\n    case _e.COMPOSITE:\n      return await ep(r, e, t, n, s, ac);\n    case _e.BATCHED_3D_MODEL:\n      return await qA(r, e, t, n, s);\n    case _e.GLTF:\n      return await np(r, e, n, s);\n    case _e.INSTANCED_3D_MODEL:\n      return await $A(r, e, t, n, s);\n    case _e.POINT_CLOUD:\n      return await cm(r, e, t, n, s);\n    default:\n      throw new Error(`3DTileLoader: unknown type ${r.type}`);\n  }\n}\nconst sp = 1952609651, rp = 1;\nasync function ip(e, t, n) {\n  if (new Uint32Array(e.slice(0, 4))[0] !== sp)\n    throw new Error(\"Wrong subtree file magic number\");\n  if (new Uint32Array(e.slice(4, 8))[0] !== rp)\n    throw new Error(\"Wrong subtree file verson, must be 1\");\n  const i = $i(e.slice(8, 16)), o = new Uint8Array(e, 24, i), c = new TextDecoder(\"utf8\").decode(o), u = JSON.parse(c), l = $i(e.slice(16, 24));\n  let h = new ArrayBuffer(0);\n  if (l && (h = e.slice(24 + i)), await pn(u, u.tileAvailability, h, n), Array.isArray(u.contentAvailability))\n    for (const f of u.contentAvailability)\n      await pn(u, f, h, n);\n  else\n    await pn(u, u.contentAvailability, h, n);\n  return await pn(u, u.childSubtreeAvailability, h, n), u;\n}\nasync function pn(e, t, n, s) {\n  const r = Number.isFinite(t.bitstream) ? t.bitstream : t.bufferView;\n  if (typeof r != \"number\")\n    return;\n  const i = e.bufferViews[r], o = e.buffers[i.buffer];\n  if (!(s != null && s.baseUrl))\n    throw new Error(\"Url is not provided\");\n  if (!s.fetch)\n    throw new Error(\"fetch is not provided\");\n  if (o.uri) {\n    const c = `${(s == null ? void 0 : s.baseUrl) || \"\"}/${o.uri}`, l = await (await s.fetch(c)).arrayBuffer();\n    t.explicitBitstream = new Uint8Array(l, i.byteOffset, i.byteLength);\n    return;\n  }\n  const a = e.buffers.slice(0, i.buffer).reduce((c, u) => c + u.byteLength, 0);\n  t.explicitBitstream = new Uint8Array(n.slice(a, a + o.byteLength), i.byteOffset, i.byteLength);\n}\nfunction $i(e) {\n  const t = new DataView(e), n = t.getUint32(0, !0), s = t.getUint32(4, !0);\n  return n + 2 ** 32 * s;\n}\nconst cc = {\n  id: \"3d-tiles-subtree\",\n  name: \"3D Tiles Subtree\",\n  module: \"3d-tiles\",\n  version: Ia,\n  extensions: [\"subtree\"],\n  mimeTypes: [\"application/octet-stream\"],\n  tests: [\"subtree\"],\n  parse: ip,\n  options: {}\n};\n/**\n * @license\n * Copyright 2009 The Closure Library Authors\n * Copyright 2020 Daniel Wirtz / The long.js Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nvar Et = null;\ntry {\n  Et = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    13,\n    2,\n    96,\n    0,\n    1,\n    127,\n    96,\n    4,\n    127,\n    127,\n    127,\n    127,\n    1,\n    127,\n    3,\n    7,\n    6,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    6,\n    6,\n    1,\n    127,\n    1,\n    65,\n    0,\n    11,\n    7,\n    50,\n    6,\n    3,\n    109,\n    117,\n    108,\n    0,\n    1,\n    5,\n    100,\n    105,\n    118,\n    95,\n    115,\n    0,\n    2,\n    5,\n    100,\n    105,\n    118,\n    95,\n    117,\n    0,\n    3,\n    5,\n    114,\n    101,\n    109,\n    95,\n    115,\n    0,\n    4,\n    5,\n    114,\n    101,\n    109,\n    95,\n    117,\n    0,\n    5,\n    8,\n    103,\n    101,\n    116,\n    95,\n    104,\n    105,\n    103,\n    104,\n    0,\n    0,\n    10,\n    191,\n    1,\n    6,\n    4,\n    0,\n    35,\n    0,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    126,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    127,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    128,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    129,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11,\n    36,\n    1,\n    1,\n    126,\n    32,\n    0,\n    173,\n    32,\n    1,\n    173,\n    66,\n    32,\n    134,\n    132,\n    32,\n    2,\n    173,\n    32,\n    3,\n    173,\n    66,\n    32,\n    134,\n    132,\n    130,\n    34,\n    4,\n    66,\n    32,\n    135,\n    167,\n    36,\n    0,\n    32,\n    4,\n    167,\n    11\n  ])), {}).exports;\n} catch {\n}\nfunction H(e, t, n) {\n  this.low = e | 0, this.high = t | 0, this.unsigned = !!n;\n}\nH.prototype.__isLong__;\nObject.defineProperty(H.prototype, \"__isLong__\", { value: !0 });\nfunction ot(e) {\n  return (e && e.__isLong__) === !0;\n}\nfunction Zi(e) {\n  var t = Math.clz32(e & -e);\n  return e ? 31 - t : t;\n}\nH.isLong = ot;\nvar to = {}, eo = {};\nfunction ie(e, t) {\n  var n, s, r;\n  return t ? (e >>>= 0, (r = 0 <= e && e < 256) && (s = eo[e], s) ? s : (n = N(e, 0, !0), r && (eo[e] = n), n)) : (e |= 0, (r = -128 <= e && e < 128) && (s = to[e], s) ? s : (n = N(e, e < 0 ? -1 : 0, !1), r && (to[e] = n), n));\n}\nH.fromInt = ie;\nfunction Tt(e, t) {\n  if (isNaN(e))\n    return t ? Ut : St;\n  if (t) {\n    if (e < 0)\n      return Ut;\n    if (e >= uc)\n      return fc;\n  } else {\n    if (e <= -so)\n      return mt;\n    if (e + 1 >= so)\n      return hc;\n  }\n  return e < 0 ? Tt(-e, t).neg() : N(e % ye | 0, e / ye | 0, t);\n}\nH.fromNumber = Tt;\nfunction N(e, t, n) {\n  return new H(e, t, n);\n}\nH.fromBits = N;\nvar Un = Math.pow;\nfunction Pr(e, t, n) {\n  if (e.length === 0)\n    throw Error(\"empty string\");\n  if (typeof t == \"number\" ? (n = t, t = !1) : t = !!t, e === \"NaN\" || e === \"Infinity\" || e === \"+Infinity\" || e === \"-Infinity\")\n    return t ? Ut : St;\n  if (n = n || 10, n < 2 || 36 < n)\n    throw RangeError(\"radix\");\n  var s;\n  if ((s = e.indexOf(\"-\")) > 0)\n    throw Error(\"interior hyphen\");\n  if (s === 0)\n    return Pr(e.substring(1), t, n).neg();\n  for (var r = Tt(Un(n, 8)), i = St, o = 0; o < e.length; o += 8) {\n    var a = Math.min(8, e.length - o), c = parseInt(e.substring(o, o + a), n);\n    if (a < 8) {\n      var u = Tt(Un(n, a));\n      i = i.mul(u).add(Tt(c));\n    } else\n      i = i.mul(r), i = i.add(Tt(c));\n  }\n  return i.unsigned = t, i;\n}\nH.fromString = Pr;\nfunction xt(e, t) {\n  return typeof e == \"number\" ? Tt(e, t) : typeof e == \"string\" ? Pr(e, t) : N(e.low, e.high, typeof t == \"boolean\" ? t : e.unsigned);\n}\nH.fromValue = xt;\nvar no = 65536, op = 1 << 24, ye = no * no, uc = ye * ye, so = uc / 2, ro = ie(op), St = ie(0);\nH.ZERO = St;\nvar Ut = ie(0, !0);\nH.UZERO = Ut;\nvar de = ie(1);\nH.ONE = de;\nvar lc = ie(1, !0);\nH.UONE = lc;\nvar tr = ie(-1);\nH.NEG_ONE = tr;\nvar hc = N(-1, 2147483647, !1);\nH.MAX_VALUE = hc;\nvar fc = N(-1, -1, !0);\nH.MAX_UNSIGNED_VALUE = fc;\nvar mt = N(0, -2147483648, !1);\nH.MIN_VALUE = mt;\nvar _ = H.prototype;\n_.toInt = function() {\n  return this.unsigned ? this.low >>> 0 : this.low;\n};\n_.toNumber = function() {\n  return this.unsigned ? (this.high >>> 0) * ye + (this.low >>> 0) : this.high * ye + (this.low >>> 0);\n};\n_.toString = function(t) {\n  if (t = t || 10, t < 2 || 36 < t)\n    throw RangeError(\"radix\");\n  if (this.isZero())\n    return \"0\";\n  if (this.isNegative())\n    if (this.eq(mt)) {\n      var n = Tt(t), s = this.div(n), r = s.mul(n).sub(this);\n      return s.toString(t) + r.toInt().toString(t);\n    } else\n      return \"-\" + this.neg().toString(t);\n  for (var i = Tt(Un(t, 6), this.unsigned), o = this, a = \"\"; ; ) {\n    var c = o.div(i), u = o.sub(c.mul(i)).toInt() >>> 0, l = u.toString(t);\n    if (o = c, o.isZero())\n      return l + a;\n    for (; l.length < 6; )\n      l = \"0\" + l;\n    a = \"\" + l + a;\n  }\n};\n_.getHighBits = function() {\n  return this.high;\n};\n_.getHighBitsUnsigned = function() {\n  return this.high >>> 0;\n};\n_.getLowBits = function() {\n  return this.low;\n};\n_.getLowBitsUnsigned = function() {\n  return this.low >>> 0;\n};\n_.getNumBitsAbs = function() {\n  if (this.isNegative())\n    return this.eq(mt) ? 64 : this.neg().getNumBitsAbs();\n  for (var t = this.high != 0 ? this.high : this.low, n = 31; n > 0 && !(t & 1 << n); n--)\n    ;\n  return this.high != 0 ? n + 33 : n + 1;\n};\n_.isZero = function() {\n  return this.high === 0 && this.low === 0;\n};\n_.eqz = _.isZero;\n_.isNegative = function() {\n  return !this.unsigned && this.high < 0;\n};\n_.isPositive = function() {\n  return this.unsigned || this.high >= 0;\n};\n_.isOdd = function() {\n  return (this.low & 1) === 1;\n};\n_.isEven = function() {\n  return (this.low & 1) === 0;\n};\n_.equals = function(t) {\n  return ot(t) || (t = xt(t)), this.unsigned !== t.unsigned && this.high >>> 31 === 1 && t.high >>> 31 === 1 ? !1 : this.high === t.high && this.low === t.low;\n};\n_.eq = _.equals;\n_.notEquals = function(t) {\n  return !this.eq(\n    /* validates */\n    t\n  );\n};\n_.neq = _.notEquals;\n_.ne = _.notEquals;\n_.lessThan = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) < 0;\n};\n_.lt = _.lessThan;\n_.lessThanOrEqual = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) <= 0;\n};\n_.lte = _.lessThanOrEqual;\n_.le = _.lessThanOrEqual;\n_.greaterThan = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) > 0;\n};\n_.gt = _.greaterThan;\n_.greaterThanOrEqual = function(t) {\n  return this.comp(\n    /* validates */\n    t\n  ) >= 0;\n};\n_.gte = _.greaterThanOrEqual;\n_.ge = _.greaterThanOrEqual;\n_.compare = function(t) {\n  if (ot(t) || (t = xt(t)), this.eq(t))\n    return 0;\n  var n = this.isNegative(), s = t.isNegative();\n  return n && !s ? -1 : !n && s ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1;\n};\n_.comp = _.compare;\n_.negate = function() {\n  return !this.unsigned && this.eq(mt) ? mt : this.not().add(de);\n};\n_.neg = _.negate;\n_.add = function(t) {\n  ot(t) || (t = xt(t));\n  var n = this.high >>> 16, s = this.high & 65535, r = this.low >>> 16, i = this.low & 65535, o = t.high >>> 16, a = t.high & 65535, c = t.low >>> 16, u = t.low & 65535, l = 0, h = 0, f = 0, d = 0;\n  return d += i + u, f += d >>> 16, d &= 65535, f += r + c, h += f >>> 16, f &= 65535, h += s + a, l += h >>> 16, h &= 65535, l += n + o, l &= 65535, N(f << 16 | d, l << 16 | h, this.unsigned);\n};\n_.subtract = function(t) {\n  return ot(t) || (t = xt(t)), this.add(t.neg());\n};\n_.sub = _.subtract;\n_.multiply = function(t) {\n  if (this.isZero())\n    return this;\n  if (ot(t) || (t = xt(t)), Et) {\n    var n = Et.mul(\n      this.low,\n      this.high,\n      t.low,\n      t.high\n    );\n    return N(n, Et.get_high(), this.unsigned);\n  }\n  if (t.isZero())\n    return this.unsigned ? Ut : St;\n  if (this.eq(mt))\n    return t.isOdd() ? mt : St;\n  if (t.eq(mt))\n    return this.isOdd() ? mt : St;\n  if (this.isNegative())\n    return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg();\n  if (t.isNegative())\n    return this.mul(t.neg()).neg();\n  if (this.lt(ro) && t.lt(ro))\n    return Tt(this.toNumber() * t.toNumber(), this.unsigned);\n  var s = this.high >>> 16, r = this.high & 65535, i = this.low >>> 16, o = this.low & 65535, a = t.high >>> 16, c = t.high & 65535, u = t.low >>> 16, l = t.low & 65535, h = 0, f = 0, d = 0, m = 0;\n  return m += o * l, d += m >>> 16, m &= 65535, d += i * l, f += d >>> 16, d &= 65535, d += o * u, f += d >>> 16, d &= 65535, f += r * l, h += f >>> 16, f &= 65535, f += i * u, h += f >>> 16, f &= 65535, f += o * c, h += f >>> 16, f &= 65535, h += s * l + r * u + i * c + o * a, h &= 65535, N(d << 16 | m, h << 16 | f, this.unsigned);\n};\n_.mul = _.multiply;\n_.divide = function(t) {\n  if (ot(t) || (t = xt(t)), t.isZero())\n    throw Error(\"division by zero\");\n  if (Et) {\n    if (!this.unsigned && this.high === -2147483648 && t.low === -1 && t.high === -1)\n      return this;\n    var n = (this.unsigned ? Et.div_u : Et.div_s)(\n      this.low,\n      this.high,\n      t.low,\n      t.high\n    );\n    return N(n, Et.get_high(), this.unsigned);\n  }\n  if (this.isZero())\n    return this.unsigned ? Ut : St;\n  var s, r, i;\n  if (this.unsigned) {\n    if (t.unsigned || (t = t.toUnsigned()), t.gt(this))\n      return Ut;\n    if (t.gt(this.shru(1)))\n      return lc;\n    i = Ut;\n  } else {\n    if (this.eq(mt)) {\n      if (t.eq(de) || t.eq(tr))\n        return mt;\n      if (t.eq(mt))\n        return de;\n      var o = this.shr(1);\n      return s = o.div(t).shl(1), s.eq(St) ? t.isNegative() ? de : tr : (r = this.sub(t.mul(s)), i = s.add(r.div(t)), i);\n    } else if (t.eq(mt))\n      return this.unsigned ? Ut : St;\n    if (this.isNegative())\n      return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg();\n    if (t.isNegative())\n      return this.div(t.neg()).neg();\n    i = St;\n  }\n  for (r = this; r.gte(t); ) {\n    s = Math.max(1, Math.floor(r.toNumber() / t.toNumber()));\n    for (var a = Math.ceil(Math.log(s) / Math.LN2), c = a <= 48 ? 1 : Un(2, a - 48), u = Tt(s), l = u.mul(t); l.isNegative() || l.gt(r); )\n      s -= c, u = Tt(s, this.unsigned), l = u.mul(t);\n    u.isZero() && (u = de), i = i.add(u), r = r.sub(l);\n  }\n  return i;\n};\n_.div = _.divide;\n_.modulo = function(t) {\n  if (ot(t) || (t = xt(t)), Et) {\n    var n = (this.unsigned ? Et.rem_u : Et.rem_s)(\n      this.low,\n      this.high,\n      t.low,\n      t.high\n    );\n    return N(n, Et.get_high(), this.unsigned);\n  }\n  return this.sub(this.div(t).mul(t));\n};\n_.mod = _.modulo;\n_.rem = _.modulo;\n_.not = function() {\n  return N(~this.low, ~this.high, this.unsigned);\n};\n_.countLeadingZeros = function() {\n  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n};\n_.clz = _.countLeadingZeros;\n_.countTrailingZeros = function() {\n  return this.low ? Zi(this.low) : Zi(this.high) + 32;\n};\n_.ctz = _.countTrailingZeros;\n_.and = function(t) {\n  return ot(t) || (t = xt(t)), N(this.low & t.low, this.high & t.high, this.unsigned);\n};\n_.or = function(t) {\n  return ot(t) || (t = xt(t)), N(this.low | t.low, this.high | t.high, this.unsigned);\n};\n_.xor = function(t) {\n  return ot(t) || (t = xt(t)), N(this.low ^ t.low, this.high ^ t.high, this.unsigned);\n};\n_.shiftLeft = function(t) {\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? N(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : N(0, this.low << t - 32, this.unsigned);\n};\n_.shl = _.shiftLeft;\n_.shiftRight = function(t) {\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? N(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : N(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n};\n_.shr = _.shiftRight;\n_.shiftRightUnsigned = function(t) {\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t < 32 ? N(this.low >>> t | this.high << 32 - t, this.high >>> t, this.unsigned) : t === 32 ? N(this.high, 0, this.unsigned) : N(this.high >>> t - 32, 0, this.unsigned);\n};\n_.shru = _.shiftRightUnsigned;\n_.shr_u = _.shiftRightUnsigned;\n_.rotateLeft = function(t) {\n  var n;\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? N(this.high, this.low, this.unsigned) : t < 32 ? (n = 32 - t, N(this.low << t | this.high >>> n, this.high << t | this.low >>> n, this.unsigned)) : (t -= 32, n = 32 - t, N(this.high << t | this.low >>> n, this.low << t | this.high >>> n, this.unsigned));\n};\n_.rotl = _.rotateLeft;\n_.rotateRight = function(t) {\n  var n;\n  return ot(t) && (t = t.toInt()), (t &= 63) === 0 ? this : t === 32 ? N(this.high, this.low, this.unsigned) : t < 32 ? (n = 32 - t, N(this.high << n | this.low >>> t, this.low << n | this.high >>> t, this.unsigned)) : (t -= 32, n = 32 - t, N(this.low << n | this.high >>> t, this.high << n | this.low >>> t, this.unsigned));\n};\n_.rotr = _.rotateRight;\n_.toSigned = function() {\n  return this.unsigned ? N(this.low, this.high, !1) : this;\n};\n_.toUnsigned = function() {\n  return this.unsigned ? this : N(this.low, this.high, !0);\n};\n_.toBytes = function(t) {\n  return t ? this.toBytesLE() : this.toBytesBE();\n};\n_.toBytesLE = function() {\n  var t = this.high, n = this.low;\n  return [\n    n & 255,\n    n >>> 8 & 255,\n    n >>> 16 & 255,\n    n >>> 24,\n    t & 255,\n    t >>> 8 & 255,\n    t >>> 16 & 255,\n    t >>> 24\n  ];\n};\n_.toBytesBE = function() {\n  var t = this.high, n = this.low;\n  return [\n    t >>> 24,\n    t >>> 16 & 255,\n    t >>> 8 & 255,\n    t & 255,\n    n >>> 24,\n    n >>> 16 & 255,\n    n >>> 8 & 255,\n    n & 255\n  ];\n};\nH.fromBytes = function(t, n, s) {\n  return s ? H.fromBytesLE(t, n) : H.fromBytesBE(t, n);\n};\nH.fromBytesLE = function(t, n) {\n  return new H(\n    t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24,\n    t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24,\n    n\n  );\n};\nH.fromBytesBE = function(t, n) {\n  return new H(\n    t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7],\n    t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3],\n    n\n  );\n};\nconst ap = 16;\nfunction dc(e) {\n  e === \"X\" && (e = \"\");\n  const t = e.padEnd(ap, \"0\");\n  return H.fromString(t, !0, 16);\n}\nfunction cp(e) {\n  if (e.isZero())\n    return \"X\";\n  let t = e.countTrailingZeros();\n  const n = t % 4;\n  t = (t - n) / 4;\n  const s = t;\n  t *= 4;\n  const i = e.shiftRightUnsigned(t).toString(16).replace(/0+$/, \"\");\n  return Array(17 - s - i.length).join(\"0\") + i;\n}\nfunction up(e, t) {\n  const n = lp(e).shiftRightUnsigned(2);\n  return e.add(H.fromNumber(2 * t + 1 - 4).multiply(n));\n}\nfunction lp(e) {\n  return e.and(e.not().add(1));\n}\nconst hp = 3, fp = 30, dp = 2 * fp + 1, io = 180 / Math.PI;\nfunction mp(e) {\n  if (e.length === 0)\n    throw new Error(`Invalid Hilbert quad key ${e}`);\n  const t = e.split(\"/\"), n = parseInt(t[0], 10), s = t[1], r = s.length;\n  let i = 0;\n  const o = [0, 0];\n  for (let a = r - 1; a >= 0; a--) {\n    i = r - a;\n    const c = s[a];\n    let u = 0, l = 0;\n    c === \"1\" ? l = 1 : c === \"2\" ? (u = 1, l = 1) : c === \"3\" && (u = 1);\n    const h = Math.pow(2, i - 1);\n    Ap(h, o, u, l), o[0] += h * u, o[1] += h * l;\n  }\n  if (n % 2 === 1) {\n    const a = o[0];\n    o[0] = o[1], o[1] = a;\n  }\n  return {\n    face: n,\n    ij: o,\n    level: i\n  };\n}\nfunction gp(e) {\n  if (e.isZero())\n    return \"\";\n  let t = e.toString(2);\n  for (; t.length < hp + dp; )\n    t = \"0\" + t;\n  const n = t.lastIndexOf(\"1\"), s = t.substring(0, 3), r = t.substring(3, n), i = r.length / 2, o = H.fromString(s, !0, 2).toString(10);\n  let a = \"\";\n  if (i !== 0)\n    for (a = H.fromString(r, !0, 2).toString(4); a.length < i; )\n      a = \"0\" + a;\n  return `${o}/${a}`;\n}\nfunction mc(e, t, n) {\n  const s = 1 << t;\n  return [(e[0] + n[0]) / s, (e[1] + n[1]) / s];\n}\nfunction oo(e) {\n  return e >= 0.5 ? 1 / 3 * (4 * e * e - 1) : 1 / 3 * (1 - 4 * (1 - e) * (1 - e));\n}\nfunction gc(e) {\n  return [oo(e[0]), oo(e[1])];\n}\nfunction Ac(e, t) {\n  let [n, s] = t;\n  switch (e) {\n    case 0:\n      return [1, n, s];\n    case 1:\n      return [-n, 1, s];\n    case 2:\n      return [-n, -s, 1];\n    case 3:\n      return [-1, -s, -n];\n    case 4:\n      return [s, -1, -n];\n    case 5:\n      return [s, n, -1];\n    default:\n      throw new Error(\"Invalid face\");\n  }\n}\nfunction pc(e) {\n  let [t, n, s] = e;\n  const r = Math.atan2(s, Math.sqrt(t * t + n * n));\n  return [Math.atan2(n, t) * io, r * io];\n}\nfunction Ap(e, t, n, s) {\n  if (s === 0) {\n    n === 1 && (t[0] = e - 1 - t[0], t[1] = e - 1 - t[1]);\n    const r = t[0];\n    t[0] = t[1], t[1] = r;\n  }\n}\nfunction pp(e) {\n  const t = mc(e.ij, e.level, [0.5, 0.5]), n = gc(t), s = Ac(e.face, n);\n  return pc(s);\n}\nconst yp = 100;\nfunction ao(e) {\n  const {\n    face: t,\n    ij: n,\n    level: s\n  } = e, r = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]], i = Math.max(1, Math.ceil(yp * Math.pow(2, -s))), o = new Float64Array(4 * i * 2 + 2);\n  let a = 0, c = 0;\n  for (let u = 0; u < 4; u++) {\n    const l = r[u].slice(0), h = r[u + 1], f = (h[0] - l[0]) / i, d = (h[1] - l[1]) / i;\n    for (let m = 0; m < i; m++) {\n      l[0] += f, l[1] += d;\n      const g = mc(n, s, l), y = gc(g), E = Ac(t, y), R = pc(E);\n      Math.abs(R[1]) > 89.999 && (R[0] = c);\n      const B = R[0] - c;\n      R[0] += B > 180 ? -360 : B < -180 ? 360 : 0, o[a++] = R[0], o[a++] = R[1], c = R[0];\n    }\n  }\n  return o[a++] = o[0], o[a++] = o[1], o;\n}\nfunction Gr(e) {\n  const t = Bp(e);\n  return mp(t);\n}\nfunction Bp(e) {\n  if (e.indexOf(\"/\") > 0)\n    return e;\n  const t = dc(e);\n  return gp(t);\n}\nfunction Cp(e) {\n  const t = Gr(e);\n  return pp(t);\n}\nfunction Ep(e) {\n  let t;\n  if (e.face === 2 || e.face === 5) {\n    let n = null, s = 0;\n    for (let r = 0; r < 4; r++) {\n      const i = `${e.face}/${r}`, o = Gr(i), a = ao(o);\n      (typeof n > \"u\" || n === null) && (n = new Float64Array(4 * a.length)), n.set(a, s), s += a.length;\n    }\n    t = co(n);\n  } else {\n    const n = ao(e);\n    t = co(n);\n  }\n  return t;\n}\nfunction co(e) {\n  if (e.length % 2 !== 0)\n    throw new Error(\"Invalid corners\");\n  const t = [], n = [];\n  for (let s = 0; s < e.length; s += 2)\n    t.push(e[s]), n.push(e[s + 1]);\n  return t.sort((s, r) => s - r), n.sort((s, r) => s - r), {\n    west: t[0],\n    east: t[t.length - 1],\n    north: n[n.length - 1],\n    south: n[0]\n  };\n}\nfunction Tp(e, t) {\n  const n = (t == null ? void 0 : t.minimumHeight) || 0, s = (t == null ? void 0 : t.maximumHeight) || 0, r = Gr(e), i = Ep(r), o = i.west, a = i.south, c = i.east, u = i.north, l = [];\n  return l.push(new A(o, u, n)), l.push(new A(c, u, n)), l.push(new A(c, a, n)), l.push(new A(o, a, n)), l.push(new A(o, u, s)), l.push(new A(c, u, s)), l.push(new A(c, a, s)), l.push(new A(o, a, s)), l;\n}\nfunction yc(e) {\n  const t = e.token, n = {\n    minimumHeight: e.minimumHeight,\n    maximumHeight: e.maximumHeight\n  }, s = Tp(t, n), r = Cp(t), i = r[0], o = r[1], a = J.WGS84.cartographicToCartesian([i, o, n.maximumHeight]), c = new A(a[0], a[1], a[2]);\n  s.push(c);\n  const u = Td(s);\n  return [...u.center, ...u.halfAxes];\n}\nconst bp = 4, _p = 8, wp = {\n  QUADTREE: bp,\n  OCTREE: _p\n};\nfunction Rp(e, t, n) {\n  if (e != null && e.box) {\n    const s = dc(e.s2VolumeInfo.token), r = up(s, t), i = cp(r), o = {\n      ...e.s2VolumeInfo\n    };\n    switch (o.token = i, n) {\n      case \"OCTREE\":\n        const u = e.s2VolumeInfo, l = u.maximumHeight - u.minimumHeight, h = l / 2, f = u.minimumHeight + l / 2;\n        u.minimumHeight = f - h, u.maximumHeight = f + h;\n        break;\n    }\n    return {\n      box: yc(o),\n      s2VolumeInfo: o\n    };\n  }\n}\nasync function Bc(e) {\n  const {\n    implicitOptions: t,\n    parentData: n = {\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    },\n    childIndex: s = 0,\n    s2VolumeBox: r,\n    loaderOptions: i\n  } = e;\n  let {\n    subtree: o,\n    level: a = 0,\n    globalData: c = {\n      level: 0,\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  } = e;\n  const {\n    subdivisionScheme: u,\n    subtreeLevels: l,\n    maximumLevel: h,\n    contentUrlTemplate: f,\n    subtreesUriTemplate: d,\n    basePath: m\n  } = t, g = {\n    children: [],\n    lodMetricValue: 0,\n    contentUrl: \"\"\n  };\n  if (!h)\n    return ia.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${f} won't be loaded...`), g;\n  const y = a + c.level;\n  if (y > h)\n    return g;\n  const E = wp[u], R = Math.log2(E), B = s & 1, C = s >> 1 & 1, M = s >> 2 & 1, b = (E ** a - 1) / (E - 1);\n  let O = Qt(n.mortonIndex, s, R), F = b + O, v = Qt(n.x, B, 1), L = Qt(n.y, C, 1), k = Qt(n.z, M, 1), X = !1;\n  a >= l && (X = Ss(o.childSubtreeAvailability, O));\n  const Q = Qt(c.x, v, a), P = Qt(c.y, L, a), at = Qt(c.z, k, a);\n  if (X) {\n    const et = `${m}/${d}`, Pt = er(et, y, Q, P, at);\n    o = await Ae(Pt, cc, i), c = {\n      mortonIndex: O,\n      x: v,\n      y: L,\n      z: k,\n      level: a\n    }, O = 0, F = 0, v = 0, L = 0, k = 0, a = 0;\n  }\n  if (!Ss(o.tileAvailability, F))\n    return g;\n  Ss(o.contentAvailability, F) && (g.contentUrl = er(f, y, Q, P, at));\n  const Be = a + 1, Lt = {\n    mortonIndex: O,\n    x: v,\n    y: L,\n    z: k\n  };\n  for (let et = 0; et < E; et++) {\n    const Pt = Rp(r, et, u), Xt = await Bc({\n      subtree: o,\n      implicitOptions: t,\n      loaderOptions: i,\n      parentData: Lt,\n      childIndex: et,\n      level: Be,\n      globalData: {\n        ...c\n      },\n      s2VolumeBox: Pt\n    });\n    if (Xt.contentUrl || Xt.children.length) {\n      const Ce = y + 1, es = Mp(Xt, Ce, {\n        childTileX: v,\n        childTileY: L,\n        childTileZ: k\n      }, t, r);\n      g.children.push(es);\n    }\n  }\n  return g;\n}\nfunction Ss(e, t) {\n  let n;\n  return Array.isArray(e) ? (n = e[0], e.length > 1 && ia.once('Not supported extension \"3DTILES_multiple_contents\" has been detected')) : n = e, \"constant\" in n ? !!n.constant : n.explicitBitstream ? xp(t, n.explicitBitstream) : !1;\n}\nfunction Mp(e, t, n, s, r) {\n  const {\n    basePath: i,\n    refine: o,\n    getRefine: a,\n    lodMetricType: c,\n    getTileType: u,\n    rootLodMetricValue: l,\n    rootBoundingVolume: h\n  } = s, f = e.contentUrl && e.contentUrl.replace(`${i}/`, \"\"), d = l / 2 ** t, m = r != null && r.box ? {\n    box: r.box\n  } : h, g = Sp(t, m, n);\n  return {\n    children: e.children,\n    contentUrl: e.contentUrl,\n    content: {\n      uri: f\n    },\n    id: e.contentUrl,\n    refine: a(o),\n    type: u(e),\n    lodMetricType: c,\n    lodMetricValue: d,\n    geometricError: d,\n    transform: e.transform,\n    boundingVolume: g\n  };\n}\nfunction Sp(e, t, n) {\n  if (t.region) {\n    const {\n      childTileX: s,\n      childTileY: r,\n      childTileZ: i\n    } = n, [o, a, c, u, l, h] = t.region, f = 2 ** e, d = (c - o) / f, m = (u - a) / f, g = (h - l) / f, [y, E] = [o + d * s, o + d * (s + 1)], [R, B] = [a + m * r, a + m * (r + 1)], [C, M] = [l + g * i, l + g * (i + 1)];\n    return {\n      region: [y, R, E, B, C, M]\n    };\n  }\n  if (t.box)\n    return t;\n  throw new Error(`Unsupported bounding volume type ${t}`);\n}\nfunction Qt(e, t, n) {\n  return (e << n) + t;\n}\nfunction er(e, t, n, s, r) {\n  const i = Ip({\n    level: t,\n    x: n,\n    y: s,\n    z: r\n  });\n  return e.replace(/{level}|{x}|{y}|{z}/gi, (o) => i[o]);\n}\nfunction Ip(e) {\n  const t = {};\n  for (const n in e)\n    t[`{${n}}`] = e[n];\n  return t;\n}\nfunction xp(e, t) {\n  const n = Math.floor(e / 8), s = e % 8;\n  return (t[n] >> s & 1) === 1;\n}\nfunction Nr(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n  if (!t)\n    return dn.EMPTY;\n  const s = t.split(\"?\")[0].split(\".\").pop();\n  switch (s) {\n    case \"pnts\":\n      return dn.POINTCLOUD;\n    case \"i3dm\":\n    case \"b3dm\":\n    case \"glb\":\n    case \"gltf\":\n      return dn.SCENEGRAPH;\n    default:\n      return s || dn.EMPTY;\n  }\n}\nfunction Ur(e) {\n  switch (e) {\n    case \"REPLACE\":\n    case \"replace\":\n      return Si.REPLACE;\n    case \"ADD\":\n    case \"add\":\n      return Si.ADD;\n    default:\n      return e;\n  }\n}\nfunction nr(e, t) {\n  if (/^[a-z][0-9a-z+.-]*:/i.test(t)) {\n    const s = new URL(e, `${t}/`);\n    return decodeURI(s.toString());\n  } else if (e.startsWith(\"/\"))\n    return e;\n  return Hu(t, e);\n}\nfunction uo(e, t) {\n  if (!e)\n    return null;\n  let n;\n  if (e.content) {\n    var s;\n    const i = e.content.uri || ((s = e.content) === null || s === void 0 ? void 0 : s.url);\n    typeof i < \"u\" && (n = nr(i, t));\n  }\n  return {\n    ...e,\n    id: n,\n    contentUrl: n,\n    lodMetricType: Qn.GEOMETRIC_ERROR,\n    lodMetricValue: e.geometricError,\n    transformMatrix: e.transform,\n    type: Nr(e, n),\n    refine: Ur(e.refine)\n  };\n}\nasync function vp(e, t, n) {\n  let s = null;\n  const r = ho(e.root);\n  r && e.root ? s = await lo(e.root, e, t, r, n) : s = uo(e.root, t);\n  const i = [];\n  for (i.push(s); i.length > 0; ) {\n    const o = i.pop() || {}, a = o.children || [], c = [];\n    for (const u of a) {\n      const l = ho(u);\n      let h;\n      l ? h = await lo(u, e, t, l, n) : h = uo(u, t), h && (c.push(h), i.push(h));\n    }\n    o.children = c;\n  }\n  return s;\n}\nasync function lo(e, t, n, s, r) {\n  var i, o, a;\n  const {\n    subdivisionScheme: c,\n    maximumLevel: u,\n    availableLevels: l,\n    subtreeLevels: h,\n    subtrees: {\n      uri: f\n    }\n  } = s, d = er(f, 0, 0, 0, 0), m = nr(d, n), g = await Ae(m, cc, r), y = (i = e.content) === null || i === void 0 ? void 0 : i.uri, E = y ? nr(y, n) : \"\", R = t == null || (o = t.root) === null || o === void 0 ? void 0 : o.refine, B = e.geometricError, C = (a = e.boundingVolume.extensions) === null || a === void 0 ? void 0 : a[\"3DTILES_bounding_volume_S2\"];\n  if (C) {\n    const F = {\n      box: yc(C),\n      s2VolumeInfo: C\n    };\n    e.boundingVolume = F;\n  }\n  const M = e.boundingVolume, b = {\n    contentUrlTemplate: E,\n    subtreesUriTemplate: f,\n    subdivisionScheme: c,\n    subtreeLevels: h,\n    maximumLevel: Number.isFinite(l) ? l - 1 : u,\n    refine: R,\n    basePath: n,\n    lodMetricType: Qn.GEOMETRIC_ERROR,\n    rootLodMetricValue: B,\n    rootBoundingVolume: M,\n    getTileType: Nr,\n    getRefine: Ur\n  };\n  return await Op(e, n, g, b, r);\n}\nasync function Op(e, t, n, s, r) {\n  if (!e)\n    return null;\n  const {\n    children: i,\n    contentUrl: o\n  } = await Bc({\n    subtree: n,\n    implicitOptions: s,\n    loaderOptions: r\n  });\n  let a, c = null;\n  return o && (a = o, c = {\n    uri: o.replace(`${t}/`, \"\")\n  }), {\n    ...e,\n    id: a,\n    contentUrl: a,\n    lodMetricType: Qn.GEOMETRIC_ERROR,\n    lodMetricValue: e.geometricError,\n    transformMatrix: e.transform,\n    type: Nr(e, a),\n    refine: Ur(e.refine),\n    content: c || e.content,\n    children: i\n  };\n}\nfunction ho(e) {\n  var t;\n  return (e == null || (t = e.extensions) === null || t === void 0 ? void 0 : t[\"3DTILES_implicit_tiling\"]) || (e == null ? void 0 : e.implicitTiling);\n}\nconst Le = {\n  id: \"3d-tiles\",\n  name: \"3D Tiles\",\n  module: \"3d-tiles\",\n  version: Ia,\n  extensions: [\"cmpt\", \"pnts\", \"b3dm\", \"i3dm\"],\n  mimeTypes: [\"application/octet-stream\"],\n  tests: [\"cmpt\", \"pnts\", \"b3dm\", \"i3dm\"],\n  parse: Fp,\n  options: {\n    \"3d-tiles\": {\n      loadGLTF: !0,\n      decodeQuantizedPositions: !1,\n      isTileset: \"auto\",\n      assetGltfUpAxis: null\n    }\n  }\n};\nasync function Fp(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;\n  const s = t[\"3d-tiles\"] || {};\n  let r;\n  return s.isTileset === \"auto\" ? r = (n == null ? void 0 : n.url) && n.url.indexOf(\".json\") !== -1 : r = s.isTileset, r ? Dp(e, t, n) : Lp(e, t, n);\n}\nasync function Dp(e, t, n) {\n  var s;\n  const r = JSON.parse(new TextDecoder().decode(e)), i = (n == null ? void 0 : n.url) || \"\", o = Pp(i), a = await vp(r, o, t || {});\n  return {\n    ...r,\n    shape: \"tileset3d\",\n    loader: Le,\n    url: i,\n    queryString: (n == null ? void 0 : n.queryString) || \"\",\n    basePath: o,\n    root: a || r.root,\n    type: bd.TILES3D,\n    lodMetricType: Qn.GEOMETRIC_ERROR,\n    lodMetricValue: ((s = r.root) === null || s === void 0 ? void 0 : s.geometricError) || 0\n  };\n}\nasync function Lp(e, t, n) {\n  const s = {\n    content: {\n      shape: \"tile3d\",\n      featureIds: null\n    }\n  };\n  return await ac(e, 0, t, n, s.content), s.content;\n}\nfunction Pp(e) {\n  return Zo(e);\n}\nconst Cc = \"https://api.cesium.com/v1/assets\";\nasync function Gp(e, t) {\n  if (!t) {\n    const i = await Np(e);\n    for (const o of i.items)\n      o.type === \"3DTILES\" && (t = o.id);\n  }\n  const n = await Up(e, t), {\n    type: s,\n    url: r\n  } = n;\n  return K(s === \"3DTILES\" && r), n.headers = {\n    Authorization: `Bearer ${n.accessToken}`\n  }, n;\n}\nasync function Np(e) {\n  K(e);\n  const t = Cc, n = {\n    Authorization: `Bearer ${e}`\n  }, s = await Ge(t, {\n    headers: n\n  });\n  if (!s.ok)\n    throw new Error(s.statusText);\n  return await s.json();\n}\nasync function Up(e, t) {\n  K(e, t);\n  const n = {\n    Authorization: `Bearer ${e}`\n  }, s = `${Cc}/${t}`;\n  let r = await Ge(`${s}`, {\n    headers: n\n  });\n  if (!r.ok)\n    throw new Error(r.statusText);\n  let i = await r.json();\n  if (r = await Ge(`${s}/endpoint`, {\n    headers: n\n  }), !r.ok)\n    throw new Error(r.statusText);\n  const o = await r.json();\n  return i = {\n    ...i,\n    ...o\n  }, i;\n}\nasync function Hp(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n  t = t[\"cesium-ion\"] || {};\n  const {\n    accessToken: n\n  } = t;\n  let s = t.assetId;\n  if (!Number.isFinite(s)) {\n    const r = e.match(/\\/([0-9]+)\\/tileset.json/);\n    s = r && r[1];\n  }\n  return Gp(n, s);\n}\nconst Ec = {\n  ...Le,\n  id: \"cesium-ion\",\n  name: \"Cesium Ion\",\n  preload: Hp,\n  parse: async (e, t, n) => (t = {\n    ...t\n  }, t[\"3d-tiles\"] = t[\"cesium-ion\"], t.loader = Ec, Le.parse(e, t, n)),\n  options: {\n    \"cesium-ion\": {\n      ...Le.options[\"3d-tiles\"],\n      accessToken: null\n    }\n  }\n}, fo = 100;\nclass Jp {\n  constructor(t, n) {\n    if (this.schema = void 0, this.options = void 0, this.shape = void 0, this.length = 0, this.rows = null, this.cursor = 0, this._headers = [], this.options = n, this.schema = t, !Array.isArray(t)) {\n      this._headers = [];\n      for (const s in t)\n        this._headers[t[s].index] = t[s].name;\n    }\n  }\n  rowCount() {\n    return this.length;\n  }\n  addArrayRow(t, n) {\n    Number.isFinite(n) && (this.cursor = n), this.shape = \"array-row-table\", this.rows = this.rows || new Array(fo), this.rows[this.length] = t, this.length++;\n  }\n  addObjectRow(t, n) {\n    Number.isFinite(n) && (this.cursor = n), this.shape = \"object-row-table\", this.rows = this.rows || new Array(fo), this.rows[this.length] = t, this.length++;\n  }\n  getBatch() {\n    let t = this.rows;\n    return t ? (t = t.slice(0, this.length), this.rows = null, {\n      shape: this.shape || \"array-row-table\",\n      batchType: \"data\",\n      data: t,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    }) : null;\n  }\n}\nfunction Vp(e, t) {\n  if (!e)\n    throw new Error(\"null row\");\n  const n = {};\n  if (t)\n    for (let s = 0; s < t.length; s++)\n      n[t[s]] = e[s];\n  else\n    for (let s = 0; s < e.length; s++) {\n      const r = `column-${s}`;\n      n[r] = e[s];\n    }\n  return n;\n}\nfunction jp(e, t) {\n  if (!e)\n    throw new Error(\"null row\");\n  if (t) {\n    const n = new Array(t.length);\n    for (let s = 0; s < t.length; s++)\n      n[s] = e[t[s]];\n    return n;\n  }\n  return Object.values(e);\n}\nfunction kp(e) {\n  const t = [];\n  for (let n = 0; n < e.length; n++) {\n    const s = `column-${n}`;\n    t.push(s);\n  }\n  return t;\n}\nfunction Kp(e) {\n  return Object.keys(e);\n}\nconst mo = 100;\nclass zp {\n  constructor(t, n) {\n    if (this.schema = void 0, this.options = void 0, this.length = 0, this.objectRows = null, this.arrayRows = null, this.cursor = 0, this._headers = null, this.options = n, this.schema = t, t) {\n      this._headers = [];\n      for (const s in t)\n        this._headers[t[s].index] = t[s].name;\n    }\n  }\n  rowCount() {\n    return this.length;\n  }\n  addArrayRow(t, n) {\n    switch (Number.isFinite(n) && (this.cursor = n), this._headers || (this._headers = kp(t)), this.options.shape) {\n      case \"object-row-table\":\n        const s = Vp(t, this._headers);\n        this.addObjectRow(s, n);\n        break;\n      case \"array-row-table\":\n        this.arrayRows = this.arrayRows || new Array(mo), this.arrayRows[this.length] = t, this.length++;\n        break;\n    }\n  }\n  addObjectRow(t, n) {\n    switch (Number.isFinite(n) && (this.cursor = n), this._headers || (this._headers = Kp(t)), this.options.shape) {\n      case \"array-row-table\":\n        const s = jp(t, this._headers);\n        this.addArrayRow(s, n);\n        break;\n      case \"object-row-table\":\n        this.objectRows = this.objectRows || new Array(mo), this.objectRows[this.length] = t, this.length++;\n        break;\n    }\n  }\n  getBatch() {\n    let t = this.arrayRows || this.objectRows;\n    return t ? (t = t.slice(0, this.length), this.arrayRows = null, this.objectRows = null, {\n      shape: this.options.shape,\n      batchType: \"data\",\n      data: t,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    }) : null;\n  }\n}\nconst Wp = 100;\nclass Xp {\n  constructor(t, n) {\n    this.schema = void 0, this.length = 0, this.allocated = 0, this.columns = {}, this.schema = t, this._reallocateColumns();\n  }\n  rowCount() {\n    return this.length;\n  }\n  addArrayRow(t) {\n    this._reallocateColumns();\n    let n = 0;\n    for (const s in this.columns)\n      this.columns[s][this.length] = t[n++];\n    this.length++;\n  }\n  addObjectRow(t) {\n    this._reallocateColumns();\n    for (const n in t)\n      this.columns[n][this.length] = t[n];\n    this.length++;\n  }\n  getBatch() {\n    this._pruneColumns();\n    const t = Array.isArray(this.schema) ? this.columns : {};\n    if (!Array.isArray(this.schema))\n      for (const s in this.schema) {\n        const r = this.schema[s];\n        t[r.name] = this.columns[r.index];\n      }\n    return this.columns = {}, {\n      shape: \"columnar-table\",\n      batchType: \"data\",\n      data: t,\n      schema: this.schema,\n      length: this.length\n    };\n  }\n  _reallocateColumns() {\n    if (!(this.length < this.allocated)) {\n      this.allocated = this.allocated > 0 ? this.allocated *= 2 : Wp, this.columns = {};\n      for (const t in this.schema) {\n        const n = this.schema[t], s = n.type || Float32Array, r = this.columns[n.index];\n        if (r && ArrayBuffer.isView(r)) {\n          const i = new s(this.allocated);\n          i.set(r), this.columns[n.index] = i;\n        } else\n          r ? (r.length = this.allocated, this.columns[n.index] = r) : this.columns[n.index] = new s(this.allocated);\n      }\n    }\n  }\n  _pruneColumns() {\n    for (const [t, n] of Object.entries(this.columns))\n      this.columns[t] = n.slice(0, this.length);\n  }\n}\nconst Qp = {\n  shape: void 0,\n  batchSize: \"auto\",\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n}, qp = \"TableBatchBuilder\";\nclass He {\n  constructor(t, n) {\n    this.schema = void 0, this.options = void 0, this.aggregator = null, this.batchCount = 0, this.bytesUsed = 0, this.isChunkComplete = !1, this.lastBatchEmittedMs = Date.now(), this.totalLength = 0, this.totalBytes = 0, this.rowBytes = 0, this.schema = t, this.options = {\n      ...Qp,\n      ...n\n    };\n  }\n  limitReached() {\n    var t, n;\n    return !!(!((t = this.options) === null || t === void 0) && t.limit && this.totalLength >= this.options.limit || !((n = this.options) === null || n === void 0) && n._limitMB && this.totalBytes / 1e6 >= this.options._limitMB);\n  }\n  addRow(t) {\n    this.limitReached() || (this.totalLength++, this.rowBytes = this.rowBytes || this._estimateRowMB(t), this.totalBytes += this.rowBytes, Array.isArray(t) ? this.addArrayRow(t) : this.addObjectRow(t));\n  }\n  addArrayRow(t) {\n    if (!this.aggregator) {\n      const n = this._getTableBatchType();\n      this.aggregator = new n(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(t);\n  }\n  addObjectRow(t) {\n    if (!this.aggregator) {\n      const n = this._getTableBatchType();\n      this.aggregator = new n(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(t);\n  }\n  chunkComplete(t) {\n    t instanceof ArrayBuffer && (this.bytesUsed += t.byteLength), typeof t == \"string\" && (this.bytesUsed += t.length), this.isChunkComplete = !0;\n  }\n  getFullBatch(t) {\n    return this._isFull() ? this._getBatch(t) : null;\n  }\n  getFinalBatch(t) {\n    return this._getBatch(t);\n  }\n  _estimateRowMB(t) {\n    return Array.isArray(t) ? t.length * 8 : Object.keys(t).length * 8;\n  }\n  _isFull() {\n    if (!this.aggregator || this.aggregator.rowCount() === 0)\n      return !1;\n    if (this.options.batchSize === \"auto\") {\n      if (!this.isChunkComplete)\n        return !1;\n    } else if (this.options.batchSize > this.aggregator.rowCount())\n      return !1;\n    return this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs ? !1 : (this.isChunkComplete = !1, this.lastBatchEmittedMs = Date.now(), !0);\n  }\n  _getBatch(t) {\n    if (!this.aggregator)\n      return null;\n    t != null && t.bytesUsed && (this.bytesUsed = t.bytesUsed);\n    const n = this.aggregator.getBatch();\n    return n.count = this.batchCount, n.bytesUsed = this.bytesUsed, Object.assign(n, t), this.batchCount++, this.aggregator = null, n;\n  }\n  _getTableBatchType() {\n    switch (this.options.shape) {\n      case \"array-row-table\":\n      case \"object-row-table\":\n        return zp;\n      case \"columnar-table\":\n        return Xp;\n      case \"arrow-table\":\n        if (!He.ArrowBatch)\n          throw new Error(qp);\n        return He.ArrowBatch;\n      default:\n        return Jp;\n    }\n  }\n}\nHe.ArrowBatch = void 0;\nfunction Yp(e) {\n  try {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return async function* () {\n      const n = new TextDecoder(void 0, t);\n      for await (const s of e)\n        yield typeof s == \"string\" ? s : n.decode(s, {\n          stream: !0\n        });\n    }();\n  } catch (t) {\n    return Promise.reject(t);\n  }\n}\nconst sr = Number.MAX_SAFE_INTEGER;\nvar S = function(e) {\n  return e[e.BEGIN = 0] = \"BEGIN\", e[e.VALUE = 1] = \"VALUE\", e[e.OPEN_OBJECT = 2] = \"OPEN_OBJECT\", e[e.CLOSE_OBJECT = 3] = \"CLOSE_OBJECT\", e[e.OPEN_ARRAY = 4] = \"OPEN_ARRAY\", e[e.CLOSE_ARRAY = 5] = \"CLOSE_ARRAY\", e[e.TEXT_ESCAPE = 6] = \"TEXT_ESCAPE\", e[e.STRING = 7] = \"STRING\", e[e.BACKSLASH = 8] = \"BACKSLASH\", e[e.END = 9] = \"END\", e[e.OPEN_KEY = 10] = \"OPEN_KEY\", e[e.CLOSE_KEY = 11] = \"CLOSE_KEY\", e[e.TRUE = 12] = \"TRUE\", e[e.TRUE2 = 13] = \"TRUE2\", e[e.TRUE3 = 14] = \"TRUE3\", e[e.FALSE = 15] = \"FALSE\", e[e.FALSE2 = 16] = \"FALSE2\", e[e.FALSE3 = 17] = \"FALSE3\", e[e.FALSE4 = 18] = \"FALSE4\", e[e.NULL = 19] = \"NULL\", e[e.NULL2 = 20] = \"NULL2\", e[e.NULL3 = 21] = \"NULL3\", e[e.NUMBER_DECIMAL_POINT = 22] = \"NUMBER_DECIMAL_POINT\", e[e.NUMBER_DIGIT = 23] = \"NUMBER_DIGIT\", e;\n}(S || {});\nconst I = {\n  tab: 9,\n  lineFeed: 10,\n  carriageReturn: 13,\n  space: 32,\n  doubleQuote: 34,\n  plus: 43,\n  comma: 44,\n  minus: 45,\n  period: 46,\n  _0: 48,\n  _9: 57,\n  colon: 58,\n  E: 69,\n  openBracket: 91,\n  backslash: 92,\n  closeBracket: 93,\n  a: 97,\n  b: 98,\n  e: 101,\n  f: 102,\n  l: 108,\n  n: 110,\n  r: 114,\n  s: 115,\n  t: 116,\n  u: 117,\n  openBrace: 123,\n  closeBrace: 125\n}, go = /[\\\\\"\\n]/g, Ao = {\n  onready: () => {\n  },\n  onopenobject: () => {\n  },\n  onkey: () => {\n  },\n  oncloseobject: () => {\n  },\n  onopenarray: () => {\n  },\n  onclosearray: () => {\n  },\n  onvalue: () => {\n  },\n  onerror: () => {\n  },\n  onend: () => {\n  },\n  onchunkparsed: () => {\n  }\n};\nclass $p {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.options = Ao, this.bufferCheckPosition = sr, this.q = \"\", this.c = \"\", this.p = \"\", this.closed = !1, this.closedRoot = !1, this.sawRoot = !1, this.error = null, this.state = S.BEGIN, this.stack = [], this.position = 0, this.column = 0, this.line = 1, this.slashed = !1, this.unicodeI = 0, this.unicodeS = null, this.depth = 0, this.textNode = void 0, this.numberNode = void 0, this.options = {\n      ...Ao,\n      ...t\n    }, this.textNode = void 0, this.numberNode = \"\", this.emit(\"onready\");\n  }\n  end() {\n    return (this.state !== S.VALUE || this.depth !== 0) && this._error(\"Unexpected end\"), this._closeValue(), this.c = \"\", this.closed = !0, this.emit(\"onend\"), this;\n  }\n  resume() {\n    return this.error = null, this;\n  }\n  close() {\n    return this.write(null);\n  }\n  emit(t, n) {\n    var s, r;\n    (s = (r = this.options)[t]) === null || s === void 0 || s.call(r, n, this);\n  }\n  emitNode(t, n) {\n    this._closeValue(), this.emit(t, n);\n  }\n  write(t) {\n    if (this.error)\n      throw this.error;\n    if (this.closed)\n      return this._error(\"Cannot write after close. Assign an onready handler.\");\n    if (t === null)\n      return this.end();\n    let n = 0, s = t.charCodeAt(0), r = this.p;\n    for (; s && (r = s, this.c = s = t.charCodeAt(n++), r !== s ? this.p = r : r = this.p, !!s); )\n      switch (this.position++, s === I.lineFeed ? (this.line++, this.column = 0) : this.column++, this.state) {\n        case S.BEGIN:\n          s === I.openBrace ? this.state = S.OPEN_OBJECT : s === I.openBracket ? this.state = S.OPEN_ARRAY : Se(s) || this._error(\"Non-whitespace before {[.\");\n          continue;\n        case S.OPEN_KEY:\n        case S.OPEN_OBJECT:\n          if (Se(s))\n            continue;\n          if (this.state === S.OPEN_KEY)\n            this.stack.push(S.CLOSE_KEY);\n          else if (s === I.closeBrace) {\n            this.emit(\"onopenobject\"), this.depth++, this.emit(\"oncloseobject\"), this.depth--, this.state = this.stack.pop() || S.VALUE;\n            continue;\n          } else\n            this.stack.push(S.CLOSE_OBJECT);\n          s === I.doubleQuote ? this.state = S.STRING : this._error('Malformed object key should start with \"');\n          continue;\n        case S.CLOSE_KEY:\n        case S.CLOSE_OBJECT:\n          if (Se(s))\n            continue;\n          s === I.colon ? (this.state === S.CLOSE_OBJECT ? (this.stack.push(S.CLOSE_OBJECT), this._closeValue(\"onopenobject\"), this.depth++) : this._closeValue(\"onkey\"), this.state = S.VALUE) : s === I.closeBrace ? (this.emitNode(\"oncloseobject\"), this.depth--, this.state = this.stack.pop() || S.VALUE) : s === I.comma ? (this.state === S.CLOSE_OBJECT && this.stack.push(S.CLOSE_OBJECT), this._closeValue(), this.state = S.OPEN_KEY) : this._error(\"Bad object\");\n          continue;\n        case S.OPEN_ARRAY:\n        case S.VALUE:\n          if (Se(s))\n            continue;\n          if (this.state === S.OPEN_ARRAY)\n            if (this.emit(\"onopenarray\"), this.depth++, this.state = S.VALUE, s === I.closeBracket) {\n              this.emit(\"onclosearray\"), this.depth--, this.state = this.stack.pop() || S.VALUE;\n              continue;\n            } else\n              this.stack.push(S.CLOSE_ARRAY);\n          s === I.doubleQuote ? this.state = S.STRING : s === I.openBrace ? this.state = S.OPEN_OBJECT : s === I.openBracket ? this.state = S.OPEN_ARRAY : s === I.t ? this.state = S.TRUE : s === I.f ? this.state = S.FALSE : s === I.n ? this.state = S.NULL : s === I.minus ? this.numberNode += \"-\" : I._0 <= s && s <= I._9 ? (this.numberNode += String.fromCharCode(s), this.state = S.NUMBER_DIGIT) : this._error(\"Bad value\");\n          continue;\n        case S.CLOSE_ARRAY:\n          if (s === I.comma)\n            this.stack.push(S.CLOSE_ARRAY), this._closeValue(\"onvalue\"), this.state = S.VALUE;\n          else if (s === I.closeBracket)\n            this.emitNode(\"onclosearray\"), this.depth--, this.state = this.stack.pop() || S.VALUE;\n          else {\n            if (Se(s))\n              continue;\n            this._error(\"Bad array\");\n          }\n          continue;\n        case S.STRING:\n          this.textNode === void 0 && (this.textNode = \"\");\n          let i = n - 1, o = this.slashed, a = this.unicodeI;\n          t:\n            for (; ; ) {\n              for (; a > 0; )\n                if (this.unicodeS += String.fromCharCode(s), s = t.charCodeAt(n++), this.position++, a === 4 ? (this.textNode += String.fromCharCode(parseInt(this.unicodeS, 16)), a = 0, i = n - 1) : a++, !s)\n                  break t;\n              if (s === I.doubleQuote && !o) {\n                this.state = this.stack.pop() || S.VALUE, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n                break;\n              }\n              if (s === I.backslash && !o && (o = !0, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i, s = t.charCodeAt(n++), this.position++, !s))\n                break;\n              if (o) {\n                if (o = !1, s === I.n ? this.textNode += `\n` : s === I.r ? this.textNode += \"\\r\" : s === I.t ? this.textNode += \"\t\" : s === I.f ? this.textNode += \"\\f\" : s === I.b ? this.textNode += \"\\b\" : s === I.u ? (a = 1, this.unicodeS = \"\") : this.textNode += String.fromCharCode(s), s = t.charCodeAt(n++), this.position++, i = n - 1, s)\n                  continue;\n                break;\n              }\n              go.lastIndex = n;\n              const c = go.exec(t);\n              if (c === null) {\n                n = t.length + 1, this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n                break;\n              }\n              if (n = c.index + 1, s = t.charCodeAt(c.index), !s) {\n                this.textNode += t.substring(i, n - 1), this.position += n - 1 - i;\n                break;\n              }\n            }\n          this.slashed = o, this.unicodeI = a;\n          continue;\n        case S.TRUE:\n          s === I.r ? this.state = S.TRUE2 : this._error(`Invalid true started with t${s}`);\n          continue;\n        case S.TRUE2:\n          s === I.u ? this.state = S.TRUE3 : this._error(`Invalid true started with tr${s}`);\n          continue;\n        case S.TRUE3:\n          s === I.e ? (this.emit(\"onvalue\", !0), this.state = this.stack.pop() || S.VALUE) : this._error(`Invalid true started with tru${s}`);\n          continue;\n        case S.FALSE:\n          s === I.a ? this.state = S.FALSE2 : this._error(`Invalid false started with f${s}`);\n          continue;\n        case S.FALSE2:\n          s === I.l ? this.state = S.FALSE3 : this._error(`Invalid false started with fa${s}`);\n          continue;\n        case S.FALSE3:\n          s === I.s ? this.state = S.FALSE4 : this._error(`Invalid false started with fal${s}`);\n          continue;\n        case S.FALSE4:\n          s === I.e ? (this.emit(\"onvalue\", !1), this.state = this.stack.pop() || S.VALUE) : this._error(`Invalid false started with fals${s}`);\n          continue;\n        case S.NULL:\n          s === I.u ? this.state = S.NULL2 : this._error(`Invalid null started with n${s}`);\n          continue;\n        case S.NULL2:\n          s === I.l ? this.state = S.NULL3 : this._error(`Invalid null started with nu${s}`);\n          continue;\n        case S.NULL3:\n          s === I.l ? (this.emit(\"onvalue\", null), this.state = this.stack.pop() || S.VALUE) : this._error(`Invalid null started with nul${s}`);\n          continue;\n        case S.NUMBER_DECIMAL_POINT:\n          s === I.period ? (this.numberNode += \".\", this.state = S.NUMBER_DIGIT) : this._error(\"Leading zero not followed by .\");\n          continue;\n        case S.NUMBER_DIGIT:\n          I._0 <= s && s <= I._9 ? this.numberNode += String.fromCharCode(s) : s === I.period ? (this.numberNode.indexOf(\".\") !== -1 && this._error(\"Invalid number has two dots\"), this.numberNode += \".\") : s === I.e || s === I.E ? ((this.numberNode.indexOf(\"e\") !== -1 || this.numberNode.indexOf(\"E\") !== -1) && this._error(\"Invalid number has two exponential\"), this.numberNode += \"e\") : s === I.plus || s === I.minus ? (r === I.e || r === I.E || this._error(\"Invalid symbol in number\"), this.numberNode += String.fromCharCode(s)) : (this._closeNumber(), n--, this.state = this.stack.pop() || S.VALUE);\n          continue;\n        default:\n          this._error(`Unknown state: ${this.state}`);\n      }\n    return this.position >= this.bufferCheckPosition && Zp(this), this.emit(\"onchunkparsed\"), this;\n  }\n  _closeValue() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"onvalue\";\n    this.textNode !== void 0 && this.emit(t, this.textNode), this.textNode = void 0;\n  }\n  _closeNumber() {\n    this.numberNode && this.emit(\"onvalue\", parseFloat(this.numberNode)), this.numberNode = \"\";\n  }\n  _error() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\";\n    this._closeValue(), t += `\nLine: ${this.line}\nColumn: ${this.column}\nChar: ${this.c}`;\n    const n = new Error(t);\n    this.error = n, this.emit(\"onerror\", n);\n  }\n}\nfunction Se(e) {\n  return e === I.carriageReturn || e === I.lineFeed || e === I.space || e === I.tab;\n}\nfunction Zp(e) {\n  const t = Math.max(sr, 10);\n  let n = 0;\n  for (const s of [\"textNode\", \"numberNode\"]) {\n    const r = e[s] === void 0 ? 0 : e[s].length;\n    if (r > t)\n      switch (s) {\n        case \"text\":\n          break;\n        default:\n          e._error(`Max buffer length exceeded: ${s}`);\n      }\n    n = Math.max(n, r);\n  }\n  e.bufferCheckPosition = sr - n + e.position;\n}\nclass te {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n    if (this.path = void 0, this.path = [\"$\"], t instanceof te) {\n      this.path = [...t.path];\n      return;\n    }\n    if (Array.isArray(t)) {\n      this.path.push(...t);\n      return;\n    }\n    if (typeof t == \"string\" && (this.path = t.split(\".\"), this.path[0] !== \"$\"))\n      throw new Error(\"JSONPaths must start with $\");\n  }\n  clone() {\n    return new te(this);\n  }\n  toString() {\n    return this.path.join(\".\");\n  }\n  push(t) {\n    this.path.push(t);\n  }\n  pop() {\n    return this.path.pop();\n  }\n  set(t) {\n    this.path[this.path.length - 1] = t;\n  }\n  equals(t) {\n    if (!this || !t || this.path.length !== t.path.length)\n      return !1;\n    for (let n = 0; n < this.path.length; ++n)\n      if (this.path[n] !== t.path[n])\n        return !1;\n    return !0;\n  }\n  setFieldAtPath(t, n) {\n    const s = [...this.path];\n    s.shift();\n    const r = s.pop();\n    for (const i of s)\n      t = t[i];\n    t[r] = n;\n  }\n  getFieldAtPath(t) {\n    const n = [...this.path];\n    n.shift();\n    const s = n.pop();\n    for (const r of n)\n      t = t[r];\n    return t[s];\n  }\n}\nclass ty {\n  constructor(t) {\n    this.parser = void 0, this.result = void 0, this.previousStates = [], this.currentState = Object.freeze({\n      container: [],\n      key: null\n    }), this.jsonpath = new te(), this.reset(), this.parser = new $p({\n      onready: () => {\n        this.jsonpath = new te(), this.previousStates.length = 0, this.currentState.container.length = 0;\n      },\n      onopenobject: (n) => {\n        this._openObject({}), typeof n < \"u\" && this.parser.emit(\"onkey\", n);\n      },\n      onkey: (n) => {\n        this.jsonpath.set(n), this.currentState.key = n;\n      },\n      oncloseobject: () => {\n        this._closeObject();\n      },\n      onopenarray: () => {\n        this._openArray();\n      },\n      onclosearray: () => {\n        this._closeArray();\n      },\n      onvalue: (n) => {\n        this._pushOrSet(n);\n      },\n      onerror: (n) => {\n        throw n;\n      },\n      onend: () => {\n        this.result = this.currentState.container.pop();\n      },\n      ...t\n    });\n  }\n  reset() {\n    this.result = void 0, this.previousStates = [], this.currentState = Object.freeze({\n      container: [],\n      key: null\n    }), this.jsonpath = new te();\n  }\n  write(t) {\n    this.parser.write(t);\n  }\n  close() {\n    this.parser.close();\n  }\n  _pushOrSet(t) {\n    const {\n      container: n,\n      key: s\n    } = this.currentState;\n    s !== null ? (n[s] = t, this.currentState.key = null) : n.push(t);\n  }\n  _openArray() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n    this.jsonpath.push(null), this._pushOrSet(t), this.previousStates.push(this.currentState), this.currentState = {\n      container: t,\n      isArray: !0,\n      key: null\n    };\n  }\n  _closeArray() {\n    this.jsonpath.pop(), this.currentState = this.previousStates.pop();\n  }\n  _openObject() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    this.jsonpath.push(null), this._pushOrSet(t), this.previousStates.push(this.currentState), this.currentState = {\n      container: t,\n      isArray: !1,\n      key: null\n    };\n  }\n  _closeObject() {\n    this.jsonpath.pop(), this.currentState = this.previousStates.pop();\n  }\n}\nclass ey extends ty {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    super({\n      onopenarray: () => {\n        if (!this.streamingArray && this._matchJSONPath()) {\n          this.streamingJsonPath = this.getJsonPath().clone(), this.streamingArray = [], this._openArray(this.streamingArray);\n          return;\n        }\n        this._openArray();\n      },\n      onopenobject: (s) => {\n        this.topLevelObject ? this._openObject({}) : (this.topLevelObject = {}, this._openObject(this.topLevelObject)), typeof s < \"u\" && this.parser.emit(\"onkey\", s);\n      }\n    }), this.jsonPaths = void 0, this.streamingJsonPath = null, this.streamingArray = null, this.topLevelObject = null;\n    const n = t.jsonpaths || [];\n    this.jsonPaths = n.map((s) => new te(s));\n  }\n  write(t) {\n    super.write(t);\n    let n = [];\n    return this.streamingArray && (n = [...this.streamingArray], this.streamingArray.length = 0), n;\n  }\n  getPartialResult() {\n    return this.topLevelObject;\n  }\n  getStreamingJsonPath() {\n    return this.streamingJsonPath;\n  }\n  getStreamingJsonPathAsString() {\n    return this.streamingJsonPath && this.streamingJsonPath.toString();\n  }\n  getJsonPath() {\n    return this.jsonpath;\n  }\n  _matchJSONPath() {\n    const t = this.getJsonPath();\n    if (this.jsonPaths.length === 0)\n      return !0;\n    for (const n of this.jsonPaths)\n      if (n.equals(t))\n        return !0;\n    return !1;\n  }\n}\nasync function* ny(e, t) {\n  const n = Yp(e), {\n    metadata: s\n  } = t, {\n    jsonpaths: r\n  } = t.json || {};\n  let i = !0;\n  const o = null, a = new He(o, t), c = new ey({\n    jsonpaths: r\n  });\n  for await (const f of n) {\n    const d = c.write(f), m = d.length > 0 && c.getStreamingJsonPathAsString();\n    if (d.length > 0 && i) {\n      if (s) {\n        var u;\n        yield {\n          shape: (t == null || (u = t.json) === null || u === void 0 ? void 0 : u.shape) || \"array-row-table\",\n          batchType: \"partial-result\",\n          data: [],\n          length: 0,\n          bytesUsed: 0,\n          container: c.getPartialResult(),\n          jsonpath: m\n        };\n      }\n      i = !1;\n    }\n    for (const y of d) {\n      a.addRow(y);\n      const E = a.getFullBatch({\n        jsonpath: m\n      });\n      E && (yield E);\n    }\n    a.chunkComplete(f);\n    const g = a.getFullBatch({\n      jsonpath: m\n    });\n    g && (yield g);\n  }\n  const l = c.getStreamingJsonPathAsString(), h = a.getFinalBatch({\n    jsonpath: l\n  });\n  h && (yield h), s && (yield {\n    shape: \"json\",\n    batchType: \"final-result\",\n    container: c.getPartialResult(),\n    jsonpath: c.getStreamingJsonPathAsString(),\n    data: [],\n    length: 0\n  });\n}\nconst Hn = {\n  x: 0,\n  y: 1,\n  z: 2\n};\nfunction Tc(e, t = {}) {\n  const { start: n = 0, end: s = e.length, plane: r = \"xy\" } = t, i = t.size || 2;\n  let o = 0;\n  const a = Hn[r[0]], c = Hn[r[1]];\n  for (let u = n, l = s - i; u < s; u += i)\n    o += (e[u + a] - e[l + a]) * (e[u + c] + e[l + c]), l = u;\n  return o / 2;\n}\nfunction sy(e, t, n = 2, s, r = \"xy\") {\n  const i = t && t.length, o = i ? t[0] * n : e.length;\n  let a = bc(e, 0, o, n, !0, s && s[0], r);\n  const c = [];\n  if (!a || a.next === a.prev)\n    return c;\n  let u, l, h, f, d, m, g;\n  if (i && (a = cy(e, t, a, n, s, r)), e.length > 80 * n) {\n    f = l = e[0], d = h = e[1];\n    for (let y = n; y < o; y += n)\n      m = e[y], g = e[y + 1], m < f && (f = m), g < d && (d = g), m > l && (l = m), g > h && (h = g);\n    u = Math.max(l - f, h - d), u = u !== 0 ? 32767 / u : 0;\n  }\n  return Je(a, c, n, f, d, u, 0), c;\n}\nfunction bc(e, t, n, s, r, i, o) {\n  let a, c;\n  i === void 0 && (i = Tc(e, { start: t, end: n, size: s, plane: o }));\n  let u = Hn[o[0]], l = Hn[o[1]];\n  if (r === i < 0)\n    for (a = t; a < n; a += s)\n      c = po(a, e[a + u], e[a + l], c);\n  else\n    for (a = n - s; a >= t; a -= s)\n      c = po(a, e[a + u], e[a + l], c);\n  return c && Zn(c, c.next) && (je(c), c = c.next), c;\n}\nfunction ne(e, t) {\n  if (!e)\n    return e;\n  t || (t = e);\n  let n = e, s;\n  do\n    if (s = !1, !n.steiner && (Zn(n, n.next) || z(n.prev, n, n.next) === 0)) {\n      if (je(n), n = t = n.prev, n === n.next)\n        break;\n      s = !0;\n    } else\n      n = n.next;\n  while (s || n !== t);\n  return t;\n}\nfunction Je(e, t, n, s, r, i, o) {\n  if (!e)\n    return;\n  !o && i && dy(e, s, r, i);\n  let a = e, c, u;\n  for (; e.prev !== e.next; ) {\n    if (c = e.prev, u = e.next, i ? iy(e, s, r, i) : ry(e)) {\n      t.push(c.i / n | 0), t.push(e.i / n | 0), t.push(u.i / n | 0), je(e), e = u.next, a = u.next;\n      continue;\n    }\n    if (e = u, e === a) {\n      o ? o === 1 ? (e = oy(ne(e), t, n), Je(e, t, n, s, r, i, 2)) : o === 2 && ay(e, t, n, s, r, i) : Je(ne(e), t, n, s, r, i, 1);\n      break;\n    }\n  }\n}\nfunction ry(e) {\n  const t = e.prev, n = e, s = e.next;\n  if (z(t, n, s) >= 0)\n    return !1;\n  const r = t.x, i = n.x, o = s.x, a = t.y, c = n.y, u = s.y, l = r < i ? r < o ? r : o : i < o ? i : o, h = a < c ? a < u ? a : u : c < u ? c : u, f = r > i ? r > o ? r : o : i > o ? i : o, d = a > c ? a > u ? a : u : c > u ? c : u;\n  let m = s.next;\n  for (; m !== t; ) {\n    if (m.x >= l && m.x <= f && m.y >= h && m.y <= d && me(r, a, i, c, o, u, m.x, m.y) && z(m.prev, m, m.next) >= 0)\n      return !1;\n    m = m.next;\n  }\n  return !0;\n}\nfunction iy(e, t, n, s) {\n  const r = e.prev, i = e, o = e.next;\n  if (z(r, i, o) >= 0)\n    return !1;\n  const a = r.x, c = i.x, u = o.x, l = r.y, h = i.y, f = o.y, d = a < c ? a < u ? a : u : c < u ? c : u, m = l < h ? l < f ? l : f : h < f ? h : f, g = a > c ? a > u ? a : u : c > u ? c : u, y = l > h ? l > f ? l : f : h > f ? h : f, E = rr(d, m, t, n, s), R = rr(g, y, t, n, s);\n  let B = e.prevZ, C = e.nextZ;\n  for (; B && B.z >= E && C && C.z <= R; ) {\n    if (B.x >= d && B.x <= g && B.y >= m && B.y <= y && B !== r && B !== o && me(a, l, c, h, u, f, B.x, B.y) && z(B.prev, B, B.next) >= 0 || (B = B.prevZ, C.x >= d && C.x <= g && C.y >= m && C.y <= y && C !== r && C !== o && me(a, l, c, h, u, f, C.x, C.y) && z(C.prev, C, C.next) >= 0))\n      return !1;\n    C = C.nextZ;\n  }\n  for (; B && B.z >= E; ) {\n    if (B.x >= d && B.x <= g && B.y >= m && B.y <= y && B !== r && B !== o && me(a, l, c, h, u, f, B.x, B.y) && z(B.prev, B, B.next) >= 0)\n      return !1;\n    B = B.prevZ;\n  }\n  for (; C && C.z <= R; ) {\n    if (C.x >= d && C.x <= g && C.y >= m && C.y <= y && C !== r && C !== o && me(a, l, c, h, u, f, C.x, C.y) && z(C.prev, C, C.next) >= 0)\n      return !1;\n    C = C.nextZ;\n  }\n  return !0;\n}\nfunction oy(e, t, n) {\n  let s = e;\n  do {\n    const r = s.prev, i = s.next.next;\n    !Zn(r, i) && _c(r, s, s.next, i) && Ve(r, i) && Ve(i, r) && (t.push(r.i / n | 0), t.push(s.i / n | 0), t.push(i.i / n | 0), je(s), je(s.next), s = e = i), s = s.next;\n  } while (s !== e);\n  return ne(s);\n}\nfunction ay(e, t, n, s, r, i) {\n  let o = e;\n  do {\n    let a = o.next.next;\n    for (; a !== o.prev; ) {\n      if (o.i !== a.i && Ay(o, a)) {\n        let c = wc(o, a);\n        o = ne(o, o.next), c = ne(c, c.next), Je(o, t, n, s, r, i, 0), Je(c, t, n, s, r, i, 0);\n        return;\n      }\n      a = a.next;\n    }\n    o = o.next;\n  } while (o !== e);\n}\nfunction cy(e, t, n, s, r, i) {\n  const o = [];\n  let a, c, u, l, h;\n  for (a = 0, c = t.length; a < c; a++)\n    u = t[a] * s, l = a < c - 1 ? t[a + 1] * s : e.length, h = bc(e, u, l, s, !1, r && r[a + 1], i), h === h.next && (h.steiner = !0), o.push(gy(h));\n  for (o.sort(uy), a = 0; a < o.length; a++)\n    n = ly(o[a], n);\n  return n;\n}\nfunction uy(e, t) {\n  return e.x - t.x;\n}\nfunction ly(e, t) {\n  const n = hy(e, t);\n  if (!n)\n    return t;\n  const s = wc(n, e);\n  return ne(s, s.next), ne(n, n.next);\n}\nfunction hy(e, t) {\n  let n = t;\n  const s = e.x, r = e.y;\n  let i = -1 / 0, o;\n  do {\n    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {\n      const f = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n      if (f <= s && f > i && (i = f, o = n.x < n.next.x ? n : n.next, f === s))\n        return o;\n    }\n    n = n.next;\n  } while (n !== t);\n  if (!o)\n    return null;\n  const a = o, c = o.x, u = o.y;\n  let l = 1 / 0, h;\n  n = o;\n  do\n    s >= n.x && n.x >= c && s !== n.x && me(r < u ? s : i, r, c, u, r < u ? i : s, r, n.x, n.y) && (h = Math.abs(r - n.y) / (s - n.x), Ve(n, e) && (h < l || h === l && (n.x > o.x || n.x === o.x && fy(o, n))) && (o = n, l = h)), n = n.next;\n  while (n !== a);\n  return o;\n}\nfunction fy(e, t) {\n  return z(e.prev, e, t.prev) < 0 && z(t.next, e, e.next) < 0;\n}\nfunction dy(e, t, n, s) {\n  let r = e;\n  do\n    r.z === 0 && (r.z = rr(r.x, r.y, t, n, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;\n  while (r !== e);\n  r.prevZ.nextZ = null, r.prevZ = null, my(r);\n}\nfunction my(e) {\n  let t, n, s = 1, r, i, o, a, c, u;\n  do {\n    for (i = e, e = null, u = null, r = 0; i; ) {\n      for (r++, a = i, o = 0, n = 0; n < s && (o++, a = a.nextZ, !!a); n++)\n        ;\n      for (c = s; o > 0 || c > 0 && a; )\n        o !== 0 && (c === 0 || !a || i.z <= a.z) ? (t = i, i = i.nextZ, o--) : (t = a, a = a.nextZ, c--), u ? u.nextZ = t : e = t, t.prevZ = u, u = t;\n      i = a;\n    }\n    u.nextZ = null, s *= 2;\n  } while (r > 1);\n  return e;\n}\nfunction rr(e, t, n, s, r) {\n  return e = (e - n) * r | 0, t = (t - s) * r | 0, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1;\n}\nfunction gy(e) {\n  let t = e, n = e;\n  do\n    (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;\n  while (t !== e);\n  return n;\n}\nfunction me(e, t, n, s, r, i, o, a) {\n  return (r - o) * (t - a) >= (e - o) * (i - a) && (e - o) * (s - a) >= (n - o) * (t - a) && (n - o) * (i - a) >= (r - o) * (s - a);\n}\nfunction Ay(e, t) {\n  return e.next.i !== t.i && e.prev.i !== t.i && !py(e, t) && // dones't intersect other edges\n  (Ve(e, t) && Ve(t, e) && yy(e, t) && // locally visible\n  (z(e.prev, e, t.prev) || z(e, t.prev, t)) || // does not create opposite-facing sectors\n  Zn(e, t) && z(e.prev, e, e.next) > 0 && z(t.prev, t, t.next) > 0);\n}\nfunction z(e, t, n) {\n  return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);\n}\nfunction Zn(e, t) {\n  return e.x === t.x && e.y === t.y;\n}\nfunction _c(e, t, n, s) {\n  const r = Bn(z(e, t, n)), i = Bn(z(e, t, s)), o = Bn(z(n, s, e)), a = Bn(z(n, s, t));\n  return !!(r !== i && o !== a || r === 0 && yn(e, n, t) || i === 0 && yn(e, s, t) || o === 0 && yn(n, e, s) || a === 0 && yn(n, t, s));\n}\nfunction yn(e, t, n) {\n  return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y);\n}\nfunction Bn(e) {\n  return e > 0 ? 1 : e < 0 ? -1 : 0;\n}\nfunction py(e, t) {\n  let n = e;\n  do {\n    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && _c(n, n.next, e, t))\n      return !0;\n    n = n.next;\n  } while (n !== e);\n  return !1;\n}\nfunction Ve(e, t) {\n  return z(e.prev, e, e.next) < 0 ? z(e, t, e.next) >= 0 && z(e, e.prev, t) >= 0 : z(e, t, e.prev) < 0 || z(e, e.next, t) < 0;\n}\nfunction yy(e, t) {\n  let n = e, s = !1;\n  const r = (e.x + t.x) / 2, i = (e.y + t.y) / 2;\n  do\n    n.y > i != n.next.y > i && n.next.y !== n.y && r < (n.next.x - n.x) * (i - n.y) / (n.next.y - n.y) + n.x && (s = !s), n = n.next;\n  while (n !== e);\n  return s;\n}\nfunction wc(e, t) {\n  const n = new ir(e.i, e.x, e.y), s = new ir(t.i, t.x, t.y), r = e.next, i = t.prev;\n  return e.next = t, t.prev = e, n.next = r, r.prev = n, s.next = n, n.prev = s, i.next = s, s.prev = i, s;\n}\nfunction po(e, t, n, s) {\n  const r = new ir(e, t, n);\n  return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r;\n}\nfunction je(e) {\n  e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);\n}\nclass ir {\n  constructor(t, n, s) {\n    this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1, this.i = t, this.x = n, this.y = s;\n  }\n}\nfunction By(e, t, n) {\n  const s = Cy(e), r = Object.keys(s).filter((i) => s[i] !== Array);\n  return Ey(e, {\n    propArrayTypes: s,\n    ...t\n  }, {\n    numericPropKeys: n && n.numericPropKeys || r,\n    PositionDataType: n ? n.PositionDataType : Float32Array,\n    triangulate: n ? n.triangulate : !0\n  });\n}\nfunction Cy(e) {\n  const t = {};\n  for (const n of e)\n    if (n.properties)\n      for (const s in n.properties) {\n        const r = n.properties[s];\n        t[s] = My(r, t[s]);\n      }\n  return t;\n}\nfunction Ey(e, t, n) {\n  const {\n    pointPositionsCount: s,\n    pointFeaturesCount: r,\n    linePositionsCount: i,\n    linePathsCount: o,\n    lineFeaturesCount: a,\n    polygonPositionsCount: c,\n    polygonObjectsCount: u,\n    polygonRingsCount: l,\n    polygonFeaturesCount: h,\n    propArrayTypes: f,\n    coordLength: d\n  } = t, {\n    numericPropKeys: m = [],\n    PositionDataType: g = Float32Array,\n    triangulate: y = !0\n  } = n, E = e[0] && \"id\" in e[0], R = e.length > 65535 ? Uint32Array : Uint16Array, B = {\n    type: \"Point\",\n    positions: new g(s * d),\n    globalFeatureIds: new R(s),\n    featureIds: r > 65535 ? new Uint32Array(s) : new Uint16Array(s),\n    numericProps: {},\n    properties: [],\n    fields: []\n  }, C = {\n    type: \"LineString\",\n    pathIndices: i > 65535 ? new Uint32Array(o + 1) : new Uint16Array(o + 1),\n    positions: new g(i * d),\n    globalFeatureIds: new R(i),\n    featureIds: a > 65535 ? new Uint32Array(i) : new Uint16Array(i),\n    numericProps: {},\n    properties: [],\n    fields: []\n  }, M = {\n    type: \"Polygon\",\n    polygonIndices: c > 65535 ? new Uint32Array(u + 1) : new Uint16Array(u + 1),\n    primitivePolygonIndices: c > 65535 ? new Uint32Array(l + 1) : new Uint16Array(l + 1),\n    positions: new g(c * d),\n    globalFeatureIds: new R(c),\n    featureIds: h > 65535 ? new Uint32Array(c) : new Uint16Array(c),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  y && (M.triangles = []);\n  for (const O of [B, C, M])\n    for (const F of m) {\n      const v = f[F];\n      O.numericProps[F] = new v(O.positions.length / d);\n    }\n  C.pathIndices[o] = i, M.polygonIndices[u] = c, M.primitivePolygonIndices[l] = c;\n  const b = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n  for (const O of e) {\n    const F = O.geometry, v = O.properties || {};\n    switch (F.type) {\n      case \"Point\":\n        Ty(F, B, b, d, v), B.properties.push(xs(v, m)), E && B.fields.push({\n          id: O.id\n        }), b.pointFeature++;\n        break;\n      case \"LineString\":\n        by(F, C, b, d, v), C.properties.push(xs(v, m)), E && C.fields.push({\n          id: O.id\n        }), b.lineFeature++;\n        break;\n      case \"Polygon\":\n        _y(F, M, b, d, v), M.properties.push(xs(v, m)), E && M.fields.push({\n          id: O.id\n        }), b.polygonFeature++;\n        break;\n      default:\n        throw new Error(\"Invalid geometry type\");\n    }\n    b.feature++;\n  }\n  return Ry(B, C, M, d);\n}\nfunction Ty(e, t, n, s, r) {\n  t.positions.set(e.data, n.pointPosition * s);\n  const i = e.data.length / s;\n  Hr(t, r, n.pointPosition, i), t.globalFeatureIds.fill(n.feature, n.pointPosition, n.pointPosition + i), t.featureIds.fill(n.pointFeature, n.pointPosition, n.pointPosition + i), n.pointPosition += i;\n}\nfunction by(e, t, n, s, r) {\n  t.positions.set(e.data, n.linePosition * s);\n  const i = e.data.length / s;\n  Hr(t, r, n.linePosition, i), t.globalFeatureIds.fill(n.feature, n.linePosition, n.linePosition + i), t.featureIds.fill(n.lineFeature, n.linePosition, n.linePosition + i);\n  for (let o = 0, a = e.indices.length; o < a; ++o) {\n    const c = e.indices[o], u = o === a - 1 ? e.data.length : e.indices[o + 1];\n    t.pathIndices[n.linePath++] = n.linePosition, n.linePosition += (u - c) / s;\n  }\n}\nfunction _y(e, t, n, s, r) {\n  t.positions.set(e.data, n.polygonPosition * s);\n  const i = e.data.length / s;\n  Hr(t, r, n.polygonPosition, i), t.globalFeatureIds.fill(n.feature, n.polygonPosition, n.polygonPosition + i), t.featureIds.fill(n.polygonFeature, n.polygonPosition, n.polygonPosition + i);\n  for (let o = 0, a = e.indices.length; o < a; ++o) {\n    const c = n.polygonPosition;\n    t.polygonIndices[n.polygonObject++] = c;\n    const u = e.areas[o], l = e.indices[o], h = e.indices[o + 1];\n    for (let d = 0, m = l.length; d < m; ++d) {\n      const g = l[d], y = d === m - 1 ? h === void 0 ? e.data.length : h[0] : l[d + 1];\n      t.primitivePolygonIndices[n.polygonRing++] = n.polygonPosition, n.polygonPosition += (y - g) / s;\n    }\n    const f = n.polygonPosition;\n    wy(t, u, l, {\n      startPosition: c,\n      endPosition: f,\n      coordLength: s\n    });\n  }\n}\nfunction wy(e, t, n, s) {\n  let {\n    startPosition: r,\n    endPosition: i,\n    coordLength: o\n  } = s;\n  if (!e.triangles)\n    return;\n  const a = r * o, c = i * o, u = e.positions.subarray(a, c), l = n[0], h = n.slice(1).map((d) => (d - l) / o), f = sy(u, h, o, t);\n  for (let d = 0, m = f.length; d < m; ++d)\n    e.triangles.push(r + f[d]);\n}\nfunction Is(e, t) {\n  const n = {};\n  for (const s in e)\n    n[s] = {\n      value: e[s],\n      size: t\n    };\n  return n;\n}\nfunction Ry(e, t, n, s) {\n  const r = {\n    shape: \"binary-feature-collection\",\n    points: {\n      ...e,\n      positions: {\n        value: e.positions,\n        size: s\n      },\n      globalFeatureIds: {\n        value: e.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: e.featureIds,\n        size: 1\n      },\n      numericProps: Is(e.numericProps, 1)\n    },\n    lines: {\n      ...t,\n      positions: {\n        value: t.positions,\n        size: s\n      },\n      pathIndices: {\n        value: t.pathIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: t.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: t.featureIds,\n        size: 1\n      },\n      numericProps: Is(t.numericProps, 1)\n    },\n    polygons: {\n      ...n,\n      positions: {\n        value: n.positions,\n        size: s\n      },\n      polygonIndices: {\n        value: n.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: n.primitivePolygonIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: n.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: n.featureIds,\n        size: 1\n      },\n      numericProps: Is(n.numericProps, 1)\n    }\n  };\n  return r.polygons && n.triangles && (r.polygons.triangles = {\n    value: new Uint32Array(n.triangles),\n    size: 1\n  }), r;\n}\nfunction Hr(e, t, n, s) {\n  for (const r in e.numericProps)\n    if (r in t) {\n      const i = t[r];\n      e.numericProps[r].fill(i, n, n + s);\n    }\n}\nfunction xs(e, t) {\n  const n = {};\n  for (const s in e)\n    t.includes(s) || (n[s] = e[s]);\n  return n;\n}\nfunction My(e, t) {\n  return t === Array || !Number.isFinite(e) ? Array : t === Float64Array || Math.fround(e) !== e ? Float64Array : Float32Array;\n}\nfunction Sy(e) {\n  let t = 0, n = 0, s = 0, r = 0, i = 0, o = 0, a = 0, c = 0, u = 0;\n  const l = /* @__PURE__ */ new Set();\n  for (const h of e) {\n    const f = h.geometry;\n    switch (f.type) {\n      case \"Point\":\n        n++, t++, l.add(f.coordinates.length);\n        break;\n      case \"MultiPoint\":\n        n++, t += f.coordinates.length;\n        for (const m of f.coordinates)\n          l.add(m.length);\n        break;\n      case \"LineString\":\n        i++, s += f.coordinates.length, r++;\n        for (const m of f.coordinates)\n          l.add(m.length);\n        break;\n      case \"MultiLineString\":\n        i++;\n        for (const m of f.coordinates) {\n          s += m.length, r++;\n          for (const g of m)\n            l.add(g.length);\n        }\n        break;\n      case \"Polygon\":\n        u++, a++, c += f.coordinates.length;\n        const d = f.coordinates.flat();\n        o += d.length;\n        for (const m of d)\n          l.add(m.length);\n        break;\n      case \"MultiPolygon\":\n        u++;\n        for (const m of f.coordinates) {\n          a++, c += m.length;\n          const g = m.flat();\n          o += g.length;\n          for (const y of g)\n            l.add(y.length);\n        }\n        break;\n      default:\n        throw new Error(`Unsupported geometry type: ${f.type}`);\n    }\n  }\n  return {\n    coordLength: l.size > 0 ? Math.max(...l) : 2,\n    pointPositionsCount: t,\n    pointFeaturesCount: n,\n    linePositionsCount: s,\n    linePathsCount: r,\n    lineFeaturesCount: i,\n    polygonPositionsCount: o,\n    polygonObjectsCount: a,\n    polygonRingsCount: c,\n    polygonFeaturesCount: u\n  };\n}\nfunction Iy(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n    coordLength: 2,\n    fixRingWinding: !0\n  };\n  return e.map((n) => xy(n, t));\n}\nfunction yo(e, t, n, s) {\n  n.push(t.length), t.push(...e);\n  for (let r = e.length; r < s.coordLength; r++)\n    t.push(0);\n}\nfunction or(e, t, n, s) {\n  n.push(t.length);\n  for (const r of e) {\n    t.push(...r);\n    for (let i = r.length; i < s.coordLength; i++)\n      t.push(0);\n  }\n}\nfunction Bo(e, t, n, s, r) {\n  let i = 0;\n  const o = [], a = [];\n  for (const c of e) {\n    const u = c.map((f) => f.slice(0, 2));\n    let l = Tc(u.flat());\n    const h = l < 0;\n    r.fixRingWinding && (i === 0 && !h || i > 0 && h) && (c.reverse(), l = -l), o.push(l), or(c, t, a, r), i++;\n  }\n  i > 0 && (s.push(o), n.push(a));\n}\nfunction xy(e, t) {\n  const {\n    geometry: n\n  } = e;\n  if (n.type === \"GeometryCollection\")\n    throw new Error(\"GeometryCollection type not supported\");\n  const s = [], r = [];\n  let i, o;\n  switch (n.type) {\n    case \"Point\":\n      o = \"Point\", yo(n.coordinates, s, r, t);\n      break;\n    case \"MultiPoint\":\n      o = \"Point\", n.coordinates.map((a) => yo(a, s, r, t));\n      break;\n    case \"LineString\":\n      o = \"LineString\", or(n.coordinates, s, r, t);\n      break;\n    case \"MultiLineString\":\n      o = \"LineString\", n.coordinates.map((a) => or(a, s, r, t));\n      break;\n    case \"Polygon\":\n      o = \"Polygon\", i = [], Bo(n.coordinates, s, r, i, t);\n      break;\n    case \"MultiPolygon\":\n      o = \"Polygon\", i = [], n.coordinates.map((a) => Bo(a, s, r, i, t));\n      break;\n    default:\n      throw new Error(`Unknown type: ${o}`);\n  }\n  return {\n    ...e,\n    geometry: {\n      type: o,\n      indices: r,\n      data: s,\n      areas: i\n    }\n  };\n}\nfunction Rc(e) {\n  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n    fixRingWinding: !0,\n    triangulate: !0\n  };\n  const n = Sy(e), s = n.coordLength, {\n    fixRingWinding: r\n  } = t, i = Iy(e, {\n    coordLength: s,\n    fixRingWinding: r\n  });\n  return By(i, n, {\n    numericPropKeys: t.numericPropKeys,\n    PositionDataType: t.PositionDataType || Float32Array,\n    triangulate: t.triangulate\n  });\n}\nconst vy = \"4.1.4\", Oy = {\n  name: \"GeoJSON\",\n  id: \"geojson\",\n  module: \"geojson\",\n  version: vy,\n  worker: !0,\n  extensions: [\"geojson\"],\n  mimeTypes: [\"application/geo+json\"],\n  category: \"geometry\",\n  text: !0,\n  options: {\n    geojson: {\n      shape: \"object-row-table\"\n    },\n    json: {\n      shape: \"object-row-table\",\n      jsonpaths: [\"$\", \"$.features\"]\n    },\n    gis: {\n      format: \"geojson\"\n    }\n  }\n}, ke = {\n  ...Oy,\n  parse: Fy,\n  parseTextSync: Mc,\n  parseInBatches: Dy\n};\nasync function Fy(e, t) {\n  return Mc(new TextDecoder().decode(e), t);\n}\nfunction Mc(e, t) {\n  var n;\n  t = {\n    ...ke.options,\n    ...t\n  }, t.geojson = {\n    ...ke.options.geojson,\n    ...t.geojson\n  }, t.gis = t.gis || {};\n  let s;\n  try {\n    s = JSON.parse(e);\n  } catch {\n    s = {};\n  }\n  const r = {\n    shape: \"geojson-table\",\n    type: \"FeatureCollection\",\n    features: ((n = s) === null || n === void 0 ? void 0 : n.features) || []\n  };\n  switch (t.gis.format) {\n    case \"binary\":\n      return Rc(r.features);\n    default:\n      return r;\n  }\n}\nfunction Dy(e, t) {\n  t = {\n    ...ke.options,\n    ...t\n  }, t.json = {\n    ...ke.options.geojson,\n    ...t.geojson\n  };\n  const n = ny(e, t);\n  switch (t.gis.format) {\n    case \"binary\":\n      return Ly(n);\n    default:\n      return n;\n  }\n}\nasync function* Ly(e) {\n  for await (const t of e)\n    t.data = Rc(t.data), yield t;\n}\nfunction $t(e, t) {\n  if (!e)\n    throw new Error(t || \"loader assertion failed.\");\n}\nconst Py = \"Queued Requests\", Gy = \"Active Requests\", Ny = \"Cancelled Requests\", Uy = \"Queued Requests Ever\", Hy = \"Active Requests Ever\", Jy = {\n  id: \"request-scheduler\",\n  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */\n  throttleRequests: !0,\n  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */\n  maxRequests: 6,\n  /**\n   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have\n   * been added to the queue for this amount of time.\n   */\n  debounceTime: 0\n};\nclass Vy {\n  constructor(t = {}) {\n    p(this, \"props\");\n    p(this, \"stats\");\n    p(this, \"activeRequestCount\", 0);\n    /** Tracks the number of active requests and prioritizes/cancels queued requests. */\n    p(this, \"requestQueue\", []);\n    p(this, \"requestMap\", /* @__PURE__ */ new Map());\n    p(this, \"updateTimer\", null);\n    this.props = { ...Jy, ...t }, this.stats = new qo({ id: this.props.id }), this.stats.get(Py), this.stats.get(Gy), this.stats.get(Ny), this.stats.get(Uy), this.stats.get(Hy);\n  }\n  /**\n   * Called by an application that wants to issue a request, without having it deeply queued by the browser\n   *\n   * When the returned promise resolved, it is OK for the application to issue a request.\n   * The promise resolves to an object that contains a `done` method.\n   * When the application's request has completed (or failed), the application must call the `done` function\n   *\n   * @param handle\n   * @param getPriority will be called when request \"slots\" open up,\n   *    allowing the caller to update priority or cancel the request\n   *    Highest priority executes first, priority < 0 cancels the request\n   * @returns a promise\n   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,\n   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).\n   *     In this case the application should not issue the request\n   */\n  scheduleRequest(t, n = () => 0) {\n    if (!this.props.throttleRequests)\n      return Promise.resolve({ done: () => {\n      } });\n    if (this.requestMap.has(t))\n      return this.requestMap.get(t);\n    const s = { handle: t, priority: 0, getPriority: n }, r = new Promise((i) => (s.resolve = i, s));\n    return this.requestQueue.push(s), this.requestMap.set(t, r), this._issueNewRequests(), r;\n  }\n  // PRIVATE\n  _issueRequest(t) {\n    const { handle: n, resolve: s } = t;\n    let r = !1;\n    const i = () => {\n      r || (r = !0, this.requestMap.delete(n), this.activeRequestCount--, this._issueNewRequests());\n    };\n    return this.activeRequestCount++, s ? s({ done: i }) : Promise.resolve({ done: i });\n  }\n  /** We check requests asynchronously, to prevent multiple updates */\n  _issueNewRequests() {\n    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);\n  }\n  /** Refresh all requests  */\n  _issueNewRequestsAsync() {\n    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = null;\n    const t = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n    if (t !== 0) {\n      this._updateAllRequests();\n      for (let n = 0; n < t; ++n) {\n        const s = this.requestQueue.shift();\n        s && this._issueRequest(s);\n      }\n    }\n  }\n  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */\n  _updateAllRequests() {\n    const t = this.requestQueue;\n    for (let n = 0; n < t.length; ++n) {\n      const s = t[n];\n      this._updateRequest(s) || (t.splice(n, 1), this.requestMap.delete(s.handle), n--);\n    }\n    t.sort((n, s) => n.priority - s.priority);\n  }\n  /** Update a single request by calling the callback */\n  _updateRequest(t) {\n    return t.priority = t.getPriority(t.handle), t.priority < 0 ? (t.resolve(null), !1) : !0;\n  }\n}\nfunction jy(e) {\n  const t = e ? e.lastIndexOf(\"/\") : -1;\n  return t >= 0 ? e.substr(0, t) : \"\";\n}\nclass ky {\n  constructor(t, n, s) {\n    p(this, \"item\");\n    p(this, \"previous\");\n    p(this, \"next\");\n    this.item = t, this.previous = n, this.next = s;\n  }\n}\nclass Ky {\n  constructor() {\n    p(this, \"head\", null);\n    p(this, \"tail\", null);\n    p(this, \"_length\", 0);\n  }\n  get length() {\n    return this._length;\n  }\n  /**\n   * Adds the item to the end of the list\n   * @param {*} [item]\n   * @return {DoublyLinkedListNode}\n   */\n  add(t) {\n    const n = new ky(t, this.tail, null);\n    return this.tail ? (this.tail.next = n, this.tail = n) : (this.head = n, this.tail = n), ++this._length, n;\n  }\n  /**\n   * Removes the given node from the list\n   * @param {DoublyLinkedListNode} node\n   */\n  remove(t) {\n    t && (t.previous && t.next ? (t.previous.next = t.next, t.next.previous = t.previous) : t.previous ? (t.previous.next = null, this.tail = t.previous) : t.next ? (t.next.previous = null, this.head = t.next) : (this.head = null, this.tail = null), t.next = null, t.previous = null, --this._length);\n  }\n  /**\n   * Moves nextNode after node\n   * @param {DoublyLinkedListNode} node\n   * @param {DoublyLinkedListNode} nextNode\n   */\n  splice(t, n) {\n    t !== n && (this.remove(n), this._insert(t, n));\n  }\n  _insert(t, n) {\n    const s = t.next;\n    t.next = n, this.tail === t ? this.tail = n : s.previous = n, n.next = s, n.previous = t, ++this._length;\n  }\n}\nclass zy {\n  constructor() {\n    p(this, \"_list\");\n    p(this, \"_sentinel\");\n    p(this, \"_trimTiles\");\n    this._list = new Ky(), this._sentinel = this._list.add(\"sentinel\"), this._trimTiles = !1;\n  }\n  reset() {\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n  touch(t) {\n    const n = t._cacheNode;\n    n && this._list.splice(this._sentinel, n);\n  }\n  add(t, n, s) {\n    n._cacheNode || (n._cacheNode = this._list.add(n), s && s(t, n));\n  }\n  unloadTile(t, n, s) {\n    const r = n._cacheNode;\n    r && (this._list.remove(r), n._cacheNode = null, s && s(t, n));\n  }\n  unloadTiles(t, n) {\n    const s = this._trimTiles;\n    this._trimTiles = !1;\n    const r = this._list, i = t.maximumMemoryUsage * 1024 * 1024, o = this._sentinel;\n    let a = r.head;\n    for (; a !== o && (t.gpuMemoryUsageInBytes > i || s); ) {\n      const c = a.item;\n      a = a.next, this.unloadTile(t, c, n);\n    }\n  }\n  trim() {\n    this._trimTiles = !0;\n  }\n}\nfunction Wy(e, t) {\n  $t(e), $t(t);\n  const { rtcCenter: n, gltfUpAxis: s } = t, { computedTransform: r, boundingVolume: { center: i } } = e;\n  let o = new V(r);\n  switch (n && o.translate(n), s) {\n    case \"Z\":\n      break;\n    case \"Y\":\n      const h = new V().rotateX(Math.PI / 2);\n      o = o.multiplyRight(h);\n      break;\n    case \"X\":\n      const f = new V().rotateY(-Math.PI / 2);\n      o = o.multiplyRight(f);\n      break;\n  }\n  t.isQuantized && o.translate(t.quantizedVolumeOffset).scale(t.quantizedVolumeScale);\n  const a = new A(i);\n  t.cartesianModelMatrix = o, t.cartesianOrigin = a;\n  const c = J.WGS84.cartesianToCartographic(a, new A()), l = J.WGS84.eastNorthUpToFixedFrame(a).invert();\n  t.cartographicModelMatrix = l.multiplyRight(o), t.cartographicOrigin = c, t.coordinateSystem || (t.modelMatrix = t.cartographicModelMatrix);\n}\nconst Co = new A(), vs = new A(), ar = new dt([\n  new tt(),\n  new tt(),\n  new tt(),\n  new tt(),\n  new tt(),\n  new tt()\n]);\nfunction Xy(e, t) {\n  const { cameraDirection: n, cameraUp: s, height: r } = e, { metersPerUnit: i } = e.distanceScales, o = wn(e, e.center), a = J.WGS84.eastNorthUpToFixedFrame(o), c = e.unprojectPosition(e.cameraPosition), u = J.WGS84.cartographicToCartesian(c, new A()), l = new A(\n    // @ts-ignore\n    a.transformAsVector(new A(n).scale(i))\n  ).normalize(), h = new A(\n    // @ts-ignore\n    a.transformAsVector(new A(s).scale(i))\n  ).normalize();\n  qy(e);\n  const f = e.constructor, { longitude: d, latitude: m, width: g, bearing: y, zoom: E } = e, R = new f({\n    longitude: d,\n    latitude: m,\n    height: r,\n    width: g,\n    bearing: y,\n    zoom: E,\n    pitch: 0\n  });\n  return {\n    camera: {\n      position: u,\n      direction: l,\n      up: h\n    },\n    viewport: e,\n    topDownViewport: R,\n    height: r,\n    cullingVolume: ar,\n    frameNumber: t,\n    // TODO: This can be the same between updates, what number is unique for between updates?\n    sseDenominator: 1.15\n    // Assumes fovy = 60 degrees\n  };\n}\nfunction Qy(e, t, n) {\n  if (n === 0 || e.length <= n)\n    return [e, []];\n  const s = [], { longitude: r, latitude: i } = t.viewport;\n  for (const [u, l] of e.entries()) {\n    const [h, f] = l.header.mbs, d = Math.abs(r - h), m = Math.abs(i - f), g = Math.sqrt(m * m + d * d);\n    s.push([u, g]);\n  }\n  const o = s.sort((u, l) => u[1] - l[1]), a = [];\n  for (let u = 0; u < n; u++)\n    a.push(e[o[u][0]]);\n  const c = [];\n  for (let u = n; u < o.length; u++)\n    c.push(e[o[u][0]]);\n  return [a, c];\n}\nfunction qy(e) {\n  const t = e.getFrustumPlanes(), n = Eo(t.near, e.cameraPosition), s = wn(e, n), r = wn(e, e.cameraPosition, vs);\n  let i = 0;\n  ar.planes[i++].fromPointNormal(s, Co.copy(s).subtract(r));\n  for (const o in t) {\n    if (o === \"near\")\n      continue;\n    const a = t[o], c = Eo(a, n, vs), u = wn(e, c, vs);\n    ar.planes[i++].fromPointNormal(\n      u,\n      // Want the normal to point into the frustum since that's what culling expects\n      Co.copy(s).subtract(u)\n    );\n  }\n}\nfunction Eo(e, t, n = new A()) {\n  const s = e.normal.dot(t);\n  return n.copy(e.normal).scale(e.distance - s).add(t), n;\n}\nfunction wn(e, t, n = new A()) {\n  const s = e.unprojectPosition(t);\n  return J.WGS84.cartographicToCartesian(s, n);\n}\nconst Yy = 6378137, $y = 6378137, cr = 6356752314245179e-9, ge = new A();\nfunction Zy(e, t) {\n  if (e instanceof qe) {\n    const { halfAxes: n } = e, s = eB(n);\n    return Math.log2(cr / (s + t[2]));\n  } else if (e instanceof Qe) {\n    const { radius: n } = e;\n    return Math.log2(cr / (n + t[2]));\n  } else if (e.width && e.height) {\n    const { width: n, height: s } = e, r = Math.log2(Yy / n), i = Math.log2($y / s);\n    return (r + i) / 2;\n  }\n  return 1;\n}\nfunction Sc(e, t, n) {\n  J.WGS84.cartographicToCartesian([e.xmax, e.ymax, e.zmax], ge);\n  const s = Math.sqrt(Math.pow(ge[0] - n[0], 2) + Math.pow(ge[1] - n[1], 2) + Math.pow(ge[2] - n[2], 2));\n  return Math.log2(cr / (s + t[2]));\n}\nfunction tB(e, t, n) {\n  const [s, r, i, o] = e;\n  return Sc({ xmin: s, xmax: i, ymin: r, ymax: o, zmin: 0, zmax: 0 }, t, n);\n}\nfunction eB(e) {\n  e.getColumn(0, ge);\n  const t = e.getColumn(1), n = e.getColumn(2);\n  return ge.add(t).add(n).len();\n}\nconst lt = {\n  UNLOADED: 0,\n  // Has never been requested\n  LOADING: 1,\n  // Is waiting on a pending request\n  PROCESSING: 2,\n  // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.\n  READY: 3,\n  // Ready to render.\n  EXPIRED: 4,\n  // Is expired and will be unloaded once new content is loaded.\n  FAILED: 5\n  // Request failed.\n};\nvar Ht;\n(function(e) {\n  e[e.ADD = 1] = \"ADD\", e[e.REPLACE = 2] = \"REPLACE\";\n})(Ht || (Ht = {}));\nvar Pe;\n(function(e) {\n  e.EMPTY = \"empty\", e.SCENEGRAPH = \"scenegraph\", e.POINTCLOUD = \"pointcloud\", e.MESH = \"mesh\";\n})(Pe || (Pe = {}));\nvar At;\n(function(e) {\n  e.I3S = \"I3S\", e.TILES3D = \"TILES3D\";\n})(At || (At = {}));\nvar To;\n(function(e) {\n  e.GEOMETRIC_ERROR = \"geometricError\", e.MAX_SCREEN_THRESHOLD = \"maxScreenThreshold\";\n})(To || (To = {}));\nconst nB = {\n  NOT_COMPUTED: -1,\n  USE_OPTIMIZATION: 1,\n  SKIP_OPTIMIZATION: 0\n};\nfunction Ic(e) {\n  return e != null;\n}\nconst rt = new A(), Rn = new A(), sB = new A(), rB = new A(), qt = new A(), bo = new A(), _o = new A(), wo = new A();\nfunction Os(e, t, n) {\n  if ($t(e, \"3D Tile: boundingVolume must be defined\"), e.box)\n    return xc(e.box, t, n);\n  if (e.region)\n    return aB(e.region);\n  if (e.sphere)\n    return oB(e.sphere, t, n);\n  throw new Error(\"3D Tile: boundingVolume must contain a sphere, region, or box\");\n}\nfunction iB(e, t) {\n  if (e.box)\n    return cB(t);\n  if (e.region) {\n    const [n, s, r, i, o, a] = e.region;\n    return [\n      [Rt(n), Rt(s), o],\n      [Rt(r), Rt(i), a]\n    ];\n  }\n  if (e.sphere)\n    return uB(t);\n  throw new Error(\"Unkown boundingVolume type\");\n}\nfunction xc(e, t, n) {\n  const s = new A(e[0], e[1], e[2]);\n  t.transform(s, s);\n  let r = [];\n  if (e.length === 10) {\n    const u = e.slice(3, 6), l = new On();\n    l.fromArray(e, 6);\n    const h = new A([1, 0, 0]), f = new A([0, 1, 0]), d = new A([0, 0, 1]);\n    h.transformByQuaternion(l), h.scale(u[0]), f.transformByQuaternion(l), f.scale(u[1]), d.transformByQuaternion(l), d.scale(u[2]), r = [...h.toArray(), ...f.toArray(), ...d.toArray()];\n  } else\n    r = [...e.slice(3, 6), ...e.slice(6, 9), ...e.slice(9, 12)];\n  const i = t.transformAsVector(r.slice(0, 3)), o = t.transformAsVector(r.slice(3, 6)), a = t.transformAsVector(r.slice(6, 9)), c = new W([\n    i[0],\n    i[1],\n    i[2],\n    o[0],\n    o[1],\n    o[2],\n    a[0],\n    a[1],\n    a[2]\n  ]);\n  return Ic(n) ? (n.center = s, n.halfAxes = c, n) : new qe(s, c);\n}\nfunction oB(e, t, n) {\n  const s = new A(e[0], e[1], e[2]);\n  t.transform(s, s);\n  const r = t.getScale(Rn), i = Math.max(Math.max(r[0], r[1]), r[2]), o = e[3] * i;\n  return Ic(n) ? (n.center = s, n.radius = o, n) : new Qe(s, o);\n}\nfunction aB(e) {\n  const [t, n, s, r, i, o] = e, a = J.WGS84.cartographicToCartesian([Rt(t), Rt(r), i], sB), c = J.WGS84.cartographicToCartesian([Rt(s), Rt(n), o], rB), u = new A().addVectors(a, c).multiplyByScalar(0.5);\n  return J.WGS84.cartesianToCartographic(u, qt), J.WGS84.cartographicToCartesian([Rt(s), qt[1], qt[2]], bo), J.WGS84.cartographicToCartesian([qt[0], Rt(r), qt[2]], _o), J.WGS84.cartographicToCartesian([qt[0], qt[1], o], wo), xc([\n    ...u,\n    ...bo.subtract(u),\n    ..._o.subtract(u),\n    ...wo.subtract(u)\n  ], new V());\n}\nfunction cB(e) {\n  const t = vc(), { halfAxes: n } = e, s = new A(n.getColumn(0)), r = new A(n.getColumn(1)), i = new A(n.getColumn(2));\n  for (let o = 0; o < 2; o++) {\n    for (let a = 0; a < 2; a++) {\n      for (let c = 0; c < 2; c++)\n        rt.copy(e.center), rt.add(s), rt.add(r), rt.add(i), Oc(t, rt), i.negate();\n      r.negate();\n    }\n    s.negate();\n  }\n  return t;\n}\nfunction uB(e) {\n  const t = vc(), { center: n, radius: s } = e, r = J.WGS84.scaleToGeodeticSurface(n, rt);\n  let i;\n  r ? i = J.WGS84.geodeticSurfaceNormal(r) : i = new A(0, 0, 1);\n  let o = new A(i[2], -i[1], 0);\n  o.len() > 0 ? o.normalize() : o = new A(0, 1, 0);\n  const a = o.clone().cross(i);\n  for (const c of [o, a, i]) {\n    Rn.copy(c).scale(s);\n    for (let u = 0; u < 2; u++)\n      rt.copy(n), rt.add(Rn), Oc(t, rt), Rn.negate();\n  }\n  return t;\n}\nfunction vc() {\n  return [\n    [1 / 0, 1 / 0, 1 / 0],\n    [-1 / 0, -1 / 0, -1 / 0]\n  ];\n}\nfunction Oc(e, t) {\n  J.WGS84.cartesianToCartographic(t, rt), e[0][0] = Math.min(e[0][0], rt[0]), e[0][1] = Math.min(e[0][1], rt[1]), e[0][2] = Math.min(e[0][2], rt[2]), e[1][0] = Math.max(e[1][0], rt[0]), e[1][1] = Math.max(e[1][1], rt[1]), e[1][2] = Math.max(e[1][2], rt[2]);\n}\nnew A();\nnew A();\nnew V();\nnew A();\nnew A();\nnew A();\nfunction lB(e, t) {\n  const n = e * t;\n  return 1 - Math.exp(-(n * n));\n}\nfunction hB(e, t) {\n  if (e.dynamicScreenSpaceError && e.dynamicScreenSpaceErrorComputedDensity) {\n    const n = e.dynamicScreenSpaceErrorComputedDensity, s = e.dynamicScreenSpaceErrorFactor;\n    return lB(t, n) * s;\n  }\n  return 0;\n}\nfunction fB(e, t, n) {\n  const s = e.tileset, r = e.parent && e.parent.lodMetricValue || e.lodMetricValue, i = n ? r : e.lodMetricValue;\n  if (i === 0)\n    return 0;\n  const o = Math.max(e._distanceToCamera, 1e-7), { height: a, sseDenominator: c } = t, { viewDistanceScale: u } = s.options;\n  let l = i * a * (u || 1) / (o * c);\n  return l -= hB(s, o), l;\n}\nconst Fs = new A(), Ro = new A(), jt = new A(), Mo = new A(), dB = new A(), Ds = new V(), So = new V();\nfunction mB(e, t) {\n  if (e.lodMetricValue === 0 || isNaN(e.lodMetricValue))\n    return \"DIG\";\n  const n = 2 * Fc(e, t);\n  return n < 2 ? \"OUT\" : !e.header.children || n <= e.lodMetricValue ? \"DRAW\" : e.header.children ? \"DIG\" : \"OUT\";\n}\nfunction Fc(e, t) {\n  const { topDownViewport: n } = t, s = e.header.mbs[1], r = e.header.mbs[0], i = e.header.mbs[2], o = e.header.mbs[3], a = [...e.boundingVolume.center], c = n.unprojectPosition(n.cameraPosition);\n  J.WGS84.cartographicToCartesian(c, Fs), Ro.copy(Fs).subtract(a).normalize(), J.WGS84.eastNorthUpToFixedFrame(a, Ds), So.copy(Ds).invert(), jt.copy(Fs).transform(So);\n  const u = Math.sqrt(jt[0] * jt[0] + jt[1] * jt[1]), l = u * u / jt[2];\n  Mo.copy([jt[0], jt[1], l]);\n  const f = Mo.transform(Ds).subtract(a).normalize(), m = Ro.cross(f).normalize().scale(o).add(a), g = J.WGS84.cartesianToCartographic(m), y = n.project([r, s, i]), E = n.project(g);\n  return dB.copy(y).subtract(E).magnitude();\n}\nfunction gB(e) {\n  return {\n    assetGltfUpAxis: e.asset && e.asset.gltfUpAxis || \"Y\"\n  };\n}\nclass Io {\n  constructor(t = 0) {\n    p(this, \"_map\", /* @__PURE__ */ new Map());\n    p(this, \"_array\");\n    p(this, \"_length\");\n    this._array = new Array(t), this._length = t;\n  }\n  /**\n   * Gets or sets the length of the array.\n   * If the set length is greater than the length of the internal array, the internal array is resized.\n   *\n   * @memberof ManagedArray.prototype\n   * @type Number\n   */\n  get length() {\n    return this._length;\n  }\n  set length(t) {\n    this._length = t, t > this._array.length && (this._array.length = t);\n  }\n  /**\n   * Gets the internal array.\n   *\n   * @memberof ManagedArray.prototype\n   * @type Array\n   * @readonly\n   */\n  get values() {\n    return this._array;\n  }\n  /**\n   * Gets the element at an index.\n   *\n   * @param {Number} index The index to get.\n   */\n  get(t) {\n    return $t(t < this._array.length), this._array[t];\n  }\n  /**\n   * Sets the element at an index. Resizes the array if index is greater than the length of the array.\n   *\n   * @param {Number} index The index to set.\n   * @param {*} element The element to set at index.\n   */\n  set(t, n) {\n    $t(t >= 0), t >= this.length && (this.length = t + 1), this._map.has(this._array[t]) && this._map.delete(this._array[t]), this._array[t] = n, this._map.set(n, t);\n  }\n  delete(t) {\n    const n = this._map.get(t);\n    n >= 0 && (this._array.splice(n, 1), this._map.delete(t), this.length--);\n  }\n  /**\n   * Returns the last element in the array without modifying the array.\n   *\n   * @returns {*} The last element in the array.\n   */\n  peek() {\n    return this._array[this._length - 1];\n  }\n  /**\n   * Push an element into the array.\n   *\n   * @param {*} element The element to push.\n   */\n  push(t) {\n    if (!this._map.has(t)) {\n      const n = this.length++;\n      this._array[n] = t, this._map.set(t, n);\n    }\n  }\n  /**\n   * Pop an element from the array.\n   *\n   * @returns {*} The last element in the array.\n   */\n  pop() {\n    const t = this._array[--this.length];\n    return this._map.delete(t), t;\n  }\n  /**\n   * Resize the internal array if length > _array.length.\n   *\n   * @param {Number} length The length.\n   */\n  reserve(t) {\n    $t(t >= 0), t > this._array.length && (this._array.length = t);\n  }\n  /**\n   * Resize the array.\n   *\n   * @param {Number} length The length.\n   */\n  resize(t) {\n    $t(t >= 0), this.length = t;\n  }\n  /**\n   * Trim the internal array to the specified length. Defaults to the current length.\n   *\n   * @param {Number} [length] The length.\n   */\n  trim(t) {\n    t == null && (t = this.length), this._array.length = t;\n  }\n  reset() {\n    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;\n  }\n  find(t) {\n    return this._map.has(t);\n  }\n}\nconst AB = {\n  loadSiblings: !1,\n  skipLevelOfDetail: !1,\n  updateTransforms: !0,\n  onTraversalEnd: () => {\n  },\n  viewportTraversersMap: {},\n  basePath: \"\"\n};\nclass ts {\n  // TODO nested props\n  constructor(t) {\n    p(this, \"options\");\n    // fulfill in traverse call\n    p(this, \"root\", null);\n    // tiles should be rendered\n    p(this, \"selectedTiles\", {});\n    // tiles should be loaded from server\n    p(this, \"requestedTiles\", {});\n    // tiles does not have render content\n    p(this, \"emptyTiles\", {});\n    p(this, \"lastUpdate\", (/* @__PURE__ */ new Date()).getTime());\n    p(this, \"updateDebounceTime\", 1e3);\n    /** temporary storage to hold the traversed tiles during a traversal */\n    p(this, \"_traversalStack\", new Io());\n    p(this, \"_emptyTraversalStack\", new Io());\n    /** set in every traverse cycle */\n    p(this, \"_frameNumber\", null);\n    this.options = { ...AB, ...t };\n  }\n  // RESULT\n  traversalFinished(t) {\n    return !0;\n  }\n  // tiles should be visible\n  traverse(t, n, s) {\n    this.root = t, this.options = { ...this.options, ...s }, this.reset(), this.updateTile(t, n), this._frameNumber = n.frameNumber, this.executeTraversal(t, n);\n  }\n  reset() {\n    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();\n  }\n  /**\n   * Execute traverse\n   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n   * This is the traditional replacement refinement approach and is called the base traversal.\n   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n   * and rendering children and parent tiles simultaneously.\n   */\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(t, n) {\n    const s = this._traversalStack;\n    for (t._selectionDepth = 1, s.push(t); s.length > 0; ) {\n      const i = s.pop();\n      let o = !1;\n      this.canTraverse(i, n) && (this.updateChildTiles(i, n), o = this.updateAndPushChildren(i, n, s, i.hasRenderContent ? i._selectionDepth + 1 : i._selectionDepth));\n      const a = i.parent, c = !!(!a || a._shouldRefine), u = !o;\n      i.hasRenderContent ? i.refine === Ht.ADD ? (this.loadTile(i, n), this.selectTile(i, n)) : i.refine === Ht.REPLACE && (this.loadTile(i, n), u && this.selectTile(i, n)) : (this.emptyTiles[i.id] = i, this.loadTile(i, n), u && this.selectTile(i, n)), this.touchTile(i, n), i._shouldRefine = o && c;\n    }\n    const r = (/* @__PURE__ */ new Date()).getTime();\n    (this.traversalFinished(n) || r - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = r, this.options.onTraversalEnd(n));\n  }\n  updateChildTiles(t, n) {\n    const s = t.children;\n    for (const r of s)\n      this.updateTile(r, n);\n  }\n  /* eslint-disable complexity, max-statements */\n  updateAndPushChildren(t, n, s, r) {\n    const { loadSiblings: i, skipLevelOfDetail: o } = this.options, a = t.children;\n    a.sort(this.compareDistanceToCamera.bind(this));\n    const c = t.refine === Ht.REPLACE && t.hasRenderContent && !o;\n    let u = !1, l = !0;\n    for (const h of a)\n      if (h._selectionDepth = r, h.isVisibleAndInRequestVolume ? (s.find(h) && s.delete(h), s.push(h), u = !0) : (c || i) && (this.loadTile(h, n), this.touchTile(h, n)), c) {\n        let f;\n        if (h._inRequestVolume ? h.hasRenderContent ? f = h.contentAvailable : f = this.executeEmptyTraversal(h, n) : f = !1, l = l && f, !l)\n          return !1;\n      }\n    return u || (l = !1), l;\n  }\n  /* eslint-enable complexity, max-statements */\n  updateTile(t, n) {\n    this.updateTileVisibility(t, n);\n  }\n  // tile to render in the browser\n  selectTile(t, n) {\n    this.shouldSelectTile(t) && (t._selectedFrame = n.frameNumber, this.selectedTiles[t.id] = t);\n  }\n  // tile to load from server\n  loadTile(t, n) {\n    this.shouldLoadTile(t) && (t._requestedFrame = n.frameNumber, t._priority = t._getPriority(), this.requestedTiles[t.id] = t);\n  }\n  // cache tile\n  touchTile(t, n) {\n    t.tileset._cache.touch(t), t._touchedFrame = n.frameNumber;\n  }\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(t, n) {\n    return t.hasChildren ? t.hasTilesetContent ? !t.contentExpired : this.shouldRefine(t, n) : !1;\n  }\n  shouldLoadTile(t) {\n    return t.hasUnloadedContent || t.contentExpired;\n  }\n  shouldSelectTile(t) {\n    return t.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */\n  shouldRefine(t, n, s = !1) {\n    let r = t._screenSpaceError;\n    return s && (r = t.getScreenSpaceError(n, !0)), r > t.tileset.memoryAdjustedScreenSpaceError;\n  }\n  updateTileVisibility(t, n) {\n    const s = [];\n    if (this.options.viewportTraversersMap)\n      for (const r in this.options.viewportTraversersMap)\n        this.options.viewportTraversersMap[r] === n.viewport.id && s.push(r);\n    else\n      s.push(n.viewport.id);\n    t.updateVisibility(n, s);\n  }\n  // UTILITIES\n  compareDistanceToCamera(t, n) {\n    return t._distanceToCamera - n._distanceToCamera;\n  }\n  anyChildrenVisible(t, n) {\n    let s = !1;\n    for (const r of t.children)\n      r.updateVisibility(n), s = s || r.isVisibleAndInRequestVolume;\n    return s;\n  }\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(t, n) {\n    let s = !0;\n    const r = this._emptyTraversalStack;\n    for (r.push(t); r.length > 0; ) {\n      const i = r.pop(), o = !i.hasRenderContent && this.canTraverse(i, n), a = !i.hasRenderContent && i.children.length === 0;\n      if (!o && !i.contentAvailable && !a && (s = !1), this.updateTile(i, n), i.isVisibleAndInRequestVolume || (this.loadTile(i, n), this.touchTile(i, n)), o) {\n        const c = i.children;\n        for (const u of c)\n          r.push(u);\n      }\n    }\n    return s;\n  }\n}\nconst xo = new A();\nfunction pB(e) {\n  return e != null;\n}\nclass ur {\n  // TODO i3s specific, needs to remove\n  /**\n   * @constructs\n   * Create a Tile3D instance\n   * @param tileset - Tileset3D instance\n   * @param header - tile header - JSON loaded from a dataset\n   * @param parentHeader - parent Tile3D instance\n   * @param extendedId - optional ID to separate copies of a tile for different viewports.\n   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   */\n  // eslint-disable-next-line max-statements\n  constructor(t, n, s, r = \"\") {\n    p(this, \"tileset\");\n    p(this, \"header\");\n    p(this, \"id\");\n    p(this, \"url\");\n    p(this, \"parent\");\n    /* Specifies the type of refine that is used when traversing this tile for rendering. */\n    p(this, \"refine\");\n    p(this, \"type\");\n    p(this, \"contentUrl\");\n    /** Different refinement algorithms used by I3S and 3D tiles */\n    p(this, \"lodMetricType\", \"geometricError\");\n    /** The error, in meters, introduced if this tile is rendered and its children are not. */\n    p(this, \"lodMetricValue\", 0);\n    /** @todo math.gl is not exporting BoundingVolume base type? */\n    p(this, \"boundingVolume\", null);\n    /**\n     * The tile's content.  This represents the actual tile's payload,\n     * not the content's metadata in the tileset JSON file.\n     */\n    p(this, \"content\", null);\n    p(this, \"contentState\", lt.UNLOADED);\n    p(this, \"gpuMemoryUsageInBytes\", 0);\n    /** The tile's children - an array of Tile3D objects. */\n    p(this, \"children\", []);\n    p(this, \"depth\", 0);\n    p(this, \"viewportIds\", []);\n    p(this, \"transform\", new V());\n    p(this, \"extensions\", null);\n    /** TODO Cesium 3d tiles specific */\n    p(this, \"implicitTiling\", null);\n    /** Container to store application specific data */\n    p(this, \"userData\", {});\n    p(this, \"computedTransform\");\n    p(this, \"hasEmptyContent\", !1);\n    p(this, \"hasTilesetContent\", !1);\n    p(this, \"traverser\", new ts({}));\n    /** Used by TilesetCache */\n    p(this, \"_cacheNode\", null);\n    p(this, \"_frameNumber\", null);\n    // TODO Cesium 3d tiles specific\n    p(this, \"_expireDate\", null);\n    p(this, \"_expiredContent\", null);\n    p(this, \"_boundingBox\");\n    /** updated every frame for tree traversal and rendering optimizations: */\n    p(this, \"_distanceToCamera\", 0);\n    p(this, \"_screenSpaceError\", 0);\n    p(this, \"_visibilityPlaneMask\");\n    p(this, \"_visible\");\n    p(this, \"_contentBoundingVolume\");\n    p(this, \"_viewerRequestVolume\");\n    p(this, \"_initialTransform\", new V());\n    // Used by traverser, cannot be marked private\n    p(this, \"_priority\", 0);\n    p(this, \"_selectedFrame\", 0);\n    p(this, \"_requestedFrame\", 0);\n    p(this, \"_selectionDepth\", 0);\n    p(this, \"_touchedFrame\", 0);\n    p(this, \"_centerZDepth\", 0);\n    p(this, \"_shouldRefine\", !1);\n    p(this, \"_stackLength\", 0);\n    p(this, \"_visitedFrame\", 0);\n    p(this, \"_inRequestVolume\", !1);\n    p(this, \"_lodJudge\", null);\n    this.header = n, this.tileset = t, this.id = r || n.id, this.url = n.url, this.parent = s, this.refine = this._getRefine(n.refine), this.type = n.type, this.contentUrl = n.contentUrl, this._initializeLodMetric(n), this._initializeTransforms(n), this._initializeBoundingVolumes(n), this._initializeContent(n), this._initializeRenderingState(n), Object.seal(this);\n  }\n  destroy() {\n    this.header = null;\n  }\n  isDestroyed() {\n    return this.header === null;\n  }\n  get selected() {\n    return this._selectedFrame === this.tileset._frameNumber;\n  }\n  get isVisible() {\n    return this._visible;\n  }\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n  /** Returns true if tile is not an empty tile and not an external tileset */\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n  /** Returns true if tile has children */\n  get hasChildren() {\n    return this.children.length > 0 || this.header.children && this.header.children.length > 0;\n  }\n  /**\n   * Determines if the tile's content is ready. This is automatically `true` for\n   * tiles with empty content.\n   */\n  get contentReady() {\n    return this.contentState === lt.READY || this.hasEmptyContent;\n  }\n  /**\n   * Determines if the tile has available content to render.  `true` if the tile's\n   * content is ready or if it has expired content this renders while new content loads; otherwise,\n   */\n  get contentAvailable() {\n    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);\n  }\n  /** Returns true if tile has renderable content but it's unloaded */\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n  /**\n   * Determines if the tile's content has not be requested. `true` if tile's\n   * content has not be requested; otherwise, `false`.\n   */\n  get contentUnloaded() {\n    return this.contentState === lt.UNLOADED;\n  }\n  /**\n   * Determines if the tile's content is expired. `true` if tile's\n   * content is expired; otherwise, `false`.\n   */\n  get contentExpired() {\n    return this.contentState === lt.EXPIRED;\n  }\n  // Determines if the tile's content failed to load.  `true` if the tile's\n  // content failed to load; otherwise, `false`.\n  get contentFailed() {\n    return this.contentState === lt.FAILED;\n  }\n  /**\n   * Distance from the tile's bounding volume center to the camera\n   */\n  get distanceToCamera() {\n    return this._distanceToCamera;\n  }\n  /**\n   * Screen space error for LOD selection\n   */\n  get screenSpaceError() {\n    return this._screenSpaceError;\n  }\n  /**\n   * Get bounding box in cartographic coordinates\n   * @returns [min, max] each in [longitude, latitude, altitude]\n   */\n  get boundingBox() {\n    return this._boundingBox || (this._boundingBox = iB(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;\n  }\n  /** Get the tile's screen space error. */\n  getScreenSpaceError(t, n) {\n    switch (this.tileset.type) {\n      case At.I3S:\n        return Fc(this, t);\n      case At.TILES3D:\n        return fB(this, t, n);\n      default:\n        throw new Error(\"Unsupported tileset type\");\n    }\n  }\n  /**\n   * Make tile unselected than means it won't be shown\n   * but it can be still loaded in memory\n   */\n  unselect() {\n    this._selectedFrame = 0;\n  }\n  /**\n   * Memory usage of tile on GPU\n   */\n  _getGpuMemoryUsageInBytes() {\n    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;\n  }\n  /*\n   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n   * Tiles are prioritized by screen space error.\n   */\n  // eslint-disable-next-line complexity\n  _getPriority() {\n    const t = this.tileset._traverser, { skipLevelOfDetail: n } = t.options, s = this.refine === Ht.ADD || n;\n    if (s && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === lt.UNLOADED)\n      return -1;\n    const r = this.parent, o = r && (!s || this._screenSpaceError === 0 || r.hasTilesetContent) ? r._screenSpaceError : this._screenSpaceError, a = t.root ? t.root._screenSpaceError : 0;\n    return Math.max(a - o, 0);\n  }\n  /**\n   *  Requests the tile's content.\n   * The request may not be made if the Request Scheduler can't prioritize it.\n   */\n  // eslint-disable-next-line max-statements, complexity\n  async loadContent() {\n    if (this.hasEmptyContent)\n      return !1;\n    if (this.content)\n      return !0;\n    this.contentExpired && (this._expireDate = null), this.contentState = lt.LOADING;\n    const n = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));\n    if (!n)\n      return this.contentState = lt.UNLOADED, !1;\n    try {\n      const s = this.tileset.getTileUrl(this.contentUrl), r = this.tileset.loader, i = {\n        ...this.tileset.loadOptions,\n        [r.id]: {\n          // @ts-expect-error\n          ...this.tileset.loadOptions[r.id],\n          isTileset: this.type === \"json\",\n          ...this._getLoaderSpecificOptions(r.id)\n        }\n      };\n      return this.content = await Ae(s, r, i), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = lt.READY, this._onContentLoaded(), !0;\n    } catch (s) {\n      throw this.contentState = lt.FAILED, s;\n    } finally {\n      n.done();\n    }\n  }\n  // Unloads the tile's content.\n  unloadContent() {\n    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = lt.UNLOADED, !0;\n  }\n  /**\n   * Update the tile's visibility\n   * @param {Object} frameState - frame state for tile culling\n   * @param {string[]} viewportIds - a list of viewport ids that show this tile\n   * @return {void}\n   */\n  updateVisibility(t, n) {\n    if (this._frameNumber === t.frameNumber)\n      return;\n    const s = this.parent, r = s ? s._visibilityPlaneMask : dt.MASK_INDETERMINATE;\n    if (this.tileset._traverser.options.updateTransforms) {\n      const i = s ? s.computedTransform : this.tileset.modelMatrix;\n      this._updateTransform(i);\n    }\n    this._distanceToCamera = this.distanceToTile(t), this._screenSpaceError = this.getScreenSpaceError(t, !1), this._visibilityPlaneMask = this.visibility(t, r), this._visible = this._visibilityPlaneMask !== dt.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(t), this._frameNumber = t.frameNumber, this.viewportIds = n;\n  }\n  // Determines whether the tile's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n  visibility(t, n) {\n    const { cullingVolume: s } = t, { boundingVolume: r } = this;\n    return s.computeVisibilityWithPlaneMask(r, n);\n  }\n  // Assuming the tile's bounding volume intersects the culling volume, determines\n  // whether the tile's content's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n  contentVisibility() {\n    return !0;\n  }\n  /**\n   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n   * @param frameState The frame state.\n   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n   */\n  distanceToTile(t) {\n    const n = this.boundingVolume;\n    return Math.sqrt(Math.max(n.distanceSquaredTo(t.camera.position), 0));\n  }\n  /**\n   * Computes the tile's camera-space z-depth.\n   * @param frameState The frame state.\n   * @returns The distance, in meters.\n   */\n  cameraSpaceZDepth({ camera: t }) {\n    const n = this.boundingVolume;\n    return xo.subVectors(n.center, t.position), t.direction.dot(xo);\n  }\n  /**\n   * Checks if the camera is inside the viewer request volume.\n   * @param {FrameState} frameState The frame state.\n   * @returns {Boolean} Whether the camera is inside the volume.\n   */\n  insideViewerRequestVolume(t) {\n    const n = this._viewerRequestVolume;\n    return !n || n.distanceSquaredTo(t.camera.position) <= 0;\n  }\n  // TODO Cesium specific\n  // Update whether the tile has expired.\n  updateExpiration() {\n    if (pB(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const t = Date.now();\n      Date.lessThan(this._expireDate, t) && (this.contentState = lt.EXPIRED, this._expiredContent = this.content);\n    }\n  }\n  get extras() {\n    return this.header.extras;\n  }\n  // INTERNAL METHODS\n  _initializeLodMetric(t) {\n    \"lodMetricType\" in t ? this.lodMetricType = t.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn(\"3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType\")), \"lodMetricValue\" in t ? this.lodMetricValue = t.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn(\"3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue\"));\n  }\n  _initializeTransforms(t) {\n    this.transform = t.transform ? new V(t.transform) : new V();\n    const n = this.parent, s = this.tileset, r = n && n.computedTransform ? n.computedTransform.clone() : s.modelMatrix.clone();\n    this.computedTransform = new V(r).multiplyRight(this.transform);\n    const i = n && n._initialTransform ? n._initialTransform.clone() : new V();\n    this._initialTransform = new V(i).multiplyRight(this.transform);\n  }\n  _initializeBoundingVolumes(t) {\n    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(t);\n  }\n  _initializeContent(t) {\n    this.content = { _tileset: this.tileset, _tile: this }, this.hasEmptyContent = !0, this.contentState = lt.UNLOADED, this.hasTilesetContent = !1, t.contentUrl && (this.content = null, this.hasEmptyContent = !1);\n  }\n  // TODO - remove anything not related to basic visibility detection\n  _initializeRenderingState(t) {\n    this.depth = t.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = dt.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;\n  }\n  _getRefine(t) {\n    return t || this.parent && this.parent.refine || Ht.REPLACE;\n  }\n  _isTileset() {\n    return this.contentUrl.indexOf(\".json\") !== -1;\n  }\n  _onContentLoaded() {\n    switch (this.content && this.content.type) {\n      case \"vctr\":\n      case \"geom\":\n        this.tileset._traverser.disableSkipLevelOfDetail = !0;\n        break;\n    }\n    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();\n  }\n  _updateBoundingVolume(t) {\n    this.boundingVolume = Os(t.boundingVolume, this.computedTransform, this.boundingVolume);\n    const n = t.content;\n    n && (n.boundingVolume && (this._contentBoundingVolume = Os(n.boundingVolume, this.computedTransform, this._contentBoundingVolume)), t.viewerRequestVolume && (this._viewerRequestVolume = Os(t.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));\n  }\n  // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n  _updateTransform(t = new V()) {\n    const n = t.clone().multiplyRight(this.transform);\n    n.equals(this.computedTransform) || (this.computedTransform = n, this._updateBoundingVolume(this.header));\n  }\n  // Get options which are applicable only for the particular loader\n  _getLoaderSpecificOptions(t) {\n    switch (t) {\n      case \"i3s\":\n        return {\n          ...this.tileset.options.i3s,\n          _tileOptions: {\n            attributeUrls: this.header.attributeUrls,\n            textureUrl: this.header.textureUrl,\n            textureFormat: this.header.textureFormat,\n            textureLoaderOptions: this.header.textureLoaderOptions,\n            materialDefinition: this.header.materialDefinition,\n            isDracoGeometry: this.header.isDracoGeometry,\n            mbs: this.header.mbs\n          },\n          _tilesetOptions: {\n            store: this.tileset.tileset.store,\n            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,\n            fields: this.tileset.tileset.fields\n          },\n          isTileHeader: !1\n        };\n      case \"3d-tiles\":\n      case \"cesium-ion\":\n      default:\n        return gB(this.tileset.tileset);\n    }\n  }\n}\nclass yB extends ts {\n  compareDistanceToCamera(t, n) {\n    return n._distanceToCamera === 0 && t._distanceToCamera === 0 ? n._centerZDepth - t._centerZDepth : n._distanceToCamera - t._distanceToCamera;\n  }\n  updateTileVisibility(t, n) {\n    if (super.updateTileVisibility(t, n), !t.isVisibleAndInRequestVolume)\n      return;\n    const s = t.children.length > 0;\n    if (t.hasTilesetContent && s) {\n      const o = t.children[0];\n      this.updateTileVisibility(o, n), t._visible = o._visible;\n      return;\n    }\n    if (this.meetsScreenSpaceErrorEarly(t, n)) {\n      t._visible = !1;\n      return;\n    }\n    const r = t.refine === Ht.REPLACE, i = t._optimChildrenWithinParent === nB.USE_OPTIMIZATION;\n    if (r && i && s && !this.anyChildrenVisible(t, n)) {\n      t._visible = !1;\n      return;\n    }\n  }\n  meetsScreenSpaceErrorEarly(t, n) {\n    const { parent: s } = t;\n    return !s || s.hasTilesetContent || s.refine !== Ht.ADD ? !1 : !this.shouldRefine(t, n, !0);\n  }\n}\nclass BB {\n  constructor() {\n    p(this, \"frameNumberMap\", /* @__PURE__ */ new Map());\n  }\n  /**\n   * Register a new pending tile header for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   */\n  register(t, n) {\n    const s = this.frameNumberMap.get(t) || /* @__PURE__ */ new Map(), r = s.get(n) || 0;\n    s.set(n, r + 1), this.frameNumberMap.set(t, s);\n  }\n  /**\n   * Deregister a pending tile header for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   */\n  deregister(t, n) {\n    const s = this.frameNumberMap.get(t);\n    if (!s)\n      return;\n    const r = s.get(n) || 1;\n    s.set(n, r - 1);\n  }\n  /**\n   * Check is there are no pending tile headers registered for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   * @returns\n   */\n  isZero(t, n) {\n    var r;\n    return (((r = this.frameNumberMap.get(t)) == null ? void 0 : r.get(n)) || 0) === 0;\n  }\n}\nconst Ls = {\n  REQUESTED: \"REQUESTED\",\n  COMPLETED: \"COMPLETED\",\n  ERROR: \"ERROR\"\n};\nclass CB {\n  constructor() {\n    p(this, \"_statusMap\");\n    p(this, \"pendingTilesRegister\", new BB());\n    this._statusMap = {};\n  }\n  /**\n   * Add request to map\n   * @param request - node metadata request\n   * @param key - unique key\n   * @param callback - callback after request completed\n   * @param frameState - frameState data\n   */\n  add(t, n, s, r) {\n    if (!this._statusMap[n]) {\n      const { frameNumber: i, viewport: { id: o } } = r;\n      this._statusMap[n] = { request: t, callback: s, key: n, frameState: r, status: Ls.REQUESTED }, this.pendingTilesRegister.register(o, i), t().then((a) => {\n        this._statusMap[n].status = Ls.COMPLETED;\n        const { frameNumber: c, viewport: { id: u } } = this._statusMap[n].frameState;\n        this.pendingTilesRegister.deregister(u, c), this._statusMap[n].callback(a, r);\n      }).catch((a) => {\n        this._statusMap[n].status = Ls.ERROR;\n        const { frameNumber: c, viewport: { id: u } } = this._statusMap[n].frameState;\n        this.pendingTilesRegister.deregister(u, c), s(a);\n      });\n    }\n  }\n  /**\n   * Update request if it is still actual for the new frameState\n   * @param key - unique key\n   * @param frameState - frameState data\n   */\n  update(t, n) {\n    if (this._statusMap[t]) {\n      const { frameNumber: s, viewport: { id: r } } = this._statusMap[t].frameState;\n      this.pendingTilesRegister.deregister(r, s);\n      const { frameNumber: i, viewport: { id: o } } = n;\n      this.pendingTilesRegister.register(o, i), this._statusMap[t].frameState = n;\n    }\n  }\n  /**\n   * Find request in the map\n   * @param key - unique key\n   * @returns\n   */\n  find(t) {\n    return this._statusMap[t];\n  }\n  /**\n   * Check it there are pending tile headers for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   * @returns\n   */\n  hasPendingTiles(t, n) {\n    return !this.pendingTilesRegister.isZero(t, n);\n  }\n}\nclass EB extends ts {\n  constructor(n) {\n    super(n);\n    p(this, \"_tileManager\");\n    this._tileManager = new CB();\n  }\n  /**\n   * Check if there are no penging tile header requests,\n   * that means the traversal is finished and we can call\n   * following-up callbacks.\n   */\n  traversalFinished(n) {\n    return !this._tileManager.hasPendingTiles(n.viewport.id, this._frameNumber || 0);\n  }\n  shouldRefine(n, s) {\n    return n._lodJudge = mB(n, s), n._lodJudge === \"DIG\";\n  }\n  updateChildTiles(n, s) {\n    const r = n.header.children || [], i = n.children, o = n.tileset;\n    for (const a of r) {\n      const c = `${a.id}-${s.viewport.id}`, u = i && i.find((l) => l.id === c);\n      if (u)\n        u && this.updateTile(u, s);\n      else {\n        let l = () => this._loadTile(a.id, o);\n        this._tileManager.find(c) ? this._tileManager.update(c, s) : (o.tileset.nodePages && (l = () => o.tileset.nodePagesTile.formTileFromNodePages(a.id)), this._tileManager.add(l, c, (f) => this._onTileLoad(f, n, c), s));\n      }\n    }\n    return !1;\n  }\n  async _loadTile(n, s) {\n    const { loader: r } = s, i = s.getTileUrl(`${s.url}/nodes/${n}`), o = {\n      ...s.loadOptions,\n      i3s: {\n        ...s.loadOptions.i3s,\n        isTileHeader: !0\n      }\n    };\n    return await Ae(i, r, o);\n  }\n  /**\n   * The callback to init Tile3D instance after loading the tile JSON\n   * @param {Object} header - the tile JSON from a dataset\n   * @param {Tile3D} tile - the parent Tile3D instance\n   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   * @return {void}\n   */\n  _onTileLoad(n, s, r) {\n    const i = new ur(s.tileset, n, s, r);\n    s.children.push(i);\n    const o = this._tileManager.find(i.id).frameState;\n    this.updateTile(i, o), this._frameNumber === o.frameNumber && (this.traversalFinished(o) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(i, o);\n  }\n}\nconst TB = {\n  description: \"\",\n  ellipsoid: J.WGS84,\n  modelMatrix: new V(),\n  throttleRequests: !0,\n  maxRequests: 64,\n  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */\n  maximumMemoryUsage: 32,\n  memoryCacheOverflow: 1,\n  maximumTilesSelected: 0,\n  debounceTime: 0,\n  onTileLoad: () => {\n  },\n  onTileUnload: () => {\n  },\n  onTileError: () => {\n  },\n  onTraversalComplete: (e) => e,\n  contentLoader: void 0,\n  viewDistanceScale: 1,\n  maximumScreenSpaceError: 8,\n  memoryAdjustedScreenSpaceError: !1,\n  loadTiles: !0,\n  updateTransforms: !0,\n  viewportTraversersMap: null,\n  loadOptions: { fetch: {} },\n  attributions: [],\n  basePath: \"\",\n  i3s: {}\n}, Cn = \"Tiles In Tileset(s)\", Ps = \"Tiles In Memory\", vo = \"Tiles In View\", Oo = \"Tiles To Render\", Fo = \"Tiles Loaded\", Gs = \"Tiles Loading\", Do = \"Tiles Unloaded\", Lo = \"Failed Tile Loads\", Po = \"Points/Vertices\", Ns = \"Tile Memory Use\", Go = \"Maximum Screen Space Error\";\nclass bB {\n  /**\n   * Create a new Tileset3D\n   * @param json\n   * @param props\n   */\n  // eslint-disable-next-line max-statements\n  constructor(t, n) {\n    // props: Tileset3DProps;\n    p(this, \"options\");\n    p(this, \"loadOptions\");\n    p(this, \"type\");\n    p(this, \"tileset\");\n    p(this, \"loader\");\n    p(this, \"url\");\n    p(this, \"basePath\");\n    p(this, \"modelMatrix\");\n    p(this, \"ellipsoid\");\n    p(this, \"lodMetricType\");\n    p(this, \"lodMetricValue\");\n    p(this, \"refine\");\n    p(this, \"root\", null);\n    p(this, \"roots\", {});\n    /** @todo any->unknown */\n    p(this, \"asset\", {});\n    // Metadata for the entire tileset\n    p(this, \"description\", \"\");\n    p(this, \"properties\");\n    p(this, \"extras\", null);\n    p(this, \"attributions\", {});\n    p(this, \"credits\", {});\n    p(this, \"stats\");\n    /** flags that contain information about data types in nested tiles */\n    p(this, \"contentFormats\", { draco: !1, meshopt: !1, dds: !1, ktx2: !1 });\n    // view props\n    p(this, \"cartographicCenter\", null);\n    p(this, \"cartesianCenter\", null);\n    p(this, \"zoom\", 1);\n    p(this, \"boundingVolume\", null);\n    /** Updated based on the camera position and direction */\n    p(this, \"dynamicScreenSpaceErrorComputedDensity\", 0);\n    // METRICS\n    /**\n     * The maximum amount of GPU memory (in MB) that may be used to cache tiles\n     * Tiles not in view are unloaded to enforce private\n     */\n    p(this, \"maximumMemoryUsage\", 32);\n    /** The total amount of GPU memory in bytes used by the tileset. */\n    p(this, \"gpuMemoryUsageInBytes\", 0);\n    /**\n     * If loading the level of detail required by maximumScreenSpaceError\n     * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement\n     * will instead use this (larger) adjusted screen space error to achieve the\n     * best possible visual quality within the available memory.\n     */\n    p(this, \"memoryAdjustedScreenSpaceError\", 0);\n    p(this, \"_cacheBytes\", 0);\n    p(this, \"_cacheOverflowBytes\", 0);\n    /** Update tracker. increase in each update cycle. */\n    p(this, \"_frameNumber\", 0);\n    p(this, \"_queryParams\", {});\n    p(this, \"_extensionsUsed\", []);\n    p(this, \"_tiles\", {});\n    /** counter for tracking tiles requests */\n    p(this, \"_pendingCount\", 0);\n    /** Hold traversal results */\n    p(this, \"selectedTiles\", []);\n    // TRAVERSAL\n    p(this, \"traverseCounter\", 0);\n    p(this, \"geometricError\", 0);\n    p(this, \"lastUpdatedVieports\", null);\n    p(this, \"_requestedTiles\", []);\n    p(this, \"_emptyTiles\", []);\n    p(this, \"frameStateData\", {});\n    p(this, \"_traverser\");\n    p(this, \"_cache\", new zy());\n    p(this, \"_requestScheduler\");\n    // Promise tracking\n    p(this, \"updatePromise\", null);\n    p(this, \"tilesetInitializationPromise\");\n    this.options = { ...TB, ...n }, this.tileset = t, this.loader = t.loader, this.type = t.type, this.url = t.url, this.basePath = t.basePath || jy(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = t.lodMetricType, this.lodMetricValue = t.lodMetricValue, this.refine = t.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new Vy({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new qo({ id: this.url }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(t);\n  }\n  /** Release resources */\n  destroy() {\n    this._destroy();\n  }\n  /** Is the tileset loaded (update needs to have been called at least once) */\n  isLoaded() {\n    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n  }\n  get tiles() {\n    return Object.values(this._tiles);\n  }\n  get frameNumber() {\n    return this._frameNumber;\n  }\n  get queryParams() {\n    return new URLSearchParams(this._queryParams).toString();\n  }\n  setProps(t) {\n    this.options = { ...this.options, ...t };\n  }\n  /** @deprecated */\n  // setOptions(options: Tileset3DProps): void {\n  //   this.options = {...this.options, ...options};\n  // }\n  /**\n   * Return a loadable tile url for a specific tile subpath\n   * @param tilePath a tile subpath\n   */\n  getTileUrl(t) {\n    if (t.startsWith(\"data:\"))\n      return t;\n    let s = t;\n    return this.queryParams.length && (s = `${t}${t.includes(\"?\") ? \"&\" : \"?\"}${this.queryParams}`), s;\n  }\n  // TODO CESIUM specific\n  hasExtension(t) {\n    return this._extensionsUsed.indexOf(t) > -1;\n  }\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports - list of viewports\n   * @deprecated\n   */\n  update(t = null) {\n    this.tilesetInitializationPromise.then(() => {\n      !t && this.lastUpdatedVieports ? t = this.lastUpdatedVieports : this.lastUpdatedVieports = t, t && this.doUpdate(t);\n    });\n  }\n  /**\n   * Update visible tiles relying on a list of viewports.\n   * Do it with debounce delay to prevent update spam\n   * @param viewports viewports\n   * @returns Promise of new frameNumber\n   */\n  async selectTiles(t = null) {\n    return await this.tilesetInitializationPromise, t && (this.lastUpdatedVieports = t), this.updatePromise || (this.updatePromise = new Promise((n) => {\n      setTimeout(() => {\n        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), n(this._frameNumber), this.updatePromise = null;\n      }, this.options.debounceTime);\n    })), this.updatePromise;\n  }\n  adjustScreenSpaceError() {\n    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);\n  }\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports viewports\n   */\n  // eslint-disable-next-line max-statements, complexity\n  doUpdate(t) {\n    if (\"loadTiles\" in this.options && !this.options.loadTiles || this.traverseCounter > 0)\n      return;\n    const n = t instanceof Array ? t : [t];\n    this._cache.reset(), this._frameNumber++, this.traverseCounter = n.length;\n    const s = [];\n    for (const r of n) {\n      const i = r.id;\n      this._needTraverse(i) ? s.push(i) : this.traverseCounter--;\n    }\n    for (const r of n) {\n      const i = r.id;\n      if (this.roots[i] || (this.roots[i] = this._initializeTileHeaders(this.tileset, null)), !s.includes(i))\n        continue;\n      const o = Xy(r, this._frameNumber);\n      this._traverser.traverse(this.roots[i], o, this.options);\n    }\n  }\n  /**\n   * Check if traversal is needed for particular viewport\n   * @param {string} viewportId - id of a viewport\n   * @return {boolean}\n   */\n  _needTraverse(t) {\n    let n = t;\n    return this.options.viewportTraversersMap && (n = this.options.viewportTraversersMap[t]), n === t;\n  }\n  /**\n   * The callback to post-process tiles after traversal procedure\n   * @param frameState - frame state for tile culling\n   */\n  _onTraversalEnd(t) {\n    const n = t.viewport.id;\n    this.frameStateData[n] || (this.frameStateData[n] = { selectedTiles: [], _requestedTiles: [], _emptyTiles: [] });\n    const s = this.frameStateData[n], r = Object.values(this._traverser.selectedTiles), [i, o] = Qy(r, t, this.options.maximumTilesSelected);\n    s.selectedTiles = i;\n    for (const a of o)\n      a.unselect();\n    s._requestedTiles = Object.values(this._traverser.requestedTiles), s._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();\n  }\n  /**\n   * Update tiles relying on data from all traversers\n   */\n  _updateTiles() {\n    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];\n    for (const t in this.frameStateData) {\n      const n = this.frameStateData[t];\n      this.selectedTiles = this.selectedTiles.concat(n.selectedTiles), this._requestedTiles = this._requestedTiles.concat(n._requestedTiles), this._emptyTiles = this._emptyTiles.concat(n._emptyTiles);\n    }\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n    for (const t of this.selectedTiles)\n      this._tiles[t.id] = t;\n    this._loadTiles(), this._unloadTiles(), this._updateStats();\n  }\n  _tilesChanged(t, n) {\n    if (t.length !== n.length)\n      return !0;\n    const s = new Set(t.map((o) => o.id)), r = new Set(n.map((o) => o.id));\n    let i = t.filter((o) => !r.has(o.id)).length > 0;\n    return i = i || n.filter((o) => !s.has(o.id)).length > 0, i;\n  }\n  _loadTiles() {\n    for (const t of this._requestedTiles)\n      t.contentUnloaded && this._loadTile(t);\n  }\n  _unloadTiles() {\n    this._cache.unloadTiles(this, (t, n) => t._unloadTile(n));\n  }\n  _updateStats() {\n    let t = 0, n = 0;\n    for (const s of this.selectedTiles)\n      s.contentAvailable && s.content && (t++, s.content.pointCount ? n += s.content.pointCount : n += s.content.vertexCount);\n    this.stats.get(vo).count = this.selectedTiles.length, this.stats.get(Oo).count = t, this.stats.get(Po).count = n, this.stats.get(Go).count = this.memoryAdjustedScreenSpaceError;\n  }\n  async _initializeTileSet(t) {\n    this.type === At.I3S && (this.calculateViewPropsI3S(), t.root = await t.root), this.root = this._initializeTileHeaders(t, null), this.type === At.TILES3D && (this._initializeTiles3DTileset(t), this.calculateViewPropsTiles3D()), this.type === At.I3S && this._initializeI3STileset();\n  }\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset\n   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props\n   * @returns\n   */\n  calculateViewPropsI3S() {\n    var s;\n    const t = this.tileset.fullExtent;\n    if (t) {\n      const { xmin: r, xmax: i, ymin: o, ymax: a, zmin: c, zmax: u } = t;\n      this.cartographicCenter = new A(r + (i - r) / 2, o + (a - o) / 2, c + (u - c) / 2), this.cartesianCenter = new A(), J.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = Sc(t, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    const n = (s = this.tileset.store) == null ? void 0 : s.extent;\n    if (n) {\n      const [r, i, o, a] = n;\n      this.cartographicCenter = new A(r + (o - r) / 2, i + (a - i) / 2, 0), this.cartesianCenter = new A(), J.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = tB(n, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    console.warn(\"Extent is not defined in the tileset header\"), this.cartographicCenter = new A(), this.zoom = 1;\n  }\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset.\n   * For 3DTiles the root tile data is used to calculate view props.\n   * @returns\n   */\n  calculateViewPropsTiles3D() {\n    const t = this.root, { center: n } = t.boundingVolume;\n    if (!n) {\n      console.warn(\"center was not pre-calculated for the root tile\"), this.cartographicCenter = new A(), this.zoom = 1;\n      return;\n    }\n    n[0] !== 0 || n[1] !== 0 || n[2] !== 0 ? (this.cartographicCenter = new A(), J.WGS84.cartesianToCartographic(n, this.cartographicCenter)) : this.cartographicCenter = new A(0, 0, -J.WGS84.radii[0]), this.cartesianCenter = n, this.zoom = Zy(t.boundingVolume, this.cartographicCenter);\n  }\n  _initializeStats() {\n    this.stats.get(Cn), this.stats.get(Gs), this.stats.get(Ps), this.stats.get(vo), this.stats.get(Oo), this.stats.get(Fo), this.stats.get(Do), this.stats.get(Lo), this.stats.get(Po), this.stats.get(Ns, \"memory\"), this.stats.get(Go);\n  }\n  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.\n  // eslint-disable-next-line max-statements\n  _initializeTileHeaders(t, n) {\n    var r;\n    const s = new ur(this, t.root, n);\n    if (n && (n.children.push(s), s.depth = n.depth + 1), this.type === At.TILES3D) {\n      const i = [];\n      for (i.push(s); i.length > 0; ) {\n        const o = i.pop();\n        this.stats.get(Cn).incrementCount();\n        const a = o.header.children || [];\n        for (const c of a) {\n          const u = new ur(this, c, o);\n          if ((r = u.contentUrl) != null && r.includes(\"?session=\")) {\n            const h = new URL(u.contentUrl).searchParams.get(\"session\");\n            h && (this._queryParams.session = h);\n          }\n          o.children.push(u), u.depth = o.depth + 1, i.push(u);\n        }\n      }\n    }\n    return s;\n  }\n  _initializeTraverser() {\n    let t;\n    switch (this.type) {\n      case At.TILES3D:\n        t = yB;\n        break;\n      case At.I3S:\n        t = EB;\n        break;\n      default:\n        t = ts;\n    }\n    return new t({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n  _destroyTileHeaders(t) {\n    this._destroySubtree(t);\n  }\n  async _loadTile(t) {\n    let n;\n    try {\n      this._onStartTileLoading(), n = await t.loadContent();\n    } catch (s) {\n      this._onTileLoadError(t, s instanceof Error ? s : new Error(\"load failed\"));\n    } finally {\n      this._onEndTileLoading(), this._onTileLoad(t, n);\n    }\n  }\n  _onTileLoadError(t, n) {\n    this.stats.get(Lo).incrementCount();\n    const s = n.message || n.toString(), r = t.url;\n    console.error(`A 3D tile failed to load: ${t.url} ${s}`), this.options.onTileError(t, s, r);\n  }\n  _onTileLoad(t, n) {\n    var s, r;\n    if (n) {\n      if (this.type === At.I3S) {\n        const i = ((r = (s = this.tileset) == null ? void 0 : s.nodePagesTile) == null ? void 0 : r.nodesInNodePages) || 0;\n        this.stats.get(Cn).reset(), this.stats.get(Cn).addCount(i);\n      }\n      t && t.content && Wy(t, t.content), this.updateContentTypes(t), this._addTileToCache(t), this.options.onTileLoad(t);\n    }\n  }\n  /**\n   * Update information about data types in nested tiles\n   * @param tile instance of a nested Tile3D\n   */\n  updateContentTypes(t) {\n    var n;\n    if (this.type === At.I3S)\n      switch (t.header.isDracoGeometry && (this.contentFormats.draco = !0), t.header.textureFormat) {\n        case \"dds\":\n          this.contentFormats.dds = !0;\n          break;\n        case \"ktx2\":\n          this.contentFormats.ktx2 = !0;\n          break;\n      }\n    else if (this.type === At.TILES3D) {\n      const { extensionsRemoved: s = [] } = ((n = t.content) == null ? void 0 : n.gltf) || {};\n      s.includes(\"KHR_draco_mesh_compression\") && (this.contentFormats.draco = !0), s.includes(\"EXT_meshopt_compression\") && (this.contentFormats.meshopt = !0), s.includes(\"KHR_texture_basisu\") && (this.contentFormats.ktx2 = !0);\n    }\n  }\n  _onStartTileLoading() {\n    this._pendingCount++, this.stats.get(Gs).incrementCount();\n  }\n  _onEndTileLoading() {\n    this._pendingCount--, this.stats.get(Gs).decrementCount();\n  }\n  _addTileToCache(t) {\n    this._cache.add(this, t, (n) => n._updateCacheStats(t));\n  }\n  _updateCacheStats(t) {\n    this.stats.get(Fo).incrementCount(), this.stats.get(Ps).incrementCount(), this.gpuMemoryUsageInBytes += t.gpuMemoryUsageInBytes || 0, this.stats.get(Ns).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();\n  }\n  _unloadTile(t) {\n    this.gpuMemoryUsageInBytes -= t.gpuMemoryUsageInBytes || 0, this.stats.get(Ps).decrementCount(), this.stats.get(Do).incrementCount(), this.stats.get(Ns).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(t), t.unloadContent();\n  }\n  // Traverse the tree and destroy all tiles\n  _destroy() {\n    const t = [];\n    for (this.root && t.push(this.root); t.length > 0; ) {\n      const n = t.pop();\n      for (const s of n.children)\n        t.push(s);\n      this._destroyTile(n);\n    }\n    this.root = null;\n  }\n  // Traverse the tree and destroy all sub tiles\n  _destroySubtree(t) {\n    const n = t, s = [];\n    for (s.push(n); s.length > 0; ) {\n      t = s.pop();\n      for (const r of t.children)\n        s.push(r);\n      t !== n && this._destroyTile(t);\n    }\n    n.children = [];\n  }\n  _destroyTile(t) {\n    this._cache.unloadTile(this, t), this._unloadTile(t), t.destroy();\n  }\n  _initializeTiles3DTileset(t) {\n    if (t.queryString) {\n      const n = new URLSearchParams(t.queryString), s = Object.fromEntries(n.entries());\n      this._queryParams = { ...this._queryParams, ...s };\n    }\n    if (this.asset = t.asset, !this.asset)\n      throw new Error(\"Tileset must have an asset property.\");\n    if (this.asset.version !== \"0.0\" && this.asset.version !== \"1.0\" && this.asset.version !== \"1.1\")\n      throw new Error(\"The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.\");\n    \"tilesetVersion\" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {\n      attributions: this.options.attributions || []\n    }, this.description = this.options.description || \"\", this.properties = t.properties, this.geometricError = t.geometricError, this._extensionsUsed = t.extensionsUsed || [], this.extras = t.extras;\n  }\n  _initializeI3STileset() {\n    this.loadOptions.i3s && \"token\" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);\n  }\n}\nfunction _B(e) {\n  let t = 0;\n  for (const s in e.attributes) {\n    const r = e.getAttribute(s);\n    t += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT;\n  }\n  const n = e.getIndex();\n  return t += n ? n.count * n.itemSize * n.array.BYTES_PER_ELEMENT : 0, t;\n}\nfunction Dc(e) {\n  const n = document.createElement(\"canvas\");\n  n.width = 64, n.height = 64;\n  const s = n.getContext(\"2d\");\n  s.rect(0, 0, 64, 64);\n  const r = s.createLinearGradient(0, 0, 64, 64);\n  for (let o = 0; o < e.length; o++) {\n    const a = e[o];\n    r.addColorStop(a[0], \"#\" + a[1].getHexString());\n  }\n  s.fillStyle = r, s.fill();\n  const i = new three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture(n);\n  return i.needsUpdate = !0, i.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, i.wrapS = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, i.wrapT = three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping, i.repeat.set(2, 2), i;\n}\nfunction No(e) {\n  e.updateMatrix(), e.updateMatrixWorld(), e.matrixWorldInverse.copy(e.matrixWorld).invert();\n  const t = new three__WEBPACK_IMPORTED_MODULE_0__.Frustum();\n  return t.setFromProjectionMatrix(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse)), t;\n}\nfunction wB(e) {\n  const t = new three__WEBPACK_IMPORTED_MODULE_0__.Group(), n = new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(10, 5), s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...e.projectPointOntoPlane([0, 0, 0])), r = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(e.normal.x, e.normal.y, e.normal.z), i = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(s).add(r);\n  n.lookAt(i), n.translate(s.x, s.y, s.z);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({ color: 65535, side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide }), a = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(n, o), c = new three__WEBPACK_IMPORTED_MODULE_0__.ArrowHelper(r, s, 5, 16776960);\n  return t.add(c), t.add(a), t;\n}\nfunction Uo(e) {\n  const { boundingVolume: t } = e;\n  let n = 0;\n  e.content && (n = Math.min(e.content.byteLength / 5e5, 1));\n  const s = new three__WEBPACK_IMPORTED_MODULE_0__.Color(n, 1, 0), r = new three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry(1, 1, 1), i = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n  t.halfAxes ? i.copy(Lc(t.halfAxes)) : t.radius && r.scale(t.radius * 2, t.radius * 2, t.radius * 2), r.applyMatrix4(i);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.EdgesGeometry(r), a = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(o, new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial({ color: s }));\n  return a.position.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...t.center)), a;\n}\nfunction Lc(e) {\n  const t = e;\n  return new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray([\n    t[0] * 2,\n    t[1] * 2,\n    t[2] * 2,\n    0,\n    t[3] * 2,\n    t[4] * 2,\n    t[5] * 2,\n    0,\n    t[6] * 2,\n    t[7] * 2,\n    t[8] * 2,\n    0,\n    0,\n    0,\n    0,\n    1\n  ]);\n}\nfunction RB(e, t) {\n  const r = 2 * Math.PI * 6378137 / 2, i = t * r / 180;\n  let o = Math.log(Math.tan((90 + e) * Math.PI / 360)) / (Math.PI / 180);\n  return o = o * r / 180, new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(i, o);\n}\nfunction MB(e) {\n  let t = 0;\n  if ((e == null ? void 0 : e.userData.mimeType) == \"image/ktx2\" && e.mipmaps) {\n    for (let n = 0; n < e.mipmaps.length; n++)\n      t += e.mipmaps[n].data.byteLength;\n    return t;\n  } else if (e.image) {\n    const { image: n } = e, s = 4;\n    let r = [n.width, n.height];\n    for (; r[0] > 1 || r[1] > 1; )\n      t += r[0] * r[1] * s, r[0] = Math.max(Math.floor(r[0] / 2), 1), r[1] = Math.max(Math.floor(r[1] / 2), 1);\n    return t += 1 * 1 * s, t;\n  } else\n    return;\n}\nfunction Pc(e) {\n  return _B(e);\n}\nlet ht = null, Mt = null, Jn = null, Mn = null;\nconst Ho = {\n  minHeight: 0,\n  maxHeight: 300,\n  samples: 4,\n  sampleStep: 4,\n  opacity: 0.5,\n  blendingType: three__WEBPACK_IMPORTED_MODULE_0__.NormalBlending\n};\nfunction SB(e, t, n, s = Ho) {\n  ht && ht.dispose(), Mt || (Mt = n);\n  const r = { ...Ho, ...s };\n  ht = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(e.width * e.devicePixelRatio, e.height * e.devicePixelRatio), ht.texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter, ht.texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter, ht.stencilBuffer = !1, ht.texture.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, ht.texture.type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType, Mt.setPixelRatio(devicePixelRatio), Mt.setSize(e.width, e.height), Mt.setRenderTarget(ht), Jn = new three__WEBPACK_IMPORTED_MODULE_0__.Scene(), Jn.overrideMaterial = vB, Mn = t, kt.uniforms.tPosition.value = ht.texture, kt.uniforms.minHeight.value = r.minHeight, kt.uniforms.maxHeight.value = r.maxHeight, kt.uniforms.samples.value = r.samples, kt.uniforms.sampleStep.value = r.sampleStep, kt.uniforms.opacity.value = r.opacity, kt.blending = r.blendingType;\n}\nfunction IB(e) {\n  ht.setSize(e.width * e.devicePixelRatio, e.height * e.devicePixelRatio), Mt.setPixelRatio(devicePixelRatio), Mt.setSize(e.width, e.height);\n}\nfunction xB(e) {\n  if (Mt) {\n    const t = Mn.parent;\n    Jn.add(Mn), Mt.setRenderTarget(ht), Mt.render(Jn, e), t && t.add(Mn), Mt.setRenderTarget(null);\n  }\n}\nconst Vn = (e) => e.toString(), vB = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n  vertexShader: Vn`\n        varying vec3 vPosition;\n        void main() {\n            vPosition =  (modelMatrix * vec4(position, 1.0)).xyz;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n    `,\n  fragmentShader: Vn`\n        varying vec3 vPosition;\n        void main() {\n            gl_FragColor = vec4(vPosition, 1.0);\n        }\n    `,\n  side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n}), OB = Vn`\n    #include <packing>\n\n    varying vec2 vUv;\n    varying vec3 vColor;\n    uniform sampler2D tPosition;\n    uniform float minHeight;\n    uniform float maxHeight;\n    uniform int samples;\n    uniform float sampleStep;\n\n    mat4 MVP;\n\n    // Convert to normalized screen coordinates\n    vec4 toNSC(const in vec4 v) {\n        return vec4(0.5 * (v.xyz / v.w) + 0.5, v.w);\n    }\n    vec4 vertexDraping(\n        const in sampler2D positionTex, // Position G-Buffer\n        const in vec4 Vin // Vertex to drape\n    ) {\n        float texSize = float(textureSize(positionTex, 0).x);\n        float pixelSize = 1.0 / texSize;\n        vec2 stepSize = vec2(sampleStep/texSize);\n        vec4 VinWorld = modelMatrix * Vin;\n\n        vec4 lineStart = projectionMatrix * viewMatrix * vec4(VinWorld.x, minHeight, VinWorld.z, 1.0);\n        vec4 lineEnd = projectionMatrix * viewMatrix * vec4(VinWorld.x, maxHeight, VinWorld.z, 1.0);\n\n        vec4 Vout = VinWorld;\n\n        // Binary search for line-terrain intersection\n        float first = 0.0, last = 1.0;\n        while(first <= last) {\n            // Compute mid-point\n            float mid = first + (last-first) / 2.0;\n            // Compute texture coordinates along line\n            vec4 texCoords = toNSC(mix(lineStart, lineEnd, mid));\n            vec4 texSample = vec4(0.0); // Sample terrain\n            for(int s = -samples; s < samples; s++) {\n                for(int t = -samples; t < samples; t++) {\n                    texSample += texture(positionTex,\n                    texCoords.st + vec2(s,t) * stepSize);\n                }\n            }\n            // Smooth samples obtain from G-Buffer\n            texSample = texSample / (float(samples) * float(samples) * 4.0);\n            float terrainHeight = texSample.y;\n            Vout.y = terrainHeight;\n           \n            if((last-first) < pixelSize) { // Termination criteria\n                return Vout;\n            }\n            // Perform intersection test\n            float depthScene = toNSC(projectionMatrix * viewMatrix * Vout).y;\n            if(depthScene >= texCoords.y) {\n                first = mid;\n            }\n            else\n                last = mid;\n        }\n        return Vout;\n    }\n\n    void main() {\n        vColor = color;\n        vUv = uv;\n        MVP = projectionMatrix * modelViewMatrix;\n        vec4 inputVertex = vec4(position, 1.0);\n        vec4 outputVertex = vertexDraping(tPosition, inputVertex);\n        vec4 finalPosition = projectionMatrix * viewMatrix * outputVertex;\n        gl_Position = finalPosition;\n    }\n`, FB = Vn`\n    varying vec3 vColor;\n    uniform float opacity;\n\n    void main() {\n        gl_FragColor = vec4(vColor, opacity);\n    }\n`, kt = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n  vertexShader: OB,\n  fragmentShader: FB,\n  uniforms: {\n    tPosition: { value: null },\n    minHeight: { value: 0 },\n    maxHeight: { value: 300 },\n    opacity: { value: 0.5 },\n    samples: { value: 4 },\n    sampleStep: { value: 4 }\n  },\n  vertexColors: !0,\n  transparent: !0,\n  depthTest: !1,\n  blending: three__WEBPACK_IMPORTED_MODULE_0__.NormalBlending\n}), Gc = {\n  // From chroma spectral http://gka.github.io/chroma.js/\n  SPECTRAL: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.3686, 0.3098, 0.6353)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1961, 0.5333, 0.7412)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4, 0.7608, 0.6471)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6706, 0.8667, 0.6431)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.9608, 0.5961)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0.749)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9961, 0.8784, 0.5451)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9922, 0.6824, 0.3804)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9569, 0.4275, 0.2627)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.8353, 0.2431, 0.3098)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6196, 39e-4, 0.2588)]\n  ],\n  PLASMA: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.241, 0.015, 0.61)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.387, 1e-3, 0.654)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.524, 0.025, 0.653)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.651, 0.125, 0.596)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.752, 0.227, 0.513)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.837, 0.329, 0.431)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.907, 0.435, 0.353)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.963, 0.554, 0.272)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.992, 0.681, 0.195)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.987, 0.822, 0.144)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.94, 0.975, 0.131)]\n  ],\n  YELLOW_GREEN: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1647, 0.2824, 0.3451)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.1338, 0.3555, 0.4227)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.061, 0.4319, 0.4864)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0.5099, 0.5319)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0.5881, 0.5569)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.137, 0.665, 0.5614)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.2906, 0.7395, 0.5477)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.4453, 0.8099, 0.5201)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.6102, 0.8748, 0.485)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.7883, 0.9323, 0.4514)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9804, 0.9804, 0.4314)]\n  ],\n  VIRIDIS: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 5e-3, 0.329)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.283, 0.141, 0.458)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.254, 0.265, 0.53)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.207, 0.372, 0.553)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.164, 0.471, 0.558)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.128, 0.567, 0.551)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.135, 0.659, 0.518)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.267, 0.749, 0.441)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.478, 0.821, 0.318)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.741, 0.873, 0.15)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.993, 0.906, 0.144)]\n  ],\n  INFERNO: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.077, 0.042, 0.206)],\n    [0.1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.225, 0.036, 0.388)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.373, 0.074, 0.432)],\n    [0.3, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.522, 0.128, 0.42)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.665, 0.182, 0.37)],\n    [0.5, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.797, 0.255, 0.287)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.902, 0.364, 0.184)],\n    [0.7, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.969, 0.516, 0.063)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.683, 0.072)],\n    [0.9, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.961, 0.859, 0.298)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.988, 0.998, 0.645)]\n  ],\n  GRAYSCALE: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)]\n  ],\n  // 16 samples of the TURBU color scheme\n  // values taken from: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f\n  // original file licensed under Apache-2.0\n  TURBO: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.18995, 0.07176, 0.23217)],\n    [0.07, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25107, 0.25237, 0.63374)],\n    [0.13, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.27628, 0.42118, 0.89123)],\n    [0.2, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.25862, 0.57958, 0.99876)],\n    [0.27, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.15844, 0.73551, 0.92305)],\n    [0.33, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.09267, 0.86554, 0.7623)],\n    [0.4, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.19659, 0.94901, 0.59466)],\n    [0.47, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.42778, 0.99419, 0.38575)],\n    [0.53, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.64362, 0.98999, 0.23356)],\n    [0.6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.80473, 0.92452, 0.20459)],\n    [0.67, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.93301, 0.81236, 0.22667)],\n    [0.73, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.99314, 0.67408, 0.20348)],\n    [0.8, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.9836, 0.49291, 0.12849)],\n    [0.87, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.92105, 0.31489, 0.05475)],\n    [0.93, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.81608, 0.18462, 0.01809)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.66449, 0.08436, 424e-5)]\n  ],\n  RAINBOW: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0.278, 0, 0.714)],\n    [1 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 1)],\n    [2 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 1)],\n    [3 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 0)],\n    [4 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0)],\n    [5 / 6, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0.64, 0)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0, 0)]\n  ],\n  CONTOUR: [\n    [0, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\n    [0.03, new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0)],\n    [0.04, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)],\n    [1, new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1)]\n  ]\n}, DB = `\n  varying vec3 vColor;\n  uniform float alpha;\n\n  void main() {\n    if (vColor == vec3(0.0, 0.0, 0.0)) {\n      discard;\n    } else {\n      gl_FragColor = vec4( vColor, alpha);\n    }\n  }\n`, LB = `\n  varying vec3 vColor;\n  uniform sampler2D gradient;\n  uniform sampler2D grayscale;\n  attribute float intensity;\n  attribute float classification;\n  uniform vec3 rootCenter;\n  uniform vec3 rootNormal;\n  uniform vec2 elevationRange;\n  uniform int coloring;\n  uniform bool hideGround;\n  uniform float maxIntensity;\n  uniform float intensityContrast;\n  uniform float pointSize;\n\n  #ifdef USE_COLOR\n  vec3 getRGB() {\n      vec3 rgb = color;\n      return rgb;\n  }\n  #endif\n\n  vec3 getElevation(){\n    vec4 world = modelMatrix * vec4( position, 1.0 );\n    float diff = abs(dot(rootNormal, (vec3(world) - rootCenter)));\n    float w = max(diff - elevationRange.x,0.0) / max(elevationRange.y - elevationRange.x,1.0);\n    vec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\n\n    return cElevation;\n  }\n\n  vec3 getIntensity(){\n    // TODO: real contrast enhancement. Check https://github.com/yuki-koyama/enhancer/blob/master/shaders/enhancer.fs\n    float intmod = pow(intensity, intensityContrast);\n    vec3 cIntensity = texture2D(grayscale, vec2(intmod / maxIntensity ,1.0-(intmod / maxIntensity))).rgb;\n    return cIntensity;\n  }\n\n  vec3 getClassification(){\n    float classNormalized = classification / 255.0;\n    vec3 cClassification = texture2D(gradient, vec2(classNormalized * 5.0,1.0-classNormalized * 5.0)).rgb;\n    return cClassification;\n  }\n\n  vec3 getColor(){\n      vec3 color;\n      if (hideGround && classification == 2.0) {\n         return vec3(0.0, 0.0, 0.0);               \n      }\n\n      if (coloring == 1) {\n        color = getIntensity();\n      }\n      else if (coloring == 2) {\n        color = getClassification();\n      } else if (coloring == 3) {\n        color = getElevation();\n      } \n      #ifdef USE_COLOR\n      else if (coloring == 4) {\n        color = getRGB();\n      }\n      #endif\n      else {\n        color = vec3(1.0, 1.0, 1.0);\n      }\n      return color;\n  }\n\n  void main() {\n      vColor = getColor();\n\n      gl_PointSize = pointSize;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n`;\nvar Nc = /* @__PURE__ */ ((e) => (e[e.Intensity = 1] = \"Intensity\", e[e.Classification = 2] = \"Classification\", e[e.Elevation = 3] = \"Elevation\", e[e.RGB = 4] = \"RGB\", e[e.White = 5] = \"White\", e))(Nc || {}), jn = /* @__PURE__ */ ((e) => (e[e.FlatTexture = 1] = \"FlatTexture\", e[e.ShadedTexture = 2] = \"ShadedTexture\", e[e.ShadedNoTexture = 3] = \"ShadedNoTexture\", e))(jn || {});\nconst PB = Gc.RAINBOW, GB = typeof document < \"u\" ? Dc(PB) : null, NB = Gc.GRAYSCALE, UB = typeof document < \"u\" ? Dc(NB) : null, HB = {\n  throttleRequests: !0,\n  maxRequests: 64,\n  updateInterval: 0.1,\n  maxConcurrency: 1,\n  maximumScreenSpaceError: 16,\n  memoryAdjustedScreenSpaceError: !0,\n  maximumMemoryUsage: 400,\n  memoryCacheOverflow: 128,\n  viewDistanceScale: 1,\n  skipLevelOfDetail: !1,\n  resetTransform: !1,\n  updateTransforms: !0,\n  shading: jn.FlatTexture,\n  transparent: !1,\n  pointCloudColoring: Nc.White,\n  pointSize: 1,\n  worker: !0,\n  wireframe: !1,\n  debug: !1,\n  gltfLoader: null,\n  basisTranscoderPath: null,\n  dracoDecoderPath: null,\n  material: null,\n  contentPostProcess: void 0,\n  preloadTilesCount: null,\n  collectAttributions: !1\n};\nclass qB {\n  /**\n  * Loads a tileset of 3D Tiles according to the given {@link LoaderProps}\n  * @public\n  *\n  * @param props - Properties for this load call {@link LoaderProps}.\n  * @returns An object containing the 3D Model to be added to the scene\n  * and a runtime engine to be updated every frame.\n  */\n  static async load(t) {\n    const n = { ...HB, ...t.options }, { url: s } = t;\n    let { viewport: r, renderer: i } = t;\n    const o = n.updateInterval, a = 5, c = {};\n    if (n.cesiumIONToken) {\n      c[\"cesium-ion\"] = {\n        accessToken: n.cesiumIONToken\n      };\n      const T = await Ec.preload(s, c);\n      c.fetch = { headers: T.headers };\n    }\n    n.googleApiKey && (c.fetch = { headers: { \"X-GOOG-API-KEY\": n.googleApiKey } }, t.options.hasOwnProperty(\"collectAttributions\") || (n.collectAttributions = !0)), t.loadingManager && t.loadingManager.itemStart(s);\n    const u = await Ae(s, Le, {\n      ...c\n    }), l = {}, h = {}, f = [], d = new three__WEBPACK_IMPORTED_MODULE_0__.Group(), m = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    n.debug || (m.visible = !1);\n    const g = {\n      pointSize: { type: \"f\", value: n.pointSize },\n      gradient: { type: \"t\", value: GB },\n      grayscale: { type: \"t\", value: UB },\n      rootCenter: { type: \"vec3\", value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() },\n      rootNormal: { type: \"vec3\", value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3() },\n      coloring: { type: \"i\", value: n.pointCloudColoring },\n      hideGround: { type: \"b\", value: !0 },\n      elevationRange: { type: \"vec2\", value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 400) },\n      maxIntensity: { type: \"f\", value: 1 },\n      intensityContrast: { type: \"f\", value: 1 },\n      alpha: { type: \"f\", value: 1 }\n    }, y = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n      uniforms: g,\n      vertexShader: LB,\n      fragmentShader: DB,\n      transparent: n.transparent,\n      vertexColors: !0\n    });\n    let E, R, B;\n    n.gltfLoader ? E = n.gltfLoader : (E = new three__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader(), n.basisTranscoderPath && (R = new three__WEBPACK_IMPORTED_MODULE_0__.KTX2Loader(), R.detectSupport(i ?? new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer()), R.setTranscoderPath(n.basisTranscoderPath + \"/\"), R.setWorkerLimit(1), E.setKTX2Loader(R)), n.dracoDecoderPath && (B = new three__WEBPACK_IMPORTED_MODULE_0__.DRACOLoader(), B.setDecoderPath(n.dracoDecoderPath + \"/\"), B.setWorkerLimit(n.maxConcurrency), E.setDRACOLoader(B)));\n    const C = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({ transparent: n.transparent }), M = {\n      maximumMemoryUsage: n.maximumMemoryUsage,\n      maximumScreenSpaceError: n.maximumScreenSpaceError,\n      memoryAdjustedScreenSpaceError: n.memoryAdjustedScreenSpaceError,\n      memoryCacheOverflow: n.memoryCacheOverflow,\n      viewDistanceScale: n.viewDistanceScale,\n      skipLevelOfDetail: n.skipLevelOfDetail,\n      updateTransforms: n.updateTransforms,\n      throttleRequests: n.throttleRequests,\n      maxRequests: n.maxRequests,\n      contentLoader: async (T) => {\n        let D = null;\n        switch (T.type) {\n          case Pe.POINTCLOUD: {\n            D = VB(T, y, n, Pt);\n            break;\n          }\n          case Pe.SCENEGRAPH:\n          case Pe.MESH: {\n            D = await JB(E, T, C, n, Pt);\n            break;\n          }\n        }\n        if (D && (D.visible = !1, l[T.id] = D, d.add(l[T.id]), n.debug)) {\n          const nt = Uo(T);\n          m.add(nt), h[T.id] = nt;\n        }\n      },\n      onTileLoad: async (T) => {\n        b && (n.resetTransform && !L && (T == null ? void 0 : T.depth) <= a && Xt(T), Wt = !0);\n      },\n      onTileUnload: (T) => {\n        f.push(T);\n      },\n      onTileError: (T, D) => {\n        console.warn(\"Tile error\", T.id, D);\n      },\n      onTraversalComplete(T) {\n        return n.collectAttributions && (k = kB(T)), T;\n      }\n    }, b = new bB(u, {\n      ...M,\n      loadOptions: {\n        ...c,\n        maxConcurrency: n.maxConcurrency,\n        worker: n.worker,\n        gltf: {\n          loadImages: !1\n        },\n        \"3d-tiles\": {\n          loadGLTF: !1\n        }\n      }\n    }), O = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), F = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    let L = !1, k = \"\";\n    if (b.root.boundingVolume ? (b.root.header.boundingVolume.region && console.warn(\"Cannot apply a model matrix to bounding volumes of type region. Tileset stays in original geo-coordinates.\"), F.setPosition(\n      b.root.boundingVolume.center[0],\n      b.root.boundingVolume.center[1],\n      b.root.boundingVolume.center[2]\n    )) : console.warn(\"Bounding volume not found, no transformations applied\"), n.debug) {\n      const T = Uo(b.root);\n      m.add(T), h[b.root.id] = T;\n    }\n    let X = !1, Q = !1;\n    g.rootCenter.value.copy(v), g.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).normalize()), b.stats.get(\"Loader concurrency\").count = n.maxConcurrency, b.stats.get(\"Maximum mem usage\").count = n.maximumMemoryUsage;\n    let P = 0, at = null, Wt = !0, oe = null;\n    const Be = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1 / 0, 1 / 0, 1 / 0);\n    let Lt = null;\n    d.updateMatrixWorld(!0);\n    const et = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(d.matrixWorld), Pt = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(et).invert();\n    n.resetTransform && Xt(b.root), n.debug && (h[b.root.id].applyMatrix4(O), m.matrixWorld.copy(d.matrixWorld));\n    function Xt(T) {\n      if (!T.boundingVolume.halfAxes)\n        return;\n      const D = T.boundingVolume.halfAxes, nt = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().extractRotation(Lc(D)).premultiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().extractRotation(Pt));\n      if (!new three__WEBPACK_IMPORTED_MODULE_0__.Euler().setFromRotationMatrix(nt).equals(new three__WEBPACK_IMPORTED_MODULE_0__.Euler())) {\n        L = !0;\n        const _t = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(\n          F.elements[12],\n          F.elements[13],\n          F.elements[14]\n        );\n        F.extractRotation(nt), F.setPosition(_t);\n      }\n      Ce();\n    }\n    function Ce() {\n      O.copy(et), n.resetTransform && O.multiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(F).invert()), b.modelMatrix = new V(O.toArray());\n    }\n    function $e(T, D, nt, ct) {\n      if (X || !ct)\n        return;\n      Lt || (Lt = new Dn({\n        fov: ct.fov / 180 * Math.PI,\n        aspectRatio: ct.aspect,\n        near: ct.near,\n        far: ct.far\n      }).sseDenominator, n.debug && console.log(\"Updated sse denonimator:\", Lt));\n      const ns = No(ct).planes.map((q) => new tt(q.normal.toArray(), q.constant)), Uc = new dt(ns), Jr = {\n        camera: {\n          position: Be.toArray()\n        },\n        height: nt.height * nt.devicePixelRatio,\n        frameNumber: T._frameNumber,\n        sseDenominator: Lt,\n        cullingVolume: Uc,\n        viewport: {\n          id: 0\n        }\n      };\n      T._cache.reset(), T._traverser.traverse(T.root, Jr, T.options);\n      for (const q of T.tiles)\n        q.selected ? D[q.id] ? D[q.id].visible = !0 : console.error(\"TILE SELECTED BUT NOT LOADED!!\", q.id) : D[q.id] && (D[q.id].visible = !1);\n      for (; f.length > 0; ) {\n        const q = f.pop();\n        D[q.id] && q.contentState == lt.UNLOADED && (d.remove(D[q.id]), Us(D[q.id]), delete D[q.id]), h[q.id] && (Us(h[q.id]), m.remove(h[q.id]), delete h[q.id]);\n      }\n      const ss = T.stats.get(\"Tiles Loaded\").count, Vr = T.stats.get(\"Tiles Loading\").count;\n      return t.onProgress && t.onProgress(\n        ss,\n        ss + Vr\n      ), t.loadingManager && !Q && Vr == 0 && (n.preloadTilesCount == null || ss >= n.preloadTilesCount) && (Q = !0, t.loadingManager.itemEnd(t.url)), Jr;\n    }\n    function es(T) {\n      const D = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), nt = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(), ct = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      T.decompose(D, nt, ct), d.position.copy(D), d.quaternion.copy(nt), d.scale.copy(ct), d.updateMatrix(), d.updateMatrixWorld(!0), et.copy(d.matrixWorld), Pt.copy(et).invert(), Ce();\n    }\n    return {\n      model: d,\n      runtime: {\n        getTileset: () => b,\n        getStats: () => b.stats,\n        getDataAttributions: () => k,\n        showTiles: (T) => {\n          m.visible = T;\n        },\n        setWireframe: (T) => {\n          n.wireframe = T, d.traverse((D) => {\n            D instanceof three__WEBPACK_IMPORTED_MODULE_0__.Mesh && (D.material.wireframe = T);\n          });\n        },\n        setDebug: (T) => {\n          n.debug = T, m.visible = T;\n        },\n        setShading: (T) => {\n          n.shading = T;\n        },\n        getTileBoxes: () => m,\n        setViewDistanceScale: (T) => {\n          b.options.viewDistanceScale = T, b._frameNumber++, $e(b, l, r, oe);\n        },\n        setMaximumScreenSpaceError: (T) => {\n          b.options.maximumScreenSpaceError = T, b._frameNumber++, $e(b, l, r, oe);\n        },\n        setHideGround: (T) => {\n          g.hideGround.value = T;\n        },\n        setPointCloudColoring: (T) => {\n          g.coloring.value = T;\n        },\n        setElevationRange: (T) => {\n          g.elevationRange.value.set(T[0], T[1]);\n        },\n        setMaxIntensity: (T) => {\n          g.maxIntensity.value = T;\n        },\n        setIntensityContrast: (T) => {\n          g.intensityContrast.value = T;\n        },\n        setPointAlpha: (T) => {\n          g.alpha.value = T;\n        },\n        getLatLongHeightFromPosition: (T) => {\n          const D = b.ellipsoid.cartesianToCartographic(\n            new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().copy(T).applyMatrix4(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(O).invert()).toArray()\n          );\n          return {\n            lat: D[1],\n            long: D[0],\n            height: D[2]\n          };\n        },\n        getPositionFromLatLongHeight: (T) => {\n          const D = b.ellipsoid.cartographicToCartesian([\n            T.long,\n            T.lat,\n            T.height\n          ]);\n          return new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(...D).applyMatrix4(O);\n        },\n        orientToGeocoord: (T) => {\n          const D = [T.long, T.lat, T.height], nt = b.ellipsoid.cartographicToCartesian(D), ct = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(b.ellipsoid.eastNorthUpToFixedFrame(nt)), _t = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationFromEuler(\n            new three__WEBPACK_IMPORTED_MODULE_0__.Euler(Math.PI / 2, Math.PI / 2, 0)\n          ), ns = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(ct).multiply(_t).invert();\n          es(ns);\n        },\n        getWebMercatorCoord: (T) => RB(T.lat, T.long),\n        getCameraFrustum: (T) => {\n          const nt = No(T).planes.map((_t) => new tt(_t.normal.toArray(), _t.constant)).map((_t) => wB(_t)), ct = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n          for (const _t of nt)\n            ct.add(_t);\n          return ct;\n        },\n        overlayGeoJSON: (T, D) => {\n          if (T.applyMatrix4(O), T.updateMatrixWorld(), !i)\n            throw new Error(\"GeoJSON draping requires a renderer reference via LoaderProps\");\n          return SB(r, d, i, D), T.material.dispose(), T.material = kt, T;\n        },\n        setViewport: (T) => {\n          r = T, Lt = null, Wt = !0, ht && IB(r);\n        },\n        setRenderer: (T) => {\n          i = T;\n        },\n        update: function(T, D) {\n          if (oe = D, P += T, ht && xB(D), b && P >= o) {\n            if (!et.equals(d.matrixWorld)) {\n              P = 0, et.copy(d.matrixWorld), n.updateTransforms && Ce();\n              const nt = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().setFromMatrixPosition(et);\n              g.rootCenter.value.copy(nt), g.rootNormal.value.copy(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1).applyMatrix4(et).normalize()), Pt.copy(et).invert(), n.debug && (h[b.root.id].matrixWorld.copy(O), h[b.root.id].applyMatrix4(et));\n            }\n            at == null ? at = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().copy(D.matrixWorld) : (Wt || jB(D, at)) && (P = 0, Wt = !1, b._frameNumber++, D.getWorldPosition(Be), at.copy(D.matrixWorld), $e(b, l, r, D));\n          }\n        },\n        dispose: function() {\n          for (X = !0, b._destroy(); d.children.length > 0; ) {\n            const T = d.children[0];\n            Us(T), d.remove(T);\n          }\n          for (; m.children.length > 0; ) {\n            const T = m.children[0];\n            m.remove(T), T.geometry.dispose(), T.material.dispose();\n          }\n          R && R.dispose(), B && B.dispose();\n        }\n      }\n    };\n  }\n  /**\n  * Loads a tileset of 3D Tiles according to the given {@link GeoJSONLoaderProps}\n  * Could be overlayed on geograpical 3D Tiles using {@link Runtime.overlayGeoJSON}\n  * @public\n  *\n  * @param props - Properties for this load call {@link GeoJSONLoaderProps}.\n  * @returns An object containing the 3D Model to be added to the scene\n  */\n  static async loadGeoJSON(t) {\n    const { url: n, height: s, featureToColor: r } = t;\n    return Ae(n, ke, { worker: !1, gis: { format: \"binary\" } }).then((i) => {\n      const o = i, a = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), c = o.polygons.positions.value.reduce((h, f, d, m) => {\n        if (d % 2 == 0) {\n          const g = [f, m[d + 1], s ?? 0], y = J.WGS84.cartographicToCartesian(g);\n          h.push(...y);\n        }\n        return h;\n      }, []);\n      if (a.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(\n        c,\n        3\n      )), r) {\n        const h = o.polygons.numericProps[r.feature].value.reduce((f, d, m, g) => {\n          const y = r.colorMap(d);\n          return f[m * 3] = y.r, f[m * 3 + 1] = y.g, f[m * 3 + 2] = y.b, f;\n        }, []);\n        a.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(\n          h,\n          3\n        ));\n      }\n      a.setIndex(\n        new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(o.polygons.triangles.value, 1)\n      );\n      const u = new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n        transparent: !0,\n        vertexColors: !0,\n        opacity: 0.5,\n        blending: three__WEBPACK_IMPORTED_MODULE_0__.NormalBlending\n      });\n      return new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(a, u);\n    });\n  }\n}\nasync function JB(e, t, n, s, r) {\n  return new Promise((i, o) => {\n    const a = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationAxis(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0), Math.PI / 2), c = t.content.gltfUpAxis !== \"Z\", u = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(t.computedTransform).premultiply(r);\n    c && u.multiply(a), t.content.byteLength || (t.content.byteLength = t.content.gltfArrayBuffer.byteLength), e.parse(\n      t.content.gltfArrayBuffer,\n      t.contentUrl ? t.contentUrl.substr(0, t.contentUrl.lastIndexOf(\"/\") + 1) : null,\n      (l) => {\n        t.userData.asset = l.asset;\n        const h = l.scenes[0];\n        h.applyMatrix4(u), t.content.texturesByteLength = 0, t.content.geometriesByteLength = 0, h.traverse((f) => {\n          if (f.type == \"Mesh\") {\n            const d = f;\n            t.content.geometriesByteLength += Pc(d.geometry);\n            const m = d.material, g = m.map;\n            if (g) {\n              const y = MB(g);\n              y && (t.content.texturesByteLength += y);\n            }\n            s.material ? (d.material = s.material.clone(), m.dispose()) : s.shading == jn.FlatTexture && d.material.type !== \"MeshBasicMaterial\" && (d.material = n.clone(), m.dispose()), s.shading != jn.ShadedNoTexture ? d.material.type == \"ShaderMaterial\" ? d.material.uniforms.map = { value: g } : d.material.map = g : (g && g.dispose(), d.material.map = null), d.material.wireframe = s.wireframe, s.contentPostProcess && s.contentPostProcess(d);\n          }\n        }), t.content.gpuMemoryUsageInBytes = t.content.texturesByteLength + t.content.geometriesByteLength, i(h);\n      },\n      (l) => {\n        o(new Error(`error parsing gltf in tile ${t.id}: ${l}`));\n      }\n    );\n  });\n}\nfunction VB(e, t, n, s) {\n  const r = {\n    rtc_center: e.content.rtcCenter,\n    // eslint-disable-line camelcase\n    points: e.content.attributes.positions,\n    intensities: e.content.attributes.intensity,\n    classifications: e.content.attributes.classification,\n    rgb: null,\n    rgba: null\n  }, { colors: i } = e.content.attributes;\n  i && i.size === 3 && (r.rgb = i.value), i && i.size === 4 && (r.rgba = i.value);\n  const o = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  o.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(r.points, 3));\n  const a = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().fromArray(e.computedTransform).premultiply(s);\n  r.rgba ? o.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(r.rgba, 4)) : r.rgb && o.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(r.rgb, 3, !0)), r.intensities && o.setAttribute(\n    \"intensity\",\n    // Handles both 16bit or 8bit intensity values\n    new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(r.intensities, 1, !0)\n  ), r.classifications && o.setAttribute(\"classification\", new three__WEBPACK_IMPORTED_MODULE_0__.Uint8BufferAttribute(r.classifications, 1, !1)), e.content.geometriesByteLength = Pc(o), e.content.gpuMemoryUsageInBytes = e.content.geometriesByteLength;\n  const c = new three__WEBPACK_IMPORTED_MODULE_0__.Points(o, n.material || t);\n  if (r.rtc_center) {\n    const u = r.rtc_center;\n    a.multiply(new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeTranslation(u[0], u[1], u[2]));\n  }\n  return c.applyMatrix4(a), n.contentPostProcess && n.contentPostProcess(c), c;\n}\nfunction Jo(e) {\n  var t, n, s, r;\n  (t = e == null ? void 0 : e.uniforms) != null && t.map ? (s = (n = e == null ? void 0 : e.uniforms) == null ? void 0 : n.map.value) == null || s.dispose() : e.map && ((r = e.map) == null || r.dispose()), e.dispose();\n}\nfunction Us(e) {\n  e.traverse((t) => {\n    if (t.isMesh)\n      if (t.geometry.dispose(), t.material.isMaterial)\n        Jo(t.material);\n      else\n        for (const n of t.material)\n          Jo(n);\n  });\n  for (let t = e.children.length - 1; t >= 0; t--) {\n    const n = e.children[t];\n    e.remove(n);\n  }\n}\nfunction jB(e, t) {\n  return !e.matrixWorld.equals(t);\n}\nfunction kB(e) {\n  const t = /* @__PURE__ */ new Map();\n  return e.forEach((r) => {\n    var o, a;\n    const i = (a = (o = r == null ? void 0 : r.userData) == null ? void 0 : o.asset) == null ? void 0 : a.copyright;\n    i && i.split(/;/g).map((u) => u.trim()).forEach((u) => {\n      u && t.set(u, (t.get(u) || 0) + 1);\n    });\n  }), Array.from(t).sort((r, i) => i[1] - r[1]).map(([r]) => r).join(\"; \");\n}\n\n\n\n//# sourceURL=webpack://aframe-loader-3dtiles-component/./node_modules/three-loader-3dtiles/dist/lib/three-loader-3dtiles.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});